#!/bin/bash
# Combined Pre-Commit Hook:
# 1. AFP/SCAS guardrails (micro-batching, complexity control)
# 2. Credential leak detection

set -e

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

echo -e "${YELLOW}üîç AFP/SCAS Pre-Commit Checks...${NC}"

# ============================================================
# PART 1: AFP/SCAS Guardrails
# ============================================================

# Count files changed
FILES_CHANGED=$(git diff --cached --name-only | wc -l | tr -d ' ')

if [ $FILES_CHANGED -gt 5 ]; then
  echo -e "${RED}‚ùå BLOCKED: $FILES_CHANGED files changed (max: 5)${NC}"
  echo "   AFP micro-batching violation."
  echo "   Split this into smaller commits."
  echo ""
  echo "   See MANDATORY_WORK_CHECKLIST.md for full guidelines."
  exit 1
fi

# Count net LOC added
LOC_ADDED=$(git diff --cached --numstat | awk '{sum+=$1} END {print sum+0}')
LOC_DELETED=$(git diff --cached --numstat | awk '{sum+=$2} END {print sum+0}')
NET_LOC=$((LOC_ADDED - LOC_DELETED))

if [ $NET_LOC -gt 150 ]; then
  echo -e "${RED}‚ùå BLOCKED: +$NET_LOC net LOC (max: +150)${NC}"
  echo "   AFP micro-batching violation."
  echo "   Prefer deletion/refactoring over addition."
  echo ""
  echo "   See MANDATORY_WORK_CHECKLIST.md for full guidelines."
  exit 1
fi

# Check for common anti-patterns
DIFF=$(git diff --cached)

# Anti-pattern 1: Adding long functions (>50 lines)
ADDED_LINES=$(echo "$DIFF" | grep "^+" | wc -l | tr -d ' ')
if [ $ADDED_LINES -gt 50 ]; then
  # Check for function definitions
  FUNC_COUNT=$(echo "$DIFF" | grep -E "^\+.*function|^\+.*=>|^\+.*async " | wc -l | tr -d ' ')
  if [ $FUNC_COUNT -gt 0 ]; then
    AVG_LINES_PER_FUNC=$((ADDED_LINES / FUNC_COUNT))
    if [ $AVG_LINES_PER_FUNC -gt 50 ]; then
      echo -e "${YELLOW}‚ö†Ô∏è  WARNING: Adding function(s) >50 lines avg.${NC}"
      echo "   Consider extracting sub-functions (AFP modularity principle)."
    fi
  fi
fi

# Anti-pattern 2: Deep nesting (>3 levels)
DEEP_NESTING=$(echo "$DIFF" | grep "^+" | grep -E "      \{|      if|      for|      while" | wc -l | tr -d ' ')
if [ $DEEP_NESTING -gt 3 ]; then
  echo -e "${YELLOW}‚ö†Ô∏è  WARNING: Deep nesting detected (>3 levels).${NC}"
  echo "   Simplify control flow (AFP complexity principle)."
fi

# Anti-pattern 3: No deletions when adding code
if [ $LOC_ADDED -gt 50 ] && [ $LOC_DELETED -eq 0 ]; then
  echo -e "${YELLOW}‚ö†Ô∏è  WARNING: Adding $LOC_ADDED LOC without deleting anything.${NC}"
  echo "   Consider via negativa: can you simplify existing code instead?"
fi

echo -e "${GREEN}‚úÖ AFP/SCAS checks passed${NC}"
echo "   Files: $FILES_CHANGED/5, Net LOC: +$NET_LOC/+150"

# ============================================================
# PART 1b: Phase Evidence Enforcement (AFP 10-Phase Lifecycle)
# ============================================================

# For non-trivial changes (>2 files or >50 LOC), require phase evidence
if [ $FILES_CHANGED -gt 2 ] || [ $NET_LOC -gt 50 ]; then
  # Check if there are source code changes (not just docs/config)
  CODE_CHANGES=$(git diff --cached --name-only | grep -E '\.(ts|js|py|go|rs|java|cpp|c|h)$' | wc -l | tr -d ' ')

  if [ $CODE_CHANGES -gt 0 ]; then
    # Look for phase evidence in staged changes
    PHASE_EVIDENCE=$(git diff --cached --name-only | grep -E 'state/evidence/.*/phases\.md' | wc -l | tr -d ' ')

    if [ $PHASE_EVIDENCE -eq 0 ]; then
      echo -e "${RED}‚ùå GATE VIOLATION: You skipped phases 1-4. STOP CODING.${NC}"
      echo "   Changed: $FILES_CHANGED files, +$NET_LOC LOC, $CODE_CHANGES code files"
      echo ""
      echo -e "${RED}   YOU MUST GO BACK AND COMPLETE PHASES 1-4 PROPERLY:${NC}"
      echo ""
      echo "   1. STRATEGIZE - Understand WHY (not just WHAT)"
      echo "      ‚Üí What problem are you solving? What's the root cause?"
      echo "      ‚Üí How does this align with AFP/SCAS principles?"
      echo ""
      echo "   2. SPEC - Define success criteria and requirements"
      echo "      ‚Üí What does 'done' look like? What are acceptance criteria?"
      echo "      ‚Üí Functional + non-functional requirements?"
      echo ""
      echo "   3. PLAN - Design the approach using AFP/SCAS"
      echo "      ‚Üí Can you DELETE code instead of adding? (via negativa)"
      echo "      ‚Üí Can you REFACTOR instead of patching?"
      echo "      ‚Üí Which files need changes? How to keep it ‚â§5 files, ‚â§150 LOC?"
      echo ""
      echo "   4. THINK - Reason through edge cases and failure modes"
      echo "      ‚Üí What can go wrong? What are the edge cases?"
      echo "      ‚Üí Does this increase complexity? How to mitigate?"
      echo ""
      echo -e "${YELLOW}   Then document phases 1-4 in: state/evidence/[TASK-ID]/phases.md${NC}"
      echo "   And stage it: git add state/evidence/[TASK-ID]/phases.md"
      echo ""
      echo "   If you already coded without thinking: THAT'S THE PROBLEM."
      echo "   Revisit your design with AFP/SCAS lens before proceeding."
      echo ""
      echo "   See MANDATORY_WORK_CHECKLIST.md for full guidelines."
      exit 1
    fi

    echo -e "${GREEN}‚úÖ Phase evidence found${NC}"
  fi
fi

# ============================================================
# PART 2: Credential Leak Detection
# ============================================================

echo -e "${YELLOW}üîê Running credential leak detection...${NC}"

ERRORS=0

# Patterns to block (with exemptions for documentation/examples)
declare -a PATTERNS=(
    "sk-[A-Za-z0-9]{20,}"  # OpenAI key format (actual keys, not variables)
    "BEGIN RSA PRIVATE KEY"
    "BEGIN PRIVATE KEY"
    "BEGIN OPENSSH PRIVATE KEY"
    "-----END.*PRIVATE"
)

# File patterns to skip (documentation, examples, hooks)
SKIP_PATTERNS=(
    ".md$"
    ".example$"
    ".template$"
    ".githooks"
    "docs/"
    "credentials_manager"
)

# Get staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

for file in $STAGED_FILES; do
    # Skip files that are documentation or examples
    SKIP=0
    for skip_pattern in "${SKIP_PATTERNS[@]}"; do
        if [[ "$file" =~ $skip_pattern ]]; then
            SKIP=1
            break
        fi
    done

    if [ $SKIP -eq 1 ]; then
        continue
    fi

    # Check against patterns (only in source code, not docs)
    for pattern in "${PATTERNS[@]}"; do
        if git diff --cached "$file" | grep -E "$pattern" > /dev/null 2>&1; then
            echo -e "${RED}‚ùå BLOCKED: Potential credential in $file${NC}"
            echo "   Pattern: $pattern"
            ERRORS=$((ERRORS + 1))
        fi
    done

    # Block specific file extensions (these are credential stores)
    if [[ "$file" =~ auth\.json$ ]] || [[ "$file" =~ credentials\.json$ ]] || [[ "$file" =~ \.pem$ ]] || [[ "$file" =~ \.key$ ]] || [[ "$file" =~ \.p12$ ]] || [[ "$file" =~ \.pfx$ ]]; then
        echo -e "${RED}‚ùå BLOCKED: Credential file type in $file${NC}"
        ERRORS=$((ERRORS + 1))
    fi
done

if [ $ERRORS -gt 0 ]; then
    echo ""
    echo -e "${RED}‚ùå Commit blocked: Found $ERRORS potential credential leaks${NC}"
    echo ""
    echo "Guidelines:"
    echo "  1. Move credentials to .env (added to .gitignore)"
    echo "  2. Use environment variables instead"
    echo "  3. Use CredentialsManager for runtime loading"
    echo ""
    echo "To override (NOT RECOMMENDED):"
    echo "  git commit --no-verify"
    exit 1
fi

echo -e "${GREEN}‚úÖ No credential leaks detected${NC}"
echo ""
echo -e "${GREEN}üéâ All pre-commit checks passed!${NC}"
exit 0
