#!/bin/bash
# Combined Pre-Commit Hook:
# 1. AFP/SCAS guardrails (micro-batching, complexity control)
# 2. Credential leak detection

set -e

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

echo -e "${YELLOW}üîç AFP/SCAS Pre-Commit Checks...${NC}"

# ============================================================
# PART 1: AFP/SCAS Guardrails
# ============================================================

# Count files changed
FILES_CHANGED=$(git diff --cached --name-only | wc -l | tr -d ' ')

if [ $FILES_CHANGED -gt 5 ]; then
  echo -e "${RED}‚ùå BLOCKED: $FILES_CHANGED files changed (max: 5)${NC}"
  echo "   AFP micro-batching violation."
  echo "   Split this into smaller commits."
  echo ""
  echo "   See MANDATORY_WORK_CHECKLIST.md for full guidelines."
  exit 1
fi

# ============================================================
# Smart LOC Enforcement (context-aware, via negativa credits)
# Set USE_SMART_LOC=0 to fallback to flat 150 LOC limit
# ============================================================

if [ "${USE_SMART_LOC:-1}" = "1" ]; then
  echo -e "${YELLOW}üìä Running smart LOC analysis...${NC}"

  if node scripts/analyze_loc.mjs --staged; then
    LOC_EXIT=$?
    if [ $LOC_EXIT -eq 2 ]; then
      # Warning only (exit code 2), not blocking
      echo -e "${YELLOW}‚ö†Ô∏è  LOC warnings noted (not blocking)${NC}"
    else
      # Pass (exit code 0)
      echo -e "${GREEN}‚úÖ Smart LOC check passed${NC}"
    fi
  else
    # Blocked (exit code 1)
    echo ""
    echo -e "${RED}‚ùå BLOCKED by smart LOC enforcement${NC}"
    echo "   See analysis above for details."
    exit 1
  fi
else
  # Fallback: Flat 150 LOC limit (original logic)
  echo -e "${YELLOW}üìè Running flat LOC check (USE_SMART_LOC=0)...${NC}"

  LOC_ADDED=$(git diff --cached --numstat | awk '{sum+=$1} END {print sum+0}')
  LOC_DELETED=$(git diff --cached --numstat | awk '{sum+=$2} END {print sum+0}')
  NET_LOC=$((LOC_ADDED - LOC_DELETED))

  if [ $NET_LOC -gt 150 ]; then
    echo -e "${RED}‚ùå BLOCKED: +$NET_LOC net LOC (max: +150)${NC}"
    echo "   AFP micro-batching violation."
    echo "   Prefer deletion/refactoring over addition."
    echo ""
    echo "   See MANDATORY_WORK_CHECKLIST.md for full guidelines."
    exit 1
  fi

  echo -e "${GREEN}‚úÖ Flat LOC check passed${NC}"
  echo "   Net LOC: +$NET_LOC/+150"
fi

# Check for common anti-patterns
DIFF=$(git diff --cached)

# Anti-pattern 1: Adding long functions (>50 lines)
ADDED_LINES=$(echo "$DIFF" | grep "^+" | wc -l | tr -d ' ')
if [ $ADDED_LINES -gt 50 ]; then
  # Check for function definitions
  FUNC_COUNT=$(echo "$DIFF" | grep -E "^\+.*function|^\+.*=>|^\+.*async " | wc -l | tr -d ' ')
  if [ $FUNC_COUNT -gt 0 ]; then
    AVG_LINES_PER_FUNC=$((ADDED_LINES / FUNC_COUNT))
    if [ $AVG_LINES_PER_FUNC -gt 50 ]; then
      echo -e "${YELLOW}‚ö†Ô∏è  WARNING: Adding function(s) >50 lines avg.${NC}"
      echo "   Consider extracting sub-functions (AFP modularity principle)."
    fi
  fi
fi

# Anti-pattern 2: Deep nesting (>3 levels)
DEEP_NESTING=$(echo "$DIFF" | grep "^+" | grep -E "      \{|      if|      for|      while" | wc -l | tr -d ' ')
if [ $DEEP_NESTING -gt 3 ]; then
  echo -e "${YELLOW}‚ö†Ô∏è  WARNING: Deep nesting detected (>3 levels).${NC}"
  echo "   Simplify control flow (AFP complexity principle)."
fi

# Anti-pattern 3: No deletions when adding code
if [ $LOC_ADDED -gt 50 ] && [ $LOC_DELETED -eq 0 ]; then
  echo -e "${YELLOW}‚ö†Ô∏è  WARNING: Adding $LOC_ADDED LOC without deleting anything.${NC}"
  echo "   Consider via negativa: can you simplify existing code instead?"
fi

echo -e "${GREEN}‚úÖ AFP/SCAS checks passed${NC}"
echo "   Files: $FILES_CHANGED/5, Net LOC: +$NET_LOC/+150"

# ============================================================
# PART 1a: Five Forces Checks
# ============================================================

# Check for override first
if git config --get hooks.override >/dev/null 2>&1; then
  REASON=$(git config --get hooks.override)
  HASH=$(git rev-parse HEAD 2>/dev/null || echo "pending")
  TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  # Log override
  mkdir -p state
  echo "{\"timestamp\":\"$TIMESTAMP\",\"commit\":\"$HASH\",\"reason\":\"$REASON\"}" >> state/overrides.jsonl

  # Clear flag
  git config --unset hooks.override

  echo -e "${YELLOW}‚ö†Ô∏è  OVERRIDE used: $REASON${NC}"
  echo "   Logged to state/overrides.jsonl for weekly review"
  echo ""
else
  # Check for SKIP_AFP environment variable
  if [ -n "$SKIP_AFP" ]; then
    TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    mkdir -p state
    echo "{\"timestamp\":\"$TIMESTAMP\",\"commit\":\"pending\",\"reason\":\"SKIP_AFP environment variable\"}" >> state/overrides.jsonl

    echo -e "${YELLOW}‚ö†Ô∏è  AFP checks skipped via SKIP_AFP${NC}"
    echo "   Logged to state/overrides.jsonl for weekly review"
    echo ""
  else
    # Not a merge or revert commit (check HEAD for merge, message for revert)
    IS_MERGE=0
    IS_REVERT=0

    if git rev-parse -q --verify MERGE_HEAD >/dev/null 2>&1; then
      IS_MERGE=1
    fi

    # Get commit message (try multiple sources)
    COMMIT_MSG=$(git log -1 --pretty=%B 2>/dev/null || cat .git/COMMIT_EDITMSG 2>/dev/null || echo "")

    if echo "$COMMIT_MSG" | grep -q "^Revert"; then
      IS_REVERT=1
    fi

    # Check if this is a roadmap administrative commit
    IS_ROADMAP_CHORE=0
    if echo "$COMMIT_MSG" | grep -q "^chore(roadmap):"; then
      IS_ROADMAP_CHORE=1
    fi

    # Only check pattern for non-merge, non-revert, non-roadmap-chore commits
    if [ $IS_MERGE -eq 0 ] && [ $IS_REVERT -eq 0 ] && [ $IS_ROADMAP_CHORE -eq 0 ]; then
      # COHERENCE/EVOLUTION: Check for pattern reference
      if ! echo "$COMMIT_MSG" | grep -qE "(Pattern:|New pattern:)"; then
        echo -e "${RED}‚ùå BLOCKED: No pattern reference found${NC}"
        echo ""
        echo "   Five forces require COHERENCE + EVOLUTION checks:"
        echo "   Add 'Pattern: <name>' if reusing existing pattern"
        echo "   Add 'New pattern: <reason>' if creating new pattern"
        echo ""
        echo "   Examples:"
        echo "     Pattern: error_logging_with_context"
        echo "     New pattern: async error aggregation for batch processing"
        echo ""
        echo "   See: docs/AFP_QUICK_START.md for pattern examples"
        echo ""
        echo "   To override: git config hooks.override 'reason' && git commit"
        echo "   Or: SKIP_AFP=1 git commit (emergency only)"
        exit 1
      fi

      # ECONOMY: Check for deletion accounting if adding >50 LOC
      if [ $LOC_ADDED -gt 50 ]; then
        if ! echo "$COMMIT_MSG" | grep -qE "Deleted:"; then
          echo -e "${RED}‚ùå BLOCKED: +$LOC_ADDED LOC added without deletion accounting${NC}"
          echo ""
          echo "   Five forces require ECONOMY check:"
          echo "   If adding >50 LOC, document what you deleted/simplified"
          echo "   Add 'Deleted: <description>' to commit message"
          echo ""
          echo "   Examples:"
          echo "     Deleted: duplicate error handling in 3 files (-45 LOC)"
          echo "     Deleted: unused config validation function (-20 LOC)"
          echo "     Simplified: combined 2 validators into 1 (-30 LOC)"
          echo ""
          echo "   If genuinely can't delete:"
          echo "     git config hooks.override 'new feature requires additions' && git commit"
          exit 1
        fi
      fi

      echo -e "${GREEN}‚úÖ Five forces checks passed${NC}"
      if echo "$COMMIT_MSG" | grep -q "Pattern:"; then
        PATTERN_NAME=$(echo "$COMMIT_MSG" | grep "Pattern:" | sed 's/.*Pattern: *//' | head -1)
        echo "   Pattern: $PATTERN_NAME"
      else
        echo "   New pattern documented"
      fi
    else
      if [ $IS_MERGE -eq 1 ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Merge commit: skipping pattern check${NC}"
      fi
      if [ $IS_REVERT -eq 1 ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Revert commit: skipping pattern check${NC}"
      fi
    fi
  fi
fi

echo ""

# ============================================================
# PART 1c: README & Directory Health Sync (docsync)
# ============================================================

echo -e "${YELLOW}üìö README/structure sync (docsync)${NC}"

node --import tsx tools/docsync/index.ts update --mode staged --quiet || {
  STATUS=$?
  if [ $STATUS -ne 0 ]; then
    echo -e "${RED}‚ùå README automation flagged issues. Run 'npm run readme:update -- --mode staged' to review.${NC}"
    exit $STATUS
  fi
}


# ============================================================
# PART 1b: Design Evidence Enforcement (AFP/SCAS GATE)
# ============================================================

# For non-trivial changes (>1 file or >20 LOC), require design evidence
# Lower threshold = more thinking, but DesignReviewer provides guidance
if [ $FILES_CHANGED -gt 1 ] || [ $NET_LOC -gt 20 ]; then
  # Check if there are source code changes (not just docs/config)
  CODE_CHANGES=$(git diff --cached --name-only | grep -E '\.(ts|js|py|go|rs|java|cpp|c|h)$' | wc -l | tr -d ' ')

  if [ $CODE_CHANGES -gt 0 ]; then
    # Look for design evidence in staged changes (design.md preferred, phases.md accepted during migration)
    DESIGN_EVIDENCE=$(git diff --cached --name-only | grep -E 'state/evidence/.*/(design|phases)\.md' | wc -l | tr -d ' ')

    if [ $DESIGN_EVIDENCE -eq 0 ]; then
      echo -e "${RED}‚ùå GATE VIOLATION: No design documentation found${NC}"
      echo "   Changed: $FILES_CHANGED files, +$NET_LOC LOC, $CODE_CHANGES code files"
      echo ""
      echo -e "${RED}   STOP: You must document design thinking BEFORE implementing${NC}"
      echo ""
      echo "   AFP/SCAS requires thinking through:"
      echo "   ‚Ä¢ VIA NEGATIVA: Can you DELETE/SIMPLIFY instead of add?"
      echo "   ‚Ä¢ REFACTOR NOT REPAIR: Are you patching or refactoring properly?"
      echo "   ‚Ä¢ ALTERNATIVES: What other approaches did you consider?"
      echo "   ‚Ä¢ COMPLEXITY: Are increases justified?"
      echo ""
      echo -e "${YELLOW}   Create design documentation:${NC}"
      echo "   1. Copy template: cp docs/templates/design_template.md state/evidence/[TASK-ID]/design.md"
      echo "   2. Fill in your thinking (be honest about trade-offs)"
      echo "   3. Stage it: git add state/evidence/[TASK-ID]/design.md"
      echo ""
      echo "   DesignReviewer will provide INTELLIGENT FEEDBACK on your design."
      echo "   Goal: Stop compliance theater, ensure real thinking."
      echo ""
      echo "   See docs/templates/design_template.md for template."
      exit 1
    fi

    echo -e "${GREEN}‚úÖ Design evidence found${NC}"

    # If design.md is staged, run DesignReviewer to enforce quality
    DESIGN_MD_STAGED=$(git diff --cached --name-only | grep -E 'state/evidence/.*/design\.md$')

    if [ -n "$DESIGN_MD_STAGED" ]; then
      echo ""
      echo -e "${YELLOW}üîç Running DesignReviewer on staged design.md...${NC}"
      echo ""

      for DESIGN_FILE in $DESIGN_MD_STAGED; do
        TASK_ID=$(echo "$DESIGN_FILE" | sed -E 's|state/evidence/([^/]+)/design\.md|\1|')

        echo -e "${YELLOW}   ‚Ä¢ Reviewing $TASK_ID${NC}"
        cd tools/wvo_mcp
        if npm run gate:review "$TASK_ID"; then
          cd ../..
          echo -e "${GREEN}     ‚úÖ $TASK_ID approved${NC}"
        else
          EXIT_CODE=$?
          cd ../..

          if [ $EXIT_CODE -eq 1 ]; then
            echo ""
            echo -e "${RED}‚ùå GATE BLOCKED: Design needs revision${NC}"
            echo ""
            echo "   DesignReviewer found concerns with $TASK_ID/design.md"
            echo "   You MUST address these before committing."
            echo ""
            echo "   Iterative GATE process:"
            echo "   1. Read concerns above carefully"
            echo "   2. Create remediation task (new STRATEGIZE cycle)"
            echo "   3. Do actual research (30-60 min per critical issue)"
            echo "   4. Update upstream artifacts (strategy/spec/plan docs)"
            echo "   5. Update design.md with revised approach"
            echo "   6. Re-run: npm run gate:review $TASK_ID"
            echo "   7. Re-commit when approved"
            echo ""
            echo "   Expect multiple review rounds; that's healthy."
            exit 1
          else
            echo ""
            echo -e "${RED}‚ùå GATE ERROR: DesignReviewer failed${NC}"
            echo "   Check the error above."
            exit 1
          fi
        fi
      done
    fi
  fi
fi

# ============================================================
# PART 1c: Strategy Review Enforcement (AFP/SCAS Phase 1)
# ============================================================

# If strategy.md is staged, run StrategyReviewer to enforce quality
STRATEGY_MD_STAGED=$(git diff --cached --name-only | grep -E 'state/evidence/.*/strategy\.md$')

if [ -n "$STRATEGY_MD_STAGED" ]; then
  echo ""
  echo -e "${YELLOW}üîç Running StrategyReviewer on staged strategy.md...${NC}"
  echo ""

  for STRATEGY_FILE in $STRATEGY_MD_STAGED; do
    TASK_ID=$(echo "$STRATEGY_FILE" | sed -E 's|state/evidence/([^/]+)/strategy\.md|\1|')

    echo -e "${YELLOW}   ‚Ä¢ Reviewing $TASK_ID${NC}"
    cd tools/wvo_mcp
    if npm run strategy:review "$TASK_ID"; then
      cd ../..
      echo -e "${GREEN}     ‚úÖ $TASK_ID approved${NC}"
    else
      EXIT_CODE=$?
      cd ../..

      if [ $EXIT_CODE -eq 1 ]; then
        echo ""
        echo -e "${RED}‚ùå STRATEGY BLOCKED: Strategy needs deeper thinking${NC}"
        echo ""
        echo "   StrategyReviewer found concerns with $TASK_ID/strategy.md"
        echo "   You MUST address these before committing."
        echo ""
        echo "   Remediation process:"
        echo "   1. Read concerns above carefully"
        echo "   2. Do actual research (30-60 min per critical issue)"
        echo "   3. Update strategy.md with real analysis (not generic text)"
        echo "   4. Re-run: npm run strategy:review $TASK_ID"
        echo "   5. Re-commit when approved"
        echo ""
        echo "   2-3 review rounds is normal for quality strategic thinking."
        exit 1
      else
        echo ""
        echo -e "${RED}‚ùå STRATEGY ERROR: StrategyReviewer failed${NC}"
        echo "   Check the error above."
        exit 1
      fi
    fi
  done
fi

# ============================================================
# PART 1d: Thinking Review Enforcement (AFP/SCAS Phase 4)
# ============================================================

# If think.md is staged, run ThinkingCritic to enforce quality
THINK_MD_STAGED=$(git diff --cached --name-only | grep -E 'state/evidence/.*/think\.md$')

if [ -n "$THINK_MD_STAGED" ]; then
  echo ""
  echo -e "${YELLOW}üîç Running ThinkingCritic on staged think.md...${NC}"
  echo ""

  for THINK_FILE in $THINK_MD_STAGED; do
    TASK_ID=$(echo "$THINK_FILE" | sed -E 's|state/evidence/([^/]+)/think\.md|\1|')

    echo -e "${YELLOW}   ‚Ä¢ Reviewing $TASK_ID${NC}"
    cd tools/wvo_mcp
    if npm run think:review "$TASK_ID"; then
      cd ../..
      echo -e "${GREEN}     ‚úÖ $TASK_ID approved${NC}"
    else
      EXIT_CODE=$?
      cd ../..

      if [ $EXIT_CODE -eq 1 ]; then
        echo ""
        echo -e "${RED}‚ùå THINKING BLOCKED: Thinking needs deeper analysis${NC}"
        echo ""
        echo "   ThinkingCritic found concerns with $TASK_ID/think.md"
        echo "   You MUST address these before committing."
        echo ""
        echo "   Remediation process:"
        echo "   1. Read concerns above carefully"
        echo "   2. Do actual deep thinking (30-60 min per critical issue)"
        echo "   3. Update think.md with comprehensive analysis"
        echo "   4. Re-run: npm run think:review $TASK_ID"
        echo "   5. Re-commit when approved"
        echo ""
        echo "   If you find critical issues, GO BACK and revise STRATEGY/SPEC/PLAN."
        exit 1
      else
        echo ""
        echo -e "${RED}‚ùå THINKING ERROR: ThinkingCritic failed${NC}"
        echo "   Check the error above."
        exit 1
      fi
    fi
  done
fi

# ============================================================
# PART 2: Roadmap Task Completion Validation
# ============================================================

# Check if roadmap is being changed
if git diff --cached --name-only | grep -q "state/roadmap.yaml"; then
  echo ""
  echo -e "${YELLOW}üìã Validating roadmap task completion...${NC}"

  # Get the diff for roadmap changes
  ROADMAP_DIFF=$(git diff --cached state/roadmap.yaml)

  # Check if any task is being marked as "done"
  TASKS_MARKED_DONE=$(echo "$ROADMAP_DIFF" | grep -E '^\+.*status: done' | wc -l | tr -d ' ')

  if [ "$TASKS_MARKED_DONE" -gt 0 ]; then
    # Extract task IDs from the diff context (look for "id: AFP-*" or "id: TASK-*" before the status change)
    TASK_IDS=$(echo "$ROADMAP_DIFF" | awk '
      /^\+.*status: done/ {
        # Look backwards in buffer for task ID
        for (i = NR-1; i >= NR-20 && i >= 1; i--) {
          if (lines[i] ~ /- id: [A-Z]/) {
            match(lines[i], /id: ([A-Z0-9_-]+)/, arr)
            if (arr[1] != "") print arr[1]
            next
          }
        }
      }
      { lines[NR] = $0 }
    ' <<< "$ROADMAP_DIFF")

    # Validate each task being marked done
    VALIDATION_ERRORS=0
    for TASK_ID in $TASK_IDS; do
      EVIDENCE_PATH="state/evidence/$TASK_ID"

      if [ ! -d "$EVIDENCE_PATH" ]; then
        echo -e "${RED}‚ùå BLOCKED: Cannot mark $TASK_ID as done${NC}"
        echo "   Evidence directory missing: $EVIDENCE_PATH"
        VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
        continue
      fi

      # Check for required artifacts
      MISSING_ARTIFACTS=()

      if [ ! -f "$EVIDENCE_PATH/strategy.md" ]; then
        MISSING_ARTIFACTS+=("strategy.md (STRATEGIZE phase)")
      fi

      if [ ! -f "$EVIDENCE_PATH/spec.md" ]; then
        MISSING_ARTIFACTS+=("spec.md (SPEC phase)")
      fi

      if [ ! -f "$EVIDENCE_PATH/plan.md" ]; then
        MISSING_ARTIFACTS+=("plan.md (PLAN phase)")
      fi

      if [ ! -f "$EVIDENCE_PATH/think.md" ]; then
        MISSING_ARTIFACTS+=("think.md (THINK phase)")
      fi

      if [ ! -f "$EVIDENCE_PATH/verify.md" ]; then
        MISSING_ARTIFACTS+=("verify.md (VERIFY phase)")
      fi

      if [ ! -f "$EVIDENCE_PATH/review.md" ]; then
        MISSING_ARTIFACTS+=("review.md (REVIEW phase)")
      fi

      if [ ${#MISSING_ARTIFACTS[@]} -gt 0 ]; then
        echo ""
        echo -e "${RED}‚ùå BLOCKED: Cannot mark $TASK_ID as done${NC}"
        echo "   Evidence incomplete: $EVIDENCE_PATH"
        echo ""
        echo "   Missing required artifacts:"
        for artifact in "${MISSING_ARTIFACTS[@]}"; do
          echo "     ‚ùå $artifact"
        done
        echo ""
        echo "   Remediation:"
        echo "     1. Complete all required work process phases"
        echo "     2. Ensure all phase artifacts exist"
        echo "     3. Then mark task as done in roadmap"
        echo ""
        echo "   See MANDATORY_WORK_CHECKLIST.md for full work process."
        VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
      else
        echo -e "${GREEN}‚úÖ $TASK_ID evidence complete${NC}"
      fi
    done

    if [ $VALIDATION_ERRORS -gt 0 ]; then
      echo ""
      echo -e "${RED}‚ùå Roadmap validation failed: $VALIDATION_ERRORS task(s) have incomplete evidence${NC}"
      echo "   Cannot mark tasks as done without full evidence trail."
      exit 1
    fi
  fi
fi

# ============================================================
# PART 2.5: Work Process Phase Validation
# ============================================================

echo ""
echo -e "${YELLOW}üîÑ Validating work process phases...${NC}"

# Extract task ID from commit message or branch
COMMIT_MSG=$(git log -1 --pretty=%B 2>/dev/null || cat .git/COMMIT_EDITMSG 2>/dev/null || echo "")
TASK_ID=$(echo "$COMMIT_MSG" | grep -oE '\[([A-Z0-9_-]+)\]' | tr -d '[]' | head -1)

# Fallback 1: Check branch name
if [ -z "$TASK_ID" ]; then
  BRANCH=$(git branch --show-current 2>/dev/null || echo "")
  TASK_ID=$(echo "$BRANCH" | grep -oE 'AFP-[A-Z0-9_-]+|TASK-[A-Z0-9_-]+' | head -1)
fi

# Fallback 2: Check recent evidence directories
if [ -z "$TASK_ID" ]; then
  RECENT_EVIDENCE=$(find state/evidence -maxdepth 1 -type d -mtime -1 2>/dev/null | head -1)
  if [ -n "$RECENT_EVIDENCE" ]; then
    TASK_ID=$(basename "$RECENT_EVIDENCE")
  fi
fi

# Get staged files
STAGED_FILES=$(git diff --cached --name-only)

# Check if this is documentation-only or chore-only commit
DOC_ONLY=0
CHORE_ONLY=0

# Documentation patterns
if echo "$STAGED_FILES" | grep -qE '\.md$' && ! echo "$STAGED_FILES" | grep -qE '\.(ts|js|tsx|jsx)$'; then
  # Only markdown files, check if they're documentation
  if echo "$STAGED_FILES" | grep -qE '^docs/'; then
    DOC_ONLY=1
  fi
fi

# Chore patterns
CHORE_PATTERNS='^(package\.json|package-lock\.json|\.github/.*\.yml|\.gitignore|tsconfig\.json|.*\.config\.(js|ts|mjs))$'
ALL_FILES_CHORE=1
for file in $STAGED_FILES; do
  if ! echo "$file" | grep -qE "$CHORE_PATTERNS"; then
    ALL_FILES_CHORE=0
    break
  fi
done

if [ $ALL_FILES_CHORE -eq 1 ] && [ -n "$STAGED_FILES" ]; then
  CHORE_ONLY=1
fi

# Skip validation for doc-only or chore-only commits
if [ $DOC_ONLY -eq 1 ] || [ $CHORE_ONLY -eq 1 ]; then
  echo "‚úÖ Documentation/chore commit, skipping phase validation"
else
  # Detect implementation files
  IMPL_FILES=0
  IMPL_PATTERNS='^(src/|tools/.*/src/|apps/).*\.(ts|js|tsx|jsx)$'

  for file in $STAGED_FILES; do
    if echo "$file" | grep -qE "$IMPL_PATTERNS"; then
      IMPL_FILES=$((IMPL_FILES + 1))
    fi
  done

  # If implementation files present, validate phases
  if [ $IMPL_FILES -gt 0 ]; then
    if [ -z "$TASK_ID" ]; then
      echo ""
      echo -e "${RED}‚ùå BLOCKED: Cannot determine task ID${NC}"
      echo "   Add task ID to commit message: [AFP-TASK-ID]"
      echo "   Or create branch: git checkout -b AFP-TASK-ID"
      echo ""
      echo "   Implementation files require work process phase validation."
      exit 1
    fi

    EVIDENCE_PATH="state/evidence/$TASK_ID"

    # Check if evidence directory exists
    if [ ! -d "$EVIDENCE_PATH" ]; then
      # Allow first commit creating evidence
      if echo "$STAGED_FILES" | grep -q "^state/evidence/$TASK_ID/strategy\.md$"; then
        echo "‚úÖ First commit: creating evidence directory"
      else
        echo ""
        echo -e "${RED}‚ùå BLOCKED: No evidence directory for $TASK_ID${NC}"
        echo "   Evidence path: $EVIDENCE_PATH"
        echo ""
        echo "   Remediation:"
        echo "     1. Create directory: mkdir -p $EVIDENCE_PATH"
        echo "     2. Start with STRATEGIZE: cp docs/templates/strategy_template.md $EVIDENCE_PATH/strategy.md"
        echo ""
        echo "   See MANDATORY_WORK_CHECKLIST.md for full work process."
        exit 1
      fi
    else
      # Validate required phases
      MISSING_PHASES=()

      # Required phases before IMPLEMENT
      if [ ! -f "$EVIDENCE_PATH/strategy.md" ]; then
        MISSING_PHASES+=("STRATEGIZE:strategy.md")
      fi

      if [ ! -f "$EVIDENCE_PATH/spec.md" ]; then
        MISSING_PHASES+=("SPEC:spec.md")
      fi

      if [ ! -f "$EVIDENCE_PATH/plan.md" ]; then
        MISSING_PHASES+=("PLAN:plan.md")
      fi

      if [ ! -f "$EVIDENCE_PATH/think.md" ]; then
        MISSING_PHASES+=("THINK:think.md")
      fi

      # Check GATE requirement
      GATE_REQUIRED=0
      GATE_REASON=""

      if [ $IMPL_FILES -gt 1 ]; then
        GATE_REQUIRED=1
        GATE_REASON="$IMPL_FILES implementation files changed"
      fi

      # Check LOC (reuse existing smart LOC)
      if [ $GATE_REQUIRED -eq 0 ]; then
        NET_LOC=$(node scripts/analyze_loc.mjs --staged --get-net-loc 2>/dev/null || echo "999")
        if [ "$NET_LOC" = "999" ]; then
          GATE_REQUIRED=1
          GATE_REASON="LOC analysis unavailable (safe default)"
        elif [ "$NET_LOC" -gt 20 ]; then
          GATE_REQUIRED=1
          GATE_REASON="$NET_LOC net LOC"
        fi
      fi

      if [ $GATE_REQUIRED -eq 1 ] && [ ! -f "$EVIDENCE_PATH/design.md" ]; then
        MISSING_PHASES+=("GATE:design.md ($GATE_REASON)")
      fi

      # If phases missing, block commit
      if [ ${#MISSING_PHASES[@]} -gt 0 ]; then
        echo ""
        echo -e "${RED}‚ùå BLOCKED: Missing required work process phases${NC}"
        echo ""
        echo "Task: $TASK_ID"
        echo "Evidence path: $EVIDENCE_PATH"
        echo ""
        echo "Phase progress:"

        # Show progress
        [ -f "$EVIDENCE_PATH/strategy.md" ] && echo "  ‚úÖ STRATEGIZE: strategy.md" || echo "  ‚ùå STRATEGIZE: strategy.md not found"
        [ -f "$EVIDENCE_PATH/spec.md" ] && echo "  ‚úÖ SPEC: spec.md" || echo "  ‚ùå SPEC: spec.md not found"
        [ -f "$EVIDENCE_PATH/plan.md" ] && echo "  ‚úÖ PLAN: plan.md" || echo "  ‚ùå PLAN: plan.md not found"
        [ -f "$EVIDENCE_PATH/think.md" ] && echo "  ‚úÖ THINK: think.md" || echo "  ‚ùå THINK: think.md not found"

        if [ $GATE_REQUIRED -eq 1 ]; then
          [ -f "$EVIDENCE_PATH/design.md" ] && echo "  ‚úÖ GATE: design.md" || echo "  ‚ùå GATE: design.md not found (required: $GATE_REASON)"
        else
          echo "  ‚è≠  GATE: design.md (not required: single file, ‚â§20 LOC)"
        fi

        echo ""
        echo "Remediation:"

        for phase_info in "${MISSING_PHASES[@]}"; do
          PHASE_NAME="${phase_info%%:*}"
          PHASE_FILE="${phase_info#*:}"
          PHASE_FILE="${PHASE_FILE%% (*}"  # Remove reason if present

          case "$PHASE_NAME" in
            STRATEGIZE)
              echo "  1. Create strategy.md:"
              echo "     cp docs/templates/strategy_template.md $EVIDENCE_PATH/strategy.md"
              ;;
            SPEC)
              echo "  2. Create spec.md:"
              echo "     cp docs/templates/spec_template.md $EVIDENCE_PATH/spec.md"
              ;;
            PLAN)
              echo "  3. Create plan.md:"
              echo "     cp docs/templates/plan_template.md $EVIDENCE_PATH/plan.md"
              ;;
            THINK)
              echo "  4. Create think.md:"
              echo "     cp docs/templates/think_template.md $EVIDENCE_PATH/think.md"
              ;;
            GATE)
              echo "  5. Create design.md (GATE):"
              echo "     cp docs/templates/design_template.md $EVIDENCE_PATH/design.md"
              ;;
          esac
        done

        echo ""
        echo "See MANDATORY_WORK_CHECKLIST.md for full work process."
        echo ""
        echo "To bypass (EMERGENCY ONLY):"
        echo "  git commit --no-verify"

        exit 1
      fi

      echo "‚úÖ All required phases complete for $TASK_ID"
    fi
  else
    echo "‚úÖ No implementation files, skipping phase validation"
  fi
fi

# ============================================================
# PART 3: Credential Leak Detection
# ============================================================

echo -e "${YELLOW}üîê Running credential leak detection...${NC}"

ERRORS=0

# Patterns to block (with exemptions for documentation/examples)
declare -a PATTERNS=(
    "sk-[A-Za-z0-9]{20,}"  # OpenAI key format (actual keys, not variables)
    "BEGIN RSA PRIVATE KEY"
    "BEGIN PRIVATE KEY"
    "BEGIN OPENSSH PRIVATE KEY"
    "-----END.*PRIVATE"
)

# File patterns to skip (documentation, examples, hooks)
SKIP_PATTERNS=(
    ".md$"
    ".example$"
    ".template$"
    ".githooks"
    "docs/"
    "credentials_manager"
)

# Get staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

for file in $STAGED_FILES; do
    # Skip files that are documentation or examples
    SKIP=0
    for skip_pattern in "${SKIP_PATTERNS[@]}"; do
        if [[ "$file" =~ $skip_pattern ]]; then
            SKIP=1
            break
        fi
    done

    if [ $SKIP -eq 1 ]; then
        continue
    fi

    # Check against patterns (only in source code, not docs)
    for pattern in "${PATTERNS[@]}"; do
        if git diff --cached "$file" | grep -E "$pattern" > /dev/null 2>&1; then
            echo -e "${RED}‚ùå BLOCKED: Potential credential in $file${NC}"
            echo "   Pattern: $pattern"
            ERRORS=$((ERRORS + 1))
        fi
    done

    # Block specific file extensions (these are credential stores)
    if [[ "$file" =~ auth\.json$ ]] || [[ "$file" =~ credentials\.json$ ]] || [[ "$file" =~ \.pem$ ]] || [[ "$file" =~ \.key$ ]] || [[ "$file" =~ \.p12$ ]] || [[ "$file" =~ \.pfx$ ]]; then
        echo -e "${RED}‚ùå BLOCKED: Credential file type in $file${NC}"
        ERRORS=$((ERRORS + 1))
    fi
done

if [ $ERRORS -gt 0 ]; then
    echo ""
    echo -e "${RED}‚ùå Commit blocked: Found $ERRORS potential credential leaks${NC}"
    echo ""
    echo "Guidelines:"
    echo "  1. Move credentials to .env (added to .gitignore)"
    echo "  2. Use environment variables instead"
    echo "  3. Use CredentialsManager for runtime loading"
    echo ""
    echo "To override (NOT RECOMMENDED):"
    echo "  git commit --no-verify"
    exit 1
fi

echo -e "${GREEN}‚úÖ No credential leaks detected${NC}"

# ============================================================
# PART 4: Git Policy Enforcement
# Part of: AFP-S2-GIT-HYGIENE-AUTOPUSH
# ============================================================

echo ""
echo -e "${YELLOW}üîê Validating git policies...${NC}"

# 1. Branch name validation
BRANCH=$(git branch --show-current 2>/dev/null)

if [[ -n "$BRANCH" ]]; then
  # Allow: AFP-*, TASK-*, feature/*, fix/*, main, master
  if [[ ! "$BRANCH" =~ ^(AFP-|TASK-|feature/|fix/|main|master) ]]; then
    echo ""
    echo -e "${RED}‚ùå BLOCKED: Invalid branch name${NC}"
    echo "   Branch: $BRANCH"
    echo ""
    echo "   Allowed patterns:"
    echo "     ‚Ä¢ AFP-*       (task branches)"
    echo "     ‚Ä¢ TASK-*      (task branches)"
    echo "     ‚Ä¢ feature/*   (feature branches)"
    echo "     ‚Ä¢ fix/*       (fix branches)"
    echo "     ‚Ä¢ main, master (main branches)"
    echo ""
    echo "   Create new branch:"
    echo "     git checkout -b AFP-TASK-NAME"
    echo ""
    exit 1
  fi

  # Block direct commits to main (unless merge commit)
  if [[ "$BRANCH" == "main" || "$BRANCH" == "master" ]]; then
    COMMIT_MSG=$(cat .git/COMMIT_EDITMSG 2>/dev/null || echo "")

    # Allow merge commits (they start with "Merge")
    # Allow commits from auto-push system
    if [[ ! "$COMMIT_MSG" =~ ^Merge ]] && [[ ! "$COMMIT_MSG" =~ "Auto-push" ]]; then
      echo ""
      echo -e "${RED}‚ùå BLOCKED: Direct commits to $BRANCH not allowed${NC}"
      echo "   Use feature branch workflow:"
      echo "     1. git checkout -b feature/my-feature"
      echo "     2. Make changes and commit"
      echo "     3. git push origin feature/my-feature"
      echo "     4. Create PR on GitHub"
      echo ""
      echo "   To override (EMERGENCY ONLY):"
      echo "     git commit --no-verify"
      echo ""
      exit 1
    fi
  fi
fi

echo -e "${GREEN}‚úÖ Git policies validated${NC}"

echo ""
echo -e "${GREEN}üéâ All pre-commit checks passed!${NC}"
exit 0
