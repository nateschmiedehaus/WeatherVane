#!/bin/bash
# Combined Pre-Commit Hook:
# 1. AFP/SCAS guardrails (micro-batching, complexity control)
# 2. Credential leak detection

set -e

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

echo -e "${YELLOW}üîç AFP/SCAS Pre-Commit Checks...${NC}"

# ============================================================
# PART 1: AFP/SCAS Guardrails
# ============================================================

# Count files changed
FILES_CHANGED=$(git diff --cached --name-only | wc -l | tr -d ' ')

if [ $FILES_CHANGED -gt 5 ]; then
  echo -e "${RED}‚ùå BLOCKED: $FILES_CHANGED files changed (max: 5)${NC}"
  echo "   AFP micro-batching violation."
  echo "   Split this into smaller commits."
  echo ""
  echo "   See MANDATORY_WORK_CHECKLIST.md for full guidelines."
  exit 1
fi

# Count net LOC added
LOC_ADDED=$(git diff --cached --numstat | awk '{sum+=$1} END {print sum+0}')
LOC_DELETED=$(git diff --cached --numstat | awk '{sum+=$2} END {print sum+0}')
NET_LOC=$((LOC_ADDED - LOC_DELETED))

if [ $NET_LOC -gt 150 ]; then
  echo -e "${RED}‚ùå BLOCKED: +$NET_LOC net LOC (max: +150)${NC}"
  echo "   AFP micro-batching violation."
  echo "   Prefer deletion/refactoring over addition."
  echo ""
  echo "   See MANDATORY_WORK_CHECKLIST.md for full guidelines."
  exit 1
fi

# Check for common anti-patterns
DIFF=$(git diff --cached)

# Anti-pattern 1: Adding long functions (>50 lines)
ADDED_LINES=$(echo "$DIFF" | grep "^+" | wc -l | tr -d ' ')
if [ $ADDED_LINES -gt 50 ]; then
  # Check for function definitions
  FUNC_COUNT=$(echo "$DIFF" | grep -E "^\+.*function|^\+.*=>|^\+.*async " | wc -l | tr -d ' ')
  if [ $FUNC_COUNT -gt 0 ]; then
    AVG_LINES_PER_FUNC=$((ADDED_LINES / FUNC_COUNT))
    if [ $AVG_LINES_PER_FUNC -gt 50 ]; then
      echo -e "${YELLOW}‚ö†Ô∏è  WARNING: Adding function(s) >50 lines avg.${NC}"
      echo "   Consider extracting sub-functions (AFP modularity principle)."
    fi
  fi
fi

# Anti-pattern 2: Deep nesting (>3 levels)
DEEP_NESTING=$(echo "$DIFF" | grep "^+" | grep -E "      \{|      if|      for|      while" | wc -l | tr -d ' ')
if [ $DEEP_NESTING -gt 3 ]; then
  echo -e "${YELLOW}‚ö†Ô∏è  WARNING: Deep nesting detected (>3 levels).${NC}"
  echo "   Simplify control flow (AFP complexity principle)."
fi

# Anti-pattern 3: No deletions when adding code
if [ $LOC_ADDED -gt 50 ] && [ $LOC_DELETED -eq 0 ]; then
  echo -e "${YELLOW}‚ö†Ô∏è  WARNING: Adding $LOC_ADDED LOC without deleting anything.${NC}"
  echo "   Consider via negativa: can you simplify existing code instead?"
fi

echo -e "${GREEN}‚úÖ AFP/SCAS checks passed${NC}"
echo "   Files: $FILES_CHANGED/5, Net LOC: +$NET_LOC/+150"

# ============================================================
# PART 1b: Design Evidence Enforcement (AFP/SCAS GATE)
# ============================================================

# For non-trivial changes (>1 file or >20 LOC), require design evidence
# Lower threshold = more thinking, but DesignReviewer provides guidance
if [ $FILES_CHANGED -gt 1 ] || [ $NET_LOC -gt 20 ]; then
  # Check if there are source code changes (not just docs/config)
  CODE_CHANGES=$(git diff --cached --name-only | grep -E '\.(ts|js|py|go|rs|java|cpp|c|h)$' | wc -l | tr -d ' ')

  if [ $CODE_CHANGES -gt 0 ]; then
    # Look for design evidence in staged changes (design.md preferred, phases.md accepted during migration)
    DESIGN_EVIDENCE=$(git diff --cached --name-only | grep -E 'state/evidence/.*/(design|phases)\.md' | wc -l | tr -d ' ')

    if [ $DESIGN_EVIDENCE -eq 0 ]; then
      echo -e "${RED}‚ùå GATE VIOLATION: No design documentation found${NC}"
      echo "   Changed: $FILES_CHANGED files, +$NET_LOC LOC, $CODE_CHANGES code files"
      echo ""
      echo -e "${RED}   STOP: You must document design thinking BEFORE implementing${NC}"
      echo ""
      echo "   AFP/SCAS requires thinking through:"
      echo "   ‚Ä¢ VIA NEGATIVA: Can you DELETE/SIMPLIFY instead of add?"
      echo "   ‚Ä¢ REFACTOR NOT REPAIR: Are you patching or refactoring properly?"
      echo "   ‚Ä¢ ALTERNATIVES: What other approaches did you consider?"
      echo "   ‚Ä¢ COMPLEXITY: Are increases justified?"
      echo ""
      echo -e "${YELLOW}   Create design documentation:${NC}"
      echo "   1. Copy template: cp docs/templates/design_template.md state/evidence/[TASK-ID]/design.md"
      echo "   2. Fill in your thinking (be honest about trade-offs)"
      echo "   3. Stage it: git add state/evidence/[TASK-ID]/design.md"
      echo ""
      echo "   DesignReviewer will provide INTELLIGENT FEEDBACK on your design."
      echo "   Goal: Stop compliance theater, ensure real thinking."
      echo ""
      echo "   See docs/templates/design_template.md for template."
      exit 1
    fi

    echo -e "${GREEN}‚úÖ Design evidence found${NC}"

    # If design.md is staged, run DesignReviewer to enforce quality
    DESIGN_MD_STAGED=$(git diff --cached --name-only | grep -E 'state/evidence/.*/design\.md$')

    if [ -n "$DESIGN_MD_STAGED" ]; then
      echo ""
      echo -e "${YELLOW}üîç Running DesignReviewer on staged design.md...${NC}"
      echo ""

      # Extract task ID from design.md path
      TASK_ID=$(echo "$DESIGN_MD_STAGED" | sed -E 's|state/evidence/([^/]+)/design\.md|\1|')

      # Run design review script
      cd tools/wvo_mcp
      if npm run gate:review "$TASK_ID"; then
        echo ""
        echo -e "${GREEN}‚úÖ DesignReviewer APPROVED${NC}"
        cd ../..
      else
        EXIT_CODE=$?
        cd ../..

        if [ $EXIT_CODE -eq 1 ]; then
          echo ""
          echo -e "${RED}‚ùå GATE BLOCKED: Design needs revision${NC}"
          echo ""
          echo "   DesignReviewer found concerns with your design.md"
          echo "   You MUST address these before committing."
          echo ""
          echo "   This is the ITERATIVE GATE process:"
          echo "   1. Read the concerns above carefully"
          echo "   2. Create a remediation task (new STRATEGIZE cycle)"
          echo "   3. Do actual research (30-60 min per critical issue)"
          echo "   4. Update UPSTREAM artifacts (strategy/spec/plan docs)"
          echo "   5. Update design.md with revised approach"
          echo "   6. Test: npm run gate:review $TASK_ID"
          echo "   7. Re-commit when approved"
          echo ""
          echo "   Expected: 2-3 review rounds is NORMAL and GOOD."
          echo "   Goal: Ensure real AFP/SCAS thinking, not compliance theater."
          exit 1
        else
          echo ""
          echo -e "${RED}‚ùå GATE ERROR: DesignReviewer failed${NC}"
          echo "   Check the error above."
          exit 1
        fi
      fi
    fi
  fi
fi

# ============================================================
# PART 2: Credential Leak Detection
# ============================================================

echo -e "${YELLOW}üîê Running credential leak detection...${NC}"

ERRORS=0

# Patterns to block (with exemptions for documentation/examples)
declare -a PATTERNS=(
    "sk-[A-Za-z0-9]{20,}"  # OpenAI key format (actual keys, not variables)
    "BEGIN RSA PRIVATE KEY"
    "BEGIN PRIVATE KEY"
    "BEGIN OPENSSH PRIVATE KEY"
    "-----END.*PRIVATE"
)

# File patterns to skip (documentation, examples, hooks)
SKIP_PATTERNS=(
    ".md$"
    ".example$"
    ".template$"
    ".githooks"
    "docs/"
    "credentials_manager"
)

# Get staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

for file in $STAGED_FILES; do
    # Skip files that are documentation or examples
    SKIP=0
    for skip_pattern in "${SKIP_PATTERNS[@]}"; do
        if [[ "$file" =~ $skip_pattern ]]; then
            SKIP=1
            break
        fi
    done

    if [ $SKIP -eq 1 ]; then
        continue
    fi

    # Check against patterns (only in source code, not docs)
    for pattern in "${PATTERNS[@]}"; do
        if git diff --cached "$file" | grep -E "$pattern" > /dev/null 2>&1; then
            echo -e "${RED}‚ùå BLOCKED: Potential credential in $file${NC}"
            echo "   Pattern: $pattern"
            ERRORS=$((ERRORS + 1))
        fi
    done

    # Block specific file extensions (these are credential stores)
    if [[ "$file" =~ auth\.json$ ]] || [[ "$file" =~ credentials\.json$ ]] || [[ "$file" =~ \.pem$ ]] || [[ "$file" =~ \.key$ ]] || [[ "$file" =~ \.p12$ ]] || [[ "$file" =~ \.pfx$ ]]; then
        echo -e "${RED}‚ùå BLOCKED: Credential file type in $file${NC}"
        ERRORS=$((ERRORS + 1))
    fi
done

if [ $ERRORS -gt 0 ]; then
    echo ""
    echo -e "${RED}‚ùå Commit blocked: Found $ERRORS potential credential leaks${NC}"
    echo ""
    echo "Guidelines:"
    echo "  1. Move credentials to .env (added to .gitignore)"
    echo "  2. Use environment variables instead"
    echo "  3. Use CredentialsManager for runtime loading"
    echo ""
    echo "To override (NOT RECOMMENDED):"
    echo "  git commit --no-verify"
    exit 1
fi

echo -e "${GREEN}‚úÖ No credential leaks detected${NC}"
echo ""
echo -e "${GREEN}üéâ All pre-commit checks passed!${NC}"
exit 0
