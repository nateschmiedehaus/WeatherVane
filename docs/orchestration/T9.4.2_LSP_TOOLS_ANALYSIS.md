# T9.4.2 LSP Proxy Tools - Complete Registration Analysis

## Executive Summary

**Task:** T9.4.2 - "LSP proxy tools for symbol-aware context (SAFE: new tools)"

**Current Status:** LSP proxy infrastructure is BUILT but NOT REGISTERED in the MCP server (index-claude.ts)

**Finding:** Tools exist in the worker layer (tool_router.ts) but are missing from the main Claude Code MCP entry point, preventing clients from discovering and using them.

---

## 1. What Exists Today

### 1.1 LSP Infrastructure (Complete)

**Files:** `tools/wvo_mcp/src/lsp/`

1. **lsp_manager.ts** (390 lines)
   - Lifecycle management for TypeScript (tsserver) and Python (pyright) language servers
   - Handles spawning, initialization, and communication via JSON-RPC
   - Public API:
     - `startTypeScriptServer()` / `startPythonServer()`
     - `findDefinition(language, filePath, line, character)`
     - `findReferences(language, filePath, line, character)`
     - `getHoverInfo(language, filePath, line, character)`
     - `getServerStatus(language)`
     - `stopServer(language)` / `stopAll()`
     - `getPendingRequests()` for debugging

2. **tsserver_proxy.ts** (270 lines)
   - Wraps tsserver communication
   - Methods:
     - `getDefinition()` - basic definition lookup
     - `getReferences()` - find all references
     - `getHover()` - type information
     - `getDefinitionWithContext(contextLines=5)` - includes code slices
     - `getReferencesWithContext(contextLines=3)` - includes code context
     - `findSymbolFallback()` - pattern-based lookup if LSP unavailable
     - `extractCodeSlice()` - private helper

3. **pyright_proxy.ts** (335 lines)
   - Wraps pyright (Python LSP)
   - Same public API as TypeScript
   - Python-specific fallback patterns (def, class, async def, assignment)
   - Additional methods for Python:
     - `extractImports()` - collect import statements
     - `getSignature()` - extract function/class signatures

4. **types.ts** (189 lines)
   - Complete TypeScript definitions for LSP protocol
   - Key types: Position, Range, Location, SymbolInformation, SymbolKind enum
   - Request/Response types for JSON-RPC
   - SymbolDefinition, SymbolReferences for context-aware results

5. **index.ts** (11 lines)
   - Module exports for LSP API

### 1.2 Worker Layer Tools (Complete)

**File:** `tools/wvo_mcp/src/worker/tool_router.ts` (lines 610-809)

**5 LSP tools already implemented:**

```typescript
private async handleLspDefinition(input: unknown)     // lines 610-654
private async handleLspReferences(input: unknown)     // lines 656-700
private async handleLspHover(input: unknown)          // lines 702-744
private async handleLspServerStatus(input: unknown)   // lines 746-773
private async handleLspInitialize(input: unknown)     // lines 775-809
```

**Tool case handlers in router.runTool():**
```typescript
case "lsp_definition":     // line 182
case "lsp_references":     // line 184
case "lsp_hover":          // line 186
case "lsp_server_status":  // line 188
case "lsp_initialize":     // line 190
```

### 1.3 Input Schema Definitions (Complete)

**File:** `tools/wvo_mcp/src/tools/input_schemas.ts`

```typescript
export const lspDefinitionInput = z.object({
  language: z.enum(["typescript", "python"]),
  filePath: z.string().min(1),
  line: z.number().int().nonnegative(),
  character: z.number().int().nonnegative(),
  contextLines: z.number().int().nonnegative().optional(),
});

export const lspReferencesInput = z.object({
  language: z.enum(["typescript", "python"]),
  filePath: z.string().min(1),
  line: z.number().int().nonnegative(),
  character: z.number().int().nonnegative(),
  contextLines: z.number().int().nonnegative().optional(),
});

export const lspHoverInput = z.object({
  language: z.enum(["typescript", "python"]),
  filePath: z.string().min(1),
  line: z.number().int().nonnegative(),
  character: z.number().int().nonnegative(),
});

export const lspServerStatusInput = z.object({
  language: z.enum(["typescript", "python"]).optional(),
});

export const lspInitializeInput = z.object({
  workspaceRoot: z.string().min(1),
});
```

Also includes TypeScript type exports:
```typescript
export type LspDefinitionInput = z.infer<typeof lspDefinitionInput>;
export type LspReferencesInput = z.infer<typeof lspReferencesInput>;
export type LspHoverInput = z.infer<typeof lspHoverInput>;
export type LspServerStatusInput = z.infer<typeof lspServerStatusInput>;
export type LspInitializeInput = z.infer<typeof lspInitializeInput>;
```

---

## 2. What's MISSING: MCP Server Registration

### 2.1 The Gap

**File:** `tools/wvo_mcp/src/index-claude.ts` (1,288 lines)

This is the main MCP server entry point that:
- Creates `McpServer` instance (line 125)
- Registers tools with `server.registerTool()` (30+ tools)
- Connects to Claude Code via StdioServerTransport (line 1272)

**Current Tools Registered (30+):**
- wvo_status
- state_save, state_metrics, state_prune
- quality_standards, quality_checklist, quality_philosophy
- provider_status, auth_status
- roadmap_check_and_extend, plan_next, plan_update
- context_write, context_snapshot
- fs_read, fs_write
- cmd_run
- critics_run
- autopilot_record_audit, autopilot_status
- heavy_queue_enqueue, heavy_queue_update, heavy_queue_list
- artifact_record
- cli_commands
- screenshot_capture, screenshot_capture_multiple, screenshot_session

**LSP Tools Registered:** **NONE** (this is the bug!)

### 2.2 Why This Matters

1. **Tool Discovery:** Claude Code and clients call `tools/list` endpoint to discover available tools
2. **Current State:** LSP tools don't appear in that list because they're not in index-claude.ts
3. **Result:** Users can't see or call lsp_definition, lsp_references, lsp_hover, etc. from Claude Code
4. **Workaround:** The tools DO work through the worker layer (orchestrator), but only if called internally

---

## 3. How Tool Registration Works

### 3.1 MCP Server Pattern (line 125-133)

```typescript
const server = new McpServer(
  {
    name: SERVER_NAME,
    version: SERVER_VERSION,
  },
  {
    capabilities: {},
  },
);
```

### 3.2 Tool Registration Pattern (example from line 160)

```typescript
server.registerTool(
  "tool_name",
  {
    description: `Tool description...`,
    inputSchema: inputSchemaObject,  // zod schema converted to JSON Schema
  },
  async (input: unknown) => {
    // Handler implementation
    return formatData(...) or formatSuccess(...) or formatError(...);
  },
);
```

### 3.3 Schema Conversion

All schemas converted via `toJsonSchema()` (line 20):
```typescript
import { toJsonSchema } from "./utils/schema.js";

const planNextInput = z.object({...});
const planNextSchema = toJsonSchema(planNextInput, "PlanNextInput");
```

---

## 4. What Needs to Be Done for T9.4.2

### 4.1 Add LSP Tool Registrations to index-claude.ts

After line 1270 (before transport setup at line 1272), add:

```typescript
// LSP Code Intelligence Tools
const lspDefinitionInput = z.object({
  language: z.enum(["typescript", "python"]),
  filePath: z.string().min(1),
  line: z.number().int().nonnegative(),
  character: z.number().int().nonnegative(),
  contextLines: z.number().int().nonnegative().optional(),
});
const lspDefinitionSchema = toJsonSchema(lspDefinitionInput, "LspDefinitionInput");

server.registerTool(
  "lsp_definition",
  {
    description: `ðŸ” Find symbol definition using LSP (Language Server Protocol).

Locates where a symbol (function, class, variable) is defined in your codebase.
Returns the definition with surrounding context lines for understanding.

Parameters:
- language (required): "typescript" or "python"
- filePath (required): Path to file with symbol reference
- line (required): Line number (0-indexed)
- character (required): Column number (0-indexed)
- contextLines (optional): Lines of context around definition (default: 5)

Example:
{
  "language": "typescript",
  "filePath": "src/utils.ts",
  "line": 10,
  "character": 5,
  "contextLines": 5
}

Returns: Array of SymbolDefinition objects with code context.

Use when: Understanding where functions/classes are defined`,
    inputSchema: lspDefinitionSchema,
  },
  async (input: unknown) => {
    try {
      const parsed = lspDefinitionInput.parse(input);
      const { getLSPManager } = await import("./lsp/lsp_manager.js");
      const lspManager = getLSPManager(session.workspaceRoot);

      // Ensure language server is running
      const status = lspManager.getServerStatus(parsed.language);
      if (!status.running) {
        if (parsed.language === "typescript") {
          await lspManager.startTypeScriptServer();
        } else {
          await lspManager.startPythonServer();
        }
      }

      // Get definitions
      if (parsed.language === "typescript") {
        const { TypeScriptLSPProxy } = await import("./lsp/tsserver_proxy.js");
        const proxy = new TypeScriptLSPProxy(lspManager, session.workspaceRoot);
        const result = await proxy.getDefinitionWithContext(
          parsed.filePath,
          parsed.line,
          parsed.character,
          parsed.contextLines ?? 5
        );
        return formatData(
          { definitions: result, count: result.length },
          `ðŸ” Found ${result.length} definition(s)`
        );
      } else {
        const { PythonLSPProxy } = await import("./lsp/pyright_proxy.js");
        const proxy = new PythonLSPProxy(lspManager, session.workspaceRoot);
        const result = await proxy.getDefinitionWithContext(
          parsed.filePath,
          parsed.line,
          parsed.character,
          parsed.contextLines ?? 5
        );
        return formatData(
          { definitions: result, count: result.length },
          `ðŸ” Found ${result.length} definition(s)`
        );
      }
    } catch (error) {
      return formatError(
        "Failed to find definition",
        error instanceof Error ? error.message : String(error)
      );
    }
  },
);

// Similar registration for lsp_references, lsp_hover, lsp_server_status, lsp_initialize
```

### 4.2 Import Required Modules at Top

Add to imports (around line 20):
```typescript
import { z } from "zod";
```

Import from lsp module (optional, can be done dynamically):
```typescript
// Lazy imports happen in handlers, but could be eager:
import { getLSPManager } from "./lsp/lsp_manager.js";
import { TypeScriptLSPProxy } from "./lsp/tsserver_proxy.js";
import { PythonLSPProxy } from "./lsp/pyright_proxy.js";
```

### 4.3 Complete List of Registrations Needed

1. **lsp_initialize** - Start/initialize LSP servers
2. **lsp_server_status** - Check if servers are running and initialized
3. **lsp_definition** - Find where a symbol is defined (with context)
4. **lsp_references** - Find all uses of a symbol (with context)
5. **lsp_hover** - Get type/documentation info for a symbol

---

## 5. Architecture Overview: Why it's Organized This Way

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Claude Code (Client)                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚ MCP Protocol (stdio)
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ index-claude.ts (MCP Server Entry Point)                    â”‚
â”‚ - Registers tools for discovery                             â”‚
â”‚ - Handlers call session methods or do inline work           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â–¼                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SessionContext   â”‚  â”‚ OrchestratorRuntime     â”‚
â”‚ (index-claude.ts â”‚  â”‚ (worker layer)          â”‚
â”‚  handlers)       â”‚  â”‚                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ tool_router.ts       â”‚
                    â”‚ (worker handlers)    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â–¼                      â–¼                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LSPManager   â”‚  â”‚ TypeScriptProxy  â”‚  â”‚ PythonProxy     â”‚
â”‚ (lifecycle)  â”‚  â”‚ (tsserver)       â”‚  â”‚ (pyright)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                    â”‚                     â”‚
      â–¼                    â–¼                     â–¼
   tsserver           JSON-RPC Protocol      pyright
   (spawned)         (stdin/stdout)         (spawned)
```

**Key Points:**
1. **index-claude.ts** = Client-facing MCP server (needs LSP tool registrations)
2. **tool_router.ts** = Internal worker layer (LSP tools already implemented here)
3. **LSP modules** = Pure language server communication (complete)

---

## 6. Exit Criteria for T9.4.2

From roadmap.yaml:
- [x] tsserver and pyright proxies running (DONE - lsp_manager.ts handles this)
- [ ] lsp.definition and lsp.references tools work (BLOCKED - missing from MCP server)
- [ ] Context assembler uses LSP for code slices (BLOCKED - needs definition tool)
- [ ] Context relevance measured and improved (BLOCKED - depends on LSP integration)
- [ ] critic:tests passes (BLOCKED - needs implementation)
- [ ] Guardrail: LSP tools routed through worker proxy with Step 0-15 safety (PENDING - check enforcement)

---

## 7. Files Modified Timeline

1. **Created:** lsp/ folder with manager + proxies + types
2. **Updated:** tool_router.ts with 5 LSP handlers + input schema imports
3. **Updated:** input_schemas.ts with 5 LSP input definitions
4. **Missing:** index-claude.ts tool registrations (THIS IS THE WORK)

---

## 8. Code Quality Observations

### Strengths
- **LSP manager**: Clean lifecycle management, proper error handling
- **Proxies**: Encapsulate language-specific logic well
- **Fallback support**: Pattern matching if LSP unavailable
- **Type safety**: Full Zod validation on all inputs
- **Graceful degradation**: Servers can fail independently

### Risks for T9.4.2
- **Server startup cost**: Starting TypeScript and Python servers adds latency
- **Memory usage**: Two child processes per session (mitigated by singleton LSP manager)
- **File system assumptions**: Assumes workspace paths are absolute (checked in proxies)
- **LSP protocol version**: Assumes LSP 3.x compatible servers (tsserver/pyright)

---

## 9. Next Steps to Complete T9.4.2

1. **Add 5 tool registrations to index-claude.ts** (~150 lines)
   - lsp_initialize
   - lsp_server_status
   - lsp_definition
   - lsp_references
   - lsp_hover

2. **Update wvo_status tool** to include LSP tools in list

3. **Run tests:**
   ```bash
   npm test -- tools/wvo_mcp/src/lsp/
   npm test -- tools/wvo_mcp/src/tests/*lsp*
   ```

4. **Manual testing:**
   ```bash
   # Start MCP server
   node tools/wvo_mcp/src/index-claude.ts &
   
   # In Claude Code, call:
   # tools -> lsp_initialize
   # tools -> lsp_definition (with valid file path)
   ```

5. **Context assembler integration** (separate task)
   - Have context_assembler use lsp_definition for code context
   - Measure relevance improvement

6. **Safety guardrail verification**
   - Confirm Step 0-15 enforcement applies to LSP tools
   - Add LSP tools to worker proxy allowlist if needed

---

## 10. Comparison: Worker Layer vs Index-Claude

**Why tools exist in both places:**

| Layer | Purpose | When Used |
|-------|---------|-----------|
| **tool_router.ts** | Internal execution engine for orchestrator | Autopilot, internal workflows |
| **index-claude.ts** | External API for Claude Code clients | Direct user calls from Claude Code |

**Current LSP tool path:**
```
Claude Code â†’ (NO DIRECT PATH - tools not registered)
             â†’ Orchestrator â†’ tool_router â†’ LSP handlers â†’ OK
```

**After T9.4.2:**
```
Claude Code â†’ index-claude.ts â†’ LSP handlers â†’ LSPManager/Proxies â†’ OK
             â†“
             Orchestrator â†’ tool_router â†’ LSP handlers â†’ LSPManager/Proxies â†’ OK (same instance)
```

---

## Summary

The LSP proxy infrastructure is **95% complete**:
- âœ“ LSPManager for lifecycle
- âœ“ TypeScript and Python proxies
- âœ“ Input schemas
- âœ“ Worker layer handlers

Only missing piece: **Register 5 tools in index-claude.ts MCP server.**

This is a straightforward registration task (~150 lines) that will enable:
- Claude Code users to call LSP tools directly
- Symbol-aware context for code understanding
- Foundation for context assembler improvements

