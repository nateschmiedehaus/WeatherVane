/**
 * Roadmap Auto-Extension - Automatically adds new tasks when roadmap nears completion
 * Prioritizes shipping code over excessive review
 */

import { logInfo } from "../telemetry/logger.js";
import type { PlanNextInput } from "../utils/types.js";

export interface RoadmapMetrics {
  totalTasks: number;
  pendingTasks: number;
  inProgressTasks: number;
  completedTasks: number;
  blockedTasks: number;
  completionPercentage: number;
  nearingCompletion: boolean;
}

export interface AutoGeneratedTask {
  id: string;
  title: string;
  description: string;
  priority: "high" | "medium" | "low";
  category: "feature" | "optimization" | "bug_fix" | "shipping" | "infrastructure";
  estimatedHours: number;
  dependencies: string[];
  rationale: string;
}

export class RoadmapAutoExtender {
  // Threshold for "nearing completion" - when to start generating new tasks
  private readonly COMPLETION_THRESHOLD = 0.75; // 75% complete
  // Minimum buffer of pending tasks to maintain
  private readonly MIN_PENDING_BUFFER = 3;

  /**
   * Analyze roadmap metrics
   */
  analyzeRoadmap(tasks: any[]): RoadmapMetrics {
    const totalTasks = tasks.length;
    const pendingTasks = tasks.filter((t) => t.status === "pending").length;
    const inProgressTasks = tasks.filter((t) => t.status === "in_progress").length;
    const completedTasks = tasks.filter((t) => t.status === "done").length;
    const blockedTasks = tasks.filter((t) => t.status === "blocked").length;

    const completionPercentage = totalTasks > 0 ? completedTasks / totalTasks : 0;

    // Consider nearing completion if:
    // 1. Completion % > threshold, OR
    // 2. Fewer than MIN_PENDING_BUFFER pending tasks
    const nearingCompletion =
      completionPercentage > this.COMPLETION_THRESHOLD ||
      pendingTasks < this.MIN_PENDING_BUFFER;

    return {
      totalTasks,
      pendingTasks,
      inProgressTasks,
      completedTasks,
      blockedTasks,
      completionPercentage,
      nearingCompletion,
    };
  }

  /**
   * Generate new tasks based on project state and priorities
   * Prioritizes shipping over analysis
   */
  generateNextTasks(metrics: RoadmapMetrics, projectPhase: string): AutoGeneratedTask[] {
    const tasks: AutoGeneratedTask[] = [];
    let taskCounter = Math.floor(Date.now() / 1000); // Simple ID generation

    // Phase-based task generation
    switch (projectPhase) {
      case "foundation":
        tasks.push(...this.generateFoundationTasks(taskCounter));
        break;
      case "development":
        tasks.push(...this.generateDevelopmentTasks(taskCounter));
        break;
      case "shipping":
        tasks.push(...this.generateShippingTasks(taskCounter));
        break;
      case "optimization":
        tasks.push(...this.generateOptimizationTasks(taskCounter));
        break;
      default:
        tasks.push(...this.generateGeneralTasks(taskCounter));
    }

    // Always prioritize shipping tasks
    tasks.push(this.generateShippingAcceleratorTask(taskCounter + 1000));

    logInfo("Generated new roadmap tasks", {
      count: tasks.length,
      phase: projectPhase,
      metrics,
    });

    return tasks;
  }

  /**
   * Foundation phase tasks
   */
  private generateFoundationTasks(baseId: number): AutoGeneratedTask[] {
    return [
      {
        id: `T_AUTO_${baseId}_1`,
        title: "Complete core data pipeline integration",
        description: "Integrate all data sources (Shopify, Ads, Weather) into unified pipeline",
        priority: "high",
        category: "feature",
        estimatedHours: 8,
        dependencies: [],
        rationale: "Foundation for all downstream features",
      },
      {
        id: `T_AUTO_${baseId}_2`,
        title: "Deploy MVP feature matrix",
        description: "Ship minimal viable feature set for modeling - prioritize speed over perfection",
        priority: "high",
        category: "shipping",
        estimatedHours: 6,
        dependencies: [`T_AUTO_${baseId}_1`],
        rationale: "Get to production fast, iterate from real data",
      },
      {
        id: `T_AUTO_${baseId}_3`,
        title: "Implement basic observability",
        description: "Add logging, metrics, and basic monitoring - just enough to debug",
        priority: "medium",
        category: "infrastructure",
        estimatedHours: 4,
        dependencies: [],
        rationale: "Need visibility into production behavior",
      },
    ];
  }

  /**
   * Development phase tasks
   */
  private generateDevelopmentTasks(baseId: number): AutoGeneratedTask[] {
    return [
      {
        id: `T_AUTO_${baseId}_1`,
        title: "Implement next priority feature",
        description: "Build highest-value feature from backlog - ship fast, refine later",
        priority: "high",
        category: "feature",
        estimatedHours: 10,
        dependencies: [],
        rationale: "Continuous feature delivery",
      },
      {
        id: `T_AUTO_${baseId}_2`,
        title: "Quick integration test pass",
        description: "Fast integration test sweep - focus on critical paths only",
        priority: "medium",
        category: "shipping",
        estimatedHours: 3,
        dependencies: [`T_AUTO_${baseId}_1`],
        rationale: "Verify basics work, don't over-test",
      },
      {
        id: `T_AUTO_${baseId}_3`,
        title: "Deploy to staging and validate",
        description: "Ship to staging, run smoke tests, iterate if needed",
        priority: "high",
        category: "shipping",
        estimatedHours: 4,
        dependencies: [`T_AUTO_${baseId}_2`],
        rationale: "Real environment validation beats analysis",
      },
    ];
  }

  /**
   * Shipping phase tasks - maximize deployment velocity
   */
  private generateShippingTasks(baseId: number): AutoGeneratedTask[] {
    return [
      {
        id: `T_AUTO_${baseId}_1`,
        title: "Production deployment preparation",
        description: "Final checks, configs, and deployment scripts - minimal, focused",
        priority: "high",
        category: "shipping",
        estimatedHours: 5,
        dependencies: [],
        rationale: "Get to production ASAP",
      },
      {
        id: `T_AUTO_${baseId}_2`,
        title: "Deploy to production",
        description: "Execute production deployment with monitoring",
        priority: "high",
        category: "shipping",
        estimatedHours: 3,
        dependencies: [`T_AUTO_${baseId}_1`],
        rationale: "Ship it!",
      },
      {
        id: `T_AUTO_${baseId}_3`,
        title: "Post-deployment validation",
        description: "Quick validation of critical paths, iterate if broken",
        priority: "high",
        category: "shipping",
        estimatedHours: 2,
        dependencies: [`T_AUTO_${baseId}_2`],
        rationale: "Verify it works, fix fast if not",
      },
      {
        id: `T_AUTO_${baseId}_4`,
        title: "Start next feature cycle",
        description: "Immediately begin next feature - keep velocity high",
        priority: "high",
        category: "feature",
        estimatedHours: 8,
        dependencies: [`T_AUTO_${baseId}_3`],
        rationale: "Continuous delivery rhythm",
      },
    ];
  }

  /**
   * Optimization phase tasks - only after core functionality shipped
   */
  private generateOptimizationTasks(baseId: number): AutoGeneratedTask[] {
    return [
      {
        id: `T_AUTO_${baseId}_1`,
        title: "Performance optimization sweep",
        description: "Profile and optimize bottlenecks identified in production",
        priority: "medium",
        category: "optimization",
        estimatedHours: 6,
        dependencies: [],
        rationale: "Optimize based on real usage patterns",
      },
      {
        id: `T_AUTO_${baseId}_2`,
        title: "Address technical debt from fast shipping",
        description: "Refactor areas that need cleanup - but only critical ones",
        priority: "low",
        category: "optimization",
        estimatedHours: 8,
        dependencies: [],
        rationale: "Clean up, but don't over-engineer",
      },
    ];
  }

  /**
   * General tasks when phase unclear
   */
  private generateGeneralTasks(baseId: number): AutoGeneratedTask[] {
    return [
      {
        id: `T_AUTO_${baseId}_1`,
        title: "Identify and implement next high-value feature",
        description: "Find and build feature with best value/effort ratio",
        priority: "high",
        category: "feature",
        estimatedHours: 8,
        dependencies: [],
        rationale: "Maintain development momentum",
      },
      {
        id: `T_AUTO_${baseId}_2`,
        title: "Ship latest changes",
        description: "Deploy recent work to production or staging",
        priority: "high",
        category: "shipping",
        estimatedHours: 4,
        dependencies: [`T_AUTO_${baseId}_1`],
        rationale: "Keep shipping cadence high",
      },
    ];
  }

  /**
   * Always-relevant shipping accelerator task
   */
  private generateShippingAcceleratorTask(id: number): AutoGeneratedTask {
    return {
      id: `T_AUTO_${id}`,
      title: "Shipping velocity check",
      description: "Review deployment frequency, identify and remove bottlenecks in shipping process",
      priority: "high",
      category: "shipping",
      estimatedHours: 2,
      dependencies: [],
      rationale: "Shipping speed is paramount - always optimize for deployment velocity",
    };
  }

  /**
   * Determine current project phase based on roadmap state
   */
  determineProjectPhase(tasks: any[]): string {
    const totalTasks = tasks.length;
    const completedTasks = tasks.filter((t) => t.status === "done").length;
    const completionRate = totalTasks > 0 ? completedTasks / totalTasks : 0;

    // Simple heuristic - adjust based on task titles/categories
    const shippingTasks = tasks.filter((t) =>
      t.title?.toLowerCase().includes("deploy") ||
      t.title?.toLowerCase().includes("ship") ||
      t.title?.toLowerCase().includes("production")
    );

    const hasShippingTasks = shippingTasks.length > 0;
    const shippingComplete = shippingTasks.filter((t) => t.status === "done").length;

    if (completionRate < 0.3) return "foundation";
    if (completionRate < 0.7 && !hasShippingTasks) return "development";
    if (hasShippingTasks && shippingComplete === 0) return "shipping";
    if (completionRate > 0.8) return "optimization";

    return "development"; // Default
  }

  /**
   * Check if roadmap needs extension and generate tasks if needed
   */
  async autoExtendIfNeeded(
    currentTasks: any[]
  ): Promise<{ shouldExtend: boolean; generatedTasks: AutoGeneratedTask[]; metrics: RoadmapMetrics }> {
    const metrics = this.analyzeRoadmap(currentTasks);

    if (!metrics.nearingCompletion) {
      return {
        shouldExtend: false,
        generatedTasks: [],
        metrics,
      };
    }

    // Generate new tasks
    const projectPhase = this.determineProjectPhase(currentTasks);
    const generatedTasks = this.generateNextTasks(metrics, projectPhase);

    logInfo("Roadmap auto-extension triggered", {
      metrics,
      projectPhase,
      generatedTaskCount: generatedTasks.length,
    });

    return {
      shouldExtend: true,
      generatedTasks,
      metrics,
    };
  }
}
