import path from 'node:path';
import { promises as fs } from 'node:fs';
import type { StateMachine, Task } from './state_machine.js';
import { logInfo, logWarning, logDebug } from '../telemetry/logger.js';

interface RoadmapInboxEntry {
  id: string;
  status?: string;
  title?: string;
  summary?: string;
  domain?: string;
  source?: string;
  notes?: string;
  blockers?: string;
  signals?: string;
  layers?: string[];
  integration?: string;
  task_id?: string;
  accepted_at?: string;
  [key: string]: unknown;
}

export class RoadmapInboxProcessor {
  private readonly inboxPath: string;

  constructor(
    private readonly workspaceRoot: string,
    private readonly stateMachine: StateMachine
  ) {
    this.inboxPath = path.join(this.workspaceRoot, 'state', 'roadmap_inbox.json');
  }

  async processPendingEntries(): Promise<number> {
    const inbox = await this.loadInbox();
    if (!inbox) {
      return 0;
    }

    let processed = 0;
    let modified = false;

    for (const entry of inbox) {
      if (!entry || typeof entry !== 'object') {
        continue;
      }

      const status = (entry.status ?? '').toString().toLowerCase();
      if (status !== 'pending_review' && status !== 'pending' && status !== 'approved_by_ai') {
        continue;
      }

      const taskId = this.buildTaskId(entry);
      const existingTask = this.stateMachine.getTask(taskId);

      if (existingTask) {
        if (entry.status !== 'accepted') {
          entry.status = 'accepted';
          entry.task_id = existingTask.id;
          entry.accepted_at = new Date().toISOString();
          modified = true;
          processed += 1;
        }
        continue;
      }

      const created = this.createTaskFromInbox(entry, taskId);
      if (!created) {
        continue;
      }

      entry.status = 'accepted';
      entry.task_id = created.id;
      entry.accepted_at = new Date().toISOString();
      modified = true;
      processed += 1;
    }

    if (modified) {
      await this.saveInbox(inbox);
    }

    if (processed > 0) {
      logInfo('Roadmap inbox entries promoted', { count: processed });
    }

    return processed;
  }

  private buildTaskId(entry: RoadmapInboxEntry): string {
    const rawId = entry.id ?? entry.title ?? entry.summary ?? `inbox-${Date.now()}`;
    const normalized = rawId
      .toString()
      .trim()
      .replace(/[^a-zA-Z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .toUpperCase();
    return `INBOX-${normalized}`;
  }

  private createTaskFromInbox(entry: RoadmapInboxEntry, taskId: string): Task | null {
    try {
      const title = entry.title ?? entry.summary ?? `Inbox Proposal ${entry.id ?? taskId}`;
      const descriptionParts = [
        entry.summary,
        entry.notes,
        entry.blockers ? `Blockers: ${entry.blockers}` : null,
        entry.signals ? `Signals: ${entry.signals}` : null,
        entry.integration ? `Integration: ${entry.integration}` : null,
      ]
        .filter(Boolean)
        .join('\n\n');

      const metadata: Record<string, unknown> = {
        source: 'roadmap_inbox',
        inbox_id: entry.id,
        domain: entry.domain,
        signals: entry.signals,
        blockers: entry.blockers,
        layers: entry.layers,
        integration: entry.integration,
        autogenerated: true,
        created_at: new Date().toISOString(),
      };

      const task = this.stateMachine.createTask({
        id: taskId,
        title,
        description: descriptionParts,
        type: 'task',
        status: 'pending',
        epic_id: this.mapDomainToEpic(entry.domain),
        metadata,
      });

      logDebug('Created task from roadmap inbox entry', {
        taskId,
        inboxId: entry.id,
        domain: entry.domain,
      });

      return task;
    } catch (error) {
      logWarning('Failed to create task from roadmap inbox entry', {
        inboxId: entry.id,
        error: error instanceof Error ? error.message : String(error),
      });
      return null;
    }
  }

  private mapDomainToEpic(domain?: string): string | undefined {
    const normalized = (domain ?? '').toLowerCase();
    if (normalized.startsWith('phase0') || normalized.startsWith('phase 0')) {
      return 'E-PHASE0';
    }
    if (normalized.startsWith('phase1') || normalized.startsWith('phase 1')) {
      return 'E-PHASE1';
    }
    if (normalized.includes('product')) {
      return 'E-PHASE0';
    }
    if (normalized.includes('mcp') || normalized.includes('orchestration')) {
      return 'E-GENERAL';
    }
    return undefined;
  }

  private async loadInbox(): Promise<RoadmapInboxEntry[] | null> {
    try {
      const content = await fs.readFile(this.inboxPath, 'utf-8');
      const parsed = JSON.parse(content);
      if (!Array.isArray(parsed)) {
        logWarning('Roadmap inbox file does not contain an array', { path: this.inboxPath });
        return [];
      }
      return parsed as RoadmapInboxEntry[];
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        return [];
      }
      logWarning('Failed to read roadmap inbox', {
        path: this.inboxPath,
        error: error instanceof Error ? error.message : String(error),
      });
      return null;
    }
  }

  private async saveInbox(entries: RoadmapInboxEntry[]): Promise<void> {
    const serialized = JSON.stringify(entries, null, 2);
    await fs.writeFile(this.inboxPath, `${serialized}\n`, 'utf-8');
  }
}
