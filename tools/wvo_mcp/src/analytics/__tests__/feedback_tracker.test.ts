import { mkdtempSync, readFileSync, rmSync } from "node:fs";
import path from "node:path";
import os from "node:os";

import { describe, expect, it } from "vitest";

import { FeedbackTracker, computeFeedbackDensity, readFeedbackLoops } from "../feedback_tracker.js";
import type { Task } from "../../orchestrator/state_machine.js";
import type { ExecutionOutcome } from "../../orchestrator/agent_pool.js";
import type { QualityCheckResult } from "../../orchestrator/quality_monitor.js";
import type { ExecutionSummary } from "../../orchestrator/agent_coordinator.js";
import type { AssembledContext } from "../../orchestrator/context_assembler.js";

function createTask(id = "AFP-MCP-TRACK"): Task {
  return {
    id,
    title: "Feedback tracking demo",
    description: "Implement feedback loop tracking",
    type: "task",
    status: "in_progress",
    created_at: Date.now() - 3_600_000,
    started_at: Date.now() - 1_800_000,
    metadata: {
      follow_up_tasks: ["AFP-MCP-FOLLOW"],
      adaptation: "Monitor loop density after deployment",
    },
  };
}

function createContext(task: Task): AssembledContext {
  return {
    task,
    relatedTasks: [],
    dependentTasks: [],
    isAutogenerated: false,
    relevantDecisions: [
      {
        timestamp: Date.now(),
        entry_type: "decision",
        topic: "Loop strategy",
        content: "Ensure monitor stage logs completion evidence.",
      },
    ],
    relevantConstraints: [],
    recentLearnings: [],
    qualityIssuesInArea: [],
    overallQualityTrend: [],
    researchHighlights: [],
    filesToRead: [],
    recentChangesInArea: [],
    projectPhase: "implement",
    velocityMetrics: {
      tasksCompletedToday: 3,
      averageTaskDuration: 4200,
      qualityTrendOverall: "stable",
    },
  };
}

function createExecutionOutcome(success = true): ExecutionOutcome {
  return {
    success,
    output: "Completed loop tracker implementation.",
    durationSeconds: 1_200,
    tokenUsage: { promptTokens: 1500, completionTokens: 350, totalTokens: 1850 },
    costUSD: 1.1,
  };
}

function createQuality(): QualityCheckResult {
  return {
    status: "pass",
    score: 0.9,
    metrics: [],
    issues: [],
    report: {
      overall_score: 92,
      dimension_scores: {
        code_elegance: 92,
        architecture_design: 90,
        user_experience: 0,
        communication_clarity: 0,
        scientific_rigor: 0,
        performance_efficiency: 0,
        maintainability: 0,
        security_robustness: 0,
        documentation_quality: 0,
        testing_coverage: 0,
      },
      assessments: [],
      world_class_areas: [],
      needs_attention: [],
      next_actions: [],
    },
  };
}

function createSummary(task: Task, execution: ExecutionOutcome): ExecutionSummary {
  return {
    taskId: task.id,
    agentId: "agent-42",
    agentType: "codex",
    success: execution.success,
    finalStatus: execution.success ? "done" : "needs_improvement",
    durationSeconds: execution.durationSeconds ?? 0,
    qualityScore: 0.9,
    issues: [],
    timestamp: Date.now(),
    projectPhase: "monitor",
    promptTokens: execution.tokenUsage?.promptTokens ?? 0,
    completionTokens: execution.tokenUsage?.completionTokens ?? 0,
    totalTokens: execution.tokenUsage?.totalTokens ?? 0,
    tokenCostUSD: execution.costUSD,
    tokenEstimateStrategy: "reported",
    correlationId: "loop-test",
    coordinatorType: "codex",
    coordinatorReason: "primary",
    coordinatorAvailable: true,
    criticsRequired: [],
    criticsFailed: [],
    promptCacheStatus: "unknown",
  };
}

describe("feedback tracker", () => {
  it("opens, tracks iterations, and closes loops", async () => {
    const tempDir = mkdtempSync(path.join(os.tmpdir(), "feedback-tracker-"));
    try {
      const tracker = new FeedbackTracker(tempDir);
      const task = createTask();
      await tracker.openFeedbackLoop(task);
      await tracker.markIteration(task.id);

      const execution = createExecutionOutcome(true);
      const summary = createSummary(task, execution);
      await tracker.closeFeedbackLoop({
        task,
        execution,
        summary,
        quality: createQuality(),
        context: createContext(task),
      });

      const logPath = path.join(tempDir, "state", "analytics", "feedback_loops.jsonl");
      const lines = readFileSync(logPath, "utf8")
        .trim()
        .split("\n")
        .map((l) => JSON.parse(l));
      const finalRecord = lines.at(-1);
      expect(finalRecord.loop_closed).toBe(true);
      expect(finalRecord.iterations_to_close).toBe(1);
      expect(finalRecord.loop_quality).toBe("medium");
      expect(finalRecord.follow_up_tasks).toContain("AFP-MCP-FOLLOW");
    } finally {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });

  it("computes feedback density from records", () => {
    const records = [
      {
        loop_id: "1",
        task_id: "AFP-1",
        loop_opened_timestamp: new Date().toISOString(),
        loop_closed_timestamp: new Date().toISOString(),
        loop_duration_hours: 2,
        loop_closed: true,
        loop_quality: "high",
        input: "",
        process: "",
        output: "",
        feedback: "",
        adaptation: "",
        iterations_to_close: 0,
        adjustments_made: 0,
        follow_up_tasks: [],
      },
      {
        loop_id: "2",
        task_id: "AFP-2",
        loop_opened_timestamp: new Date().toISOString(),
        loop_closed_timestamp: null,
        loop_duration_hours: null,
        loop_closed: false,
        loop_quality: null,
        input: "",
        process: "",
        output: "",
        feedback: "",
        adaptation: "",
        iterations_to_close: 0,
        adjustments_made: 0,
        follow_up_tasks: [],
      },
    ];
    const density = computeFeedbackDensity(records as any);
    expect(density).toBeCloseTo(0.5);
  });

  it("reads feedback loops from disk", async () => {
    const tempDir = mkdtempSync(path.join(os.tmpdir(), "feedback-read-"));
    try {
      const tracker = new FeedbackTracker(tempDir);
      const task = createTask("AFP-READ");
      await tracker.openFeedbackLoop(task);
      await tracker.closeFeedbackLoop({
        task,
        execution: createExecutionOutcome(true),
        summary: createSummary(task, createExecutionOutcome(true)),
        quality: createQuality(),
        context: createContext(task),
      });

      const loops = await readFeedbackLoops(tempDir);
      expect(loops.length).toBeGreaterThan(0);
      expect(loops[loops.length - 1].task_id).toBe("AFP-READ");
    } finally {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });
});
