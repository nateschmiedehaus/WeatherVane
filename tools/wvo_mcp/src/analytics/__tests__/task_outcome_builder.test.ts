import { mkdtempSync, readFileSync, rmSync } from "node:fs";
import path from "node:path";
import os from "node:os";

import { describe, expect, it } from "vitest";

import type { Task } from "../../orchestrator/state_machine.js";
import type { ExecutionOutcome } from "../../orchestrator/agent_pool.js";
import type { QualityCheckResult } from "../../orchestrator/quality_monitor.js";
import type { ExecutionSummary } from "../../orchestrator/agent_coordinator.js";
import type { AssembledContext } from "../../orchestrator/context_assembler.js";
import { buildTaskOutcome } from "../task_outcome_builder.js";
import { logTaskOutcome } from "../task_outcome_logger.js";

function createTask(): Task {
  return {
    id: "AFP-MCP-EXAMPLE",
    title: "Example task",
    description: "Demo task for outcome logging",
    type: "task",
    status: "done",
    created_at: Date.now() - 3_600_000,
    started_at: Date.now() - 1_800_000,
    completed_at: Date.now(),
    estimated_complexity: 6,
    metadata: {
      estimated_files: 3,
      actual_files: 4,
      estimated_time_minutes: 90,
      token_budget_estimated: 6_000,
      cost_estimate_usd: 3.25,
      evidence_bundle_path: "state/evidence/AFP-MCP-EXAMPLE",
    },
  };
}

function createContext(): AssembledContext {
  return {
    task: createTask(),
    relatedTasks: [
      {
        ...createTask(),
        id: "AFP-MCP-PRIOR",
        status: "done",
      },
    ],
    dependentTasks: [],
    isAutogenerated: false,
    relevantDecisions: [],
    relevantConstraints: [],
    recentLearnings: [],
    qualityIssuesInArea: [],
    overallQualityTrend: [],
    projectPhase: "implement",
    velocityMetrics: {
      tasksCompletedToday: 3,
      averageTaskDuration: 4200,
      qualityTrendOverall: "improving",
    },
    researchHighlights: [],
    filesToRead: [],
    recentChangesInArea: [],
  };
}

function createExecutionOutcome(): ExecutionOutcome {
  return {
    success: true,
    output: "Task completed successfully",
    durationSeconds: 900,
    tokenUsage: {
      promptTokens: 2_400,
      completionTokens: 680,
      totalTokens: 3_080,
    },
    costUSD: 1.87,
  };
}

function createQualityResult(): QualityCheckResult {
  return {
    status: "pass",
    score: 0.91,
    metrics: [],
    issues: ["lint_warning"],
    report: {
      overall_score: 93.2,
      dimension_scores: {
        code_elegance: 94,
        architecture_design: 92,
        user_experience: 0,
        communication_clarity: 0,
        scientific_rigor: 0,
        performance_efficiency: 0,
        maintainability: 0,
        security_robustness: 0,
        documentation_quality: 0,
        testing_coverage: 0,
      },
      assessments: [],
      world_class_areas: [],
      needs_attention: [],
      next_actions: [],
    },
  };
}

function createSummary(): ExecutionSummary {
  return {
    taskId: "AFP-MCP-EXAMPLE",
    agentId: "agent-123",
    agentType: "codex",
    success: true,
    finalStatus: "done",
    durationSeconds: 900,
    qualityScore: 0.91,
    issues: ["lint_warning"],
    timestamp: Date.now(),
    projectPhase: "implement",
    coordinatorType: "codex",
    coordinatorReason: "primary",
    coordinatorAvailable: true,
    codexPreset: "default",
    codexModel: "gpt-4",
    codexReasoning: "medium",
    promptTokens: 2_400,
    completionTokens: 680,
    totalTokens: 3_080,
    tokenCostUSD: 1.87,
    tokenEstimateStrategy: "reported",
    criticsRequired: [],
    criticsFailed: [],
    correlationId: "corr-123",
    promptCacheStatus: "unknown",
    promptCacheTier: undefined,
    promptCacheId: undefined,
    promptCacheHit: undefined,
    promptCacheStore: undefined,
    promptCacheEligible: undefined,
    promptCacheRaw: undefined,
    failureType: undefined,
  };
}

describe("task outcome builder", () => {
  it("normalizes metadata and telemetry fields", () => {
    const task = createTask();
    const execution = createExecutionOutcome();
    const quality = createQualityResult();
    const summary = createSummary();
    const context = createContext();

    const outcome = buildTaskOutcome({
      task,
      execution,
      quality,
      summary,
      context,
      criticOutcome: {
        passed: true,
        required: [],
        failedCritics: ["design_review"],
      },
      guardrailAdjustments: [
        { guardrail_id: "micro_batching.max_files", old_value: 5, new_value: 8, reason: "bootstrap exception" },
      ],
      promptVersion: "compact",
    });

    expect(outcome.task_id).toBe("AFP-MCP-EXAMPLE");
    expect(outcome.success).toBe(true);
    expect(outcome.budgets.token_budget_estimated).toBe(6_000);
    expect(outcome.budgets.token_budget_actual).toBe(3_080);
    expect(outcome.budgets.time_budget_actual_minutes).toBeCloseTo(15, 1);
    expect(outcome.budgets.cost_actual_usd).toBeCloseTo(1.87, 2);
    expect(outcome.guardrails_triggered).toContain("lint_warning");
    expect(outcome.guardrails_triggered).toContain("critic_failed:design_review");
    expect(outcome.critic_issues).toEqual(["critic_failed:design_review"]);
    expect(outcome.stigmergy.influenced_by_task).toBe("AFP-MCP-PRIOR");
    expect(outcome.prompt.prompt_tokens).toBe(2_400);
    expect(outcome.prompt.completion_tokens).toBe(680);
    expect(outcome.prompt.prompt_version).toBe("compact");
  });

  it("logs outcome to JSONL file", async () => {
    const tempDir = mkdtempSync(path.join(os.tmpdir(), "outcome-log-"));
    try {
      const task = createTask();
      const execution = createExecutionOutcome();
      const quality = createQualityResult();
      const summary = createSummary();
      const context = createContext();

      const outcome = buildTaskOutcome({
        task,
        execution,
        quality,
        summary,
        context,
      });

      await logTaskOutcome(outcome, {
        workspaceRoot: tempDir,
        relativePath: "analytics/test_task_outcomes.jsonl",
      });

      const logPath = path.join(tempDir, "state", "analytics", "test_task_outcomes.jsonl");
      const lines = readFileSync(logPath, "utf8").trim().split("\n");
      expect(lines).toHaveLength(1);
      const parsed = JSON.parse(lines[0]);
      expect(parsed.task_id).toBe("AFP-MCP-EXAMPLE");
      expect(parsed.success).toBe(true);
    } finally {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });
});
