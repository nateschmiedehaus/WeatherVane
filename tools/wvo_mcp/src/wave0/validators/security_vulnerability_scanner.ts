/**
 * Security & Vulnerability Scanner
 *
 * RIGOROUS security validation that goes beyond basic checks.
 * Performs deep vulnerability scanning, OWASP compliance checks,
 * secret detection, dependency vulnerability analysis, and security
 * best practices enforcement.
 */

import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';
import * as crypto from 'crypto';

interface SecurityVulnerability {
  severity: 'critical' | 'high' | 'medium' | 'low';
  type: string;
  description: string;
  file?: string;
  line?: number;
  cwe?: string; // Common Weakness Enumeration
  owasp?: string; // OWASP Top 10 category
  remediation: string;
  exploitability: 'high' | 'medium' | 'low';
}

interface SecurityScanResult {
  passed: boolean;
  vulnerabilities: SecurityVulnerability[];
  riskScore: number; // 0-100
  compliance: {
    owasp: boolean;
    pci: boolean;
    gdpr: boolean;
  };
  recommendations: string[];
  criticalFindings: number;
}

export class SecurityVulnerabilityScanner {
  private readonly workspaceRoot: string;
  private vulnerabilities: SecurityVulnerability[] = [];
  private readonly secretPatterns: Map<string, RegExp>;
  private readonly vulnerablePatterns: Map<string, { pattern: RegExp, cwe: string }>;

  constructor(workspaceRoot: string) {
    this.workspaceRoot = workspaceRoot;

    // Initialize secret detection patterns
    this.secretPatterns = new Map([
      ['aws_access_key', /AKIA[0-9A-Z]{16}/],
      ['aws_secret_key', /(?:aws|AWS|Aws)?(?:_|-)?(?:SECRET|secret|Secret)(?:_|-)?(?:ACCESS|access|Access)?(?:_|-)?(?:KEY|key|Key)["']?\s*[:=]\s*["']([A-Za-z0-9/+=]{40})["']/],
      ['github_token', /ghp_[a-zA-Z0-9]{36}/],
      ['npm_token', /npm_[a-zA-Z0-9]{36}/],
      ['slack_token', /xox[baprs]-[0-9]{10,12}-[0-9]{10,12}-[a-zA-Z0-9]{24}/],
      ['stripe_key', /sk_live_[0-9a-zA-Z]{24}/],
      ['jwt_secret', /(?:jwt|JWT|Jwt)(?:_|-)?(?:SECRET|secret|Secret)["']?\s*[:=]\s*["']([^"']+)["']/],
      ['private_key', /-----BEGIN (?:RSA |EC )?PRIVATE KEY-----/],
      ['api_key', /(?:api|API|Api)(?:_|-)?(?:KEY|key|Key)["']?\s*[:=]\s*["']([A-Za-z0-9]{32,})["']/],
      ['database_url', /(?:DATABASE_URL|DB_CONNECTION)["']?\s*[:=]\s*["']([^"']+)["']/]
    ]);

    // Initialize vulnerability patterns with CWE mapping
    this.vulnerablePatterns = new Map([
      ['sql_injection', {
        pattern: /query\([`"'].*\$\{.*\}.*[`"']\)/,
        cwe: 'CWE-89'
      }],
      ['xss', {
        pattern: /innerHTML\s*=\s*[^`]|\$\{.*\}.*<script/,
        cwe: 'CWE-79'
      }],
      ['command_injection', {
        pattern: /exec(?:Sync)?\([`"'].*\$\{.*\}.*[`"']\)/,
        cwe: 'CWE-78'
      }],
      ['path_traversal', {
        pattern: /\.\.\/|\.\.\\/,
        cwe: 'CWE-22'
      }],
      ['xxe', {
        pattern: /new\s+DOMParser\(\)\.parseFromString/,
        cwe: 'CWE-611'
      }],
      ['ssrf', {
        pattern: /fetch\([`"'].*\$\{.*\}.*[`"']\)/,
        cwe: 'CWE-918'
      }],
      ['insecure_random', {
        pattern: /Math\.random\(\).*(?:password|token|secret|key)/i,
        cwe: 'CWE-330'
      }],
      ['weak_crypto', {
        pattern: /createHash\(['"](?:md5|sha1)['"]\)/,
        cwe: 'CWE-327'
      }],
      ['eval_usage', {
        pattern: /eval\s*\(|new\s+Function\s*\(/,
        cwe: 'CWE-94'
      }],
      ['unsafe_deserialization', {
        pattern: /JSON\.parse\([^)]*user(?:Input|Data)|request\.body[^)]*\)/,
        cwe: 'CWE-502'
      }]
    ]);
  }

  /**
   * Run RIGOROUS security vulnerability scanning
   */
  async scan(targetPath?: string): Promise<SecurityScanResult> {
    console.log('ðŸ”’ Starting RIGOROUS Security Vulnerability Scan...');
    console.log('  Scanning with multiple security engines...\n');

    // Reset vulnerabilities
    this.vulnerabilities = [];

    // Phase 1: Secret Detection
    console.log('  ðŸ”‘ Phase 1: Secret Detection...');
    await this.scanForSecrets(targetPath);

    // Phase 2: OWASP Top 10 Vulnerability Scan
    console.log('  ðŸ›¡ï¸ Phase 2: OWASP Top 10 Vulnerability Scan...');
    await this.scanForOwaspVulnerabilities(targetPath);

    // Phase 3: Dependency Vulnerability Analysis
    console.log('  ðŸ“¦ Phase 3: Dependency Vulnerability Analysis...');
    await this.scanDependencies();

    // Phase 4: Code Injection Vulnerabilities
    console.log('  ðŸ’‰ Phase 4: Code Injection Vulnerability Scan...');
    await this.scanForInjectionVulnerabilities(targetPath);

    // Phase 5: Authentication & Authorization Issues
    console.log('  ðŸ” Phase 5: Authentication & Authorization Scan...');
    await this.scanForAuthIssues(targetPath);

    // Phase 6: Cryptographic Weaknesses
    console.log('  ðŸ”“ Phase 6: Cryptographic Weakness Detection...');
    await this.scanForCryptoWeaknesses(targetPath);

    // Phase 7: Configuration Security
    console.log('  âš™ï¸ Phase 7: Configuration Security Check...');
    await this.scanConfigurationSecurity();

    // Phase 8: API Security
    console.log('  ðŸŒ Phase 8: API Security Validation...');
    await this.scanApiSecurity(targetPath);

    // Phase 9: Infrastructure as Code Security
    console.log('  â˜ï¸ Phase 9: Infrastructure Security Scan...');
    await this.scanInfrastructureSecurity(targetPath);

    // Phase 10: Compliance Check
    console.log('  âœ… Phase 10: Compliance Verification...');
    const compliance = await this.checkCompliance();

    // Calculate risk score
    const riskScore = this.calculateRiskScore();

    // Generate recommendations
    const recommendations = this.generateSecurityRecommendations();

    // Count critical findings
    const criticalFindings = this.vulnerabilities.filter(v =>
      v.severity === 'critical' || v.severity === 'high'
    ).length;

    // Determine pass/fail
    const passed = criticalFindings === 0 && riskScore < 30;

    return {
      passed,
      vulnerabilities: this.vulnerabilities,
      riskScore,
      compliance,
      recommendations,
      criticalFindings
    };
  }

  private async scanForSecrets(targetPath?: string): Promise<void> {
    const files = this.getAllFiles(targetPath);

    for (const file of files) {
      // Skip binary files
      if (this.isBinaryFile(file)) continue;

      const content = fs.readFileSync(file, 'utf-8');
      const lines = content.split('\n');

      for (const [secretType, pattern] of this.secretPatterns) {
        lines.forEach((line, index) => {
          if (pattern.test(line)) {
            // Check if it's not a false positive
            if (!this.isFalsePositive(line, secretType)) {
              this.vulnerabilities.push({
                severity: 'critical',
                type: 'exposed_secret',
                description: `Potential ${secretType.replace('_', ' ')} exposed`,
                file: path.relative(this.workspaceRoot, file),
                line: index + 1,
                cwe: 'CWE-798',
                owasp: 'A07:2021',
                remediation: 'Remove secret from code and use environment variables or secure vault',
                exploitability: 'high'
              });
            }
          }
        });
      }
    }

    // Also check for .env files in version control
    if (fs.existsSync(path.join(this.workspaceRoot, '.env'))) {
      try {
        const gitIgnore = fs.readFileSync(path.join(this.workspaceRoot, '.gitignore'), 'utf-8');
        if (!gitIgnore.includes('.env')) {
          this.vulnerabilities.push({
            severity: 'critical',
            type: 'exposed_config',
            description: '.env file not in .gitignore',
            file: '.env',
            cwe: 'CWE-532',
            owasp: 'A05:2021',
            remediation: 'Add .env to .gitignore immediately',
            exploitability: 'high'
          });
        }
      } catch (error) {
        // No .gitignore file
      }
    }
  }

  private async scanForOwaspVulnerabilities(targetPath?: string): Promise<void> {
    const files = this.getSourceFiles(targetPath);

    const owaspChecks = [
      // A01:2021 â€“ Broken Access Control
      {
        check: (content: string) => !content.includes('authenticate') && content.includes('router.'),
        vulnerability: {
          severity: 'high' as const,
          type: 'broken_access_control',
          description: 'API routes without authentication checks',
          owasp: 'A01:2021',
          cwe: 'CWE-862',
          remediation: 'Add authentication middleware to all sensitive routes',
          exploitability: 'high' as const
        }
      },
      // A02:2021 â€“ Cryptographic Failures
      {
        check: (content: string) => /password\s*=\s*['"][^'"]+['"]/.test(content),
        vulnerability: {
          severity: 'critical' as const,
          type: 'cryptographic_failure',
          description: 'Plaintext password storage detected',
          owasp: 'A02:2021',
          cwe: 'CWE-256',
          remediation: 'Use bcrypt or argon2 for password hashing',
          exploitability: 'high' as const
        }
      },
      // A03:2021 â€“ Injection
      {
        check: (content: string) => this.vulnerablePatterns.get('sql_injection')!.pattern.test(content),
        vulnerability: {
          severity: 'critical' as const,
          type: 'injection',
          description: 'SQL injection vulnerability detected',
          owasp: 'A03:2021',
          cwe: 'CWE-89',
          remediation: 'Use parameterized queries or ORM with proper escaping',
          exploitability: 'high' as const
        }
      },
      // A04:2021 â€“ Insecure Design
      {
        check: (content: string) => /rate[_-]?limit/i.test(content) === false && /api|endpoint/i.test(content),
        vulnerability: {
          severity: 'medium' as const,
          type: 'insecure_design',
          description: 'API endpoint without rate limiting',
          owasp: 'A04:2021',
          cwe: 'CWE-770',
          remediation: 'Implement rate limiting for all API endpoints',
          exploitability: 'medium' as const
        }
      },
      // A05:2021 â€“ Security Misconfiguration
      {
        check: (content: string) => /cors\(\s*\)/.test(content) || /cors:\s*{\s*origin:\s*['"]\*['"]/.test(content),
        vulnerability: {
          severity: 'high' as const,
          type: 'security_misconfiguration',
          description: 'Overly permissive CORS configuration',
          owasp: 'A05:2021',
          cwe: 'CWE-942',
          remediation: 'Configure CORS with specific allowed origins',
          exploitability: 'medium' as const
        }
      },
      // A06:2021 â€“ Vulnerable and Outdated Components
      // (Handled in dependency scanning)

      // A07:2021 â€“ Identification and Authentication Failures
      {
        check: (content: string) => /session.*maxAge.*60000/.test(content), // 1 minute sessions
        vulnerability: {
          severity: 'medium' as const,
          type: 'authentication_failure',
          description: 'Session timeout too short or too long',
          owasp: 'A07:2021',
          cwe: 'CWE-613',
          remediation: 'Set appropriate session timeout (15-30 minutes for sensitive apps)',
          exploitability: 'low' as const
        }
      },
      // A08:2021 â€“ Software and Data Integrity Failures
      {
        check: (content: string) => /npm\s+install.*--no-verify/.test(content),
        vulnerability: {
          severity: 'high' as const,
          type: 'integrity_failure',
          description: 'Package installation without integrity verification',
          owasp: 'A08:2021',
          cwe: 'CWE-494',
          remediation: 'Always verify package integrity during installation',
          exploitability: 'medium' as const
        }
      },
      // A09:2021 â€“ Security Logging and Monitoring Failures
      {
        check: (content: string) => !content.includes('logger') && content.includes('catch'),
        vulnerability: {
          severity: 'low' as const,
          type: 'logging_failure',
          description: 'Error handling without proper logging',
          owasp: 'A09:2021',
          cwe: 'CWE-778',
          remediation: 'Implement comprehensive security logging',
          exploitability: 'low' as const
        }
      },
      // A10:2021 â€“ Server-Side Request Forgery (SSRF)
      {
        check: (content: string) => this.vulnerablePatterns.get('ssrf')!.pattern.test(content),
        vulnerability: {
          severity: 'high' as const,
          type: 'ssrf',
          description: 'Potential SSRF vulnerability with user-controlled URLs',
          owasp: 'A10:2021',
          cwe: 'CWE-918',
          remediation: 'Validate and whitelist allowed URLs',
          exploitability: 'high' as const
        }
      }
    ];

    for (const file of files) {
      const content = fs.readFileSync(file, 'utf-8');

      for (const owaspCheck of owaspChecks) {
        if (owaspCheck.check(content)) {
          this.vulnerabilities.push({
            ...owaspCheck.vulnerability,
            file: path.relative(this.workspaceRoot, file)
          });
        }
      }
    }
  }

  private async scanDependencies(): Promise<void> {
    try {
      // Run npm audit
      const auditResult = execSync('npm audit --json', {
        cwd: this.workspaceRoot,
        encoding: 'utf-8',
        stdio: ['pipe', 'pipe', 'ignore'] // Ignore stderr
      });

      const audit = JSON.parse(auditResult);

      if (audit.vulnerabilities) {
        for (const [pkg, vuln] of Object.entries(audit.vulnerabilities) as any) {
          for (const finding of vuln.via || []) {
            if (typeof finding === 'object') {
              this.vulnerabilities.push({
                severity: this.mapNpmSeverity(finding.severity),
                type: 'vulnerable_dependency',
                description: `${pkg}: ${finding.title}`,
                cwe: finding.cwe?.[0] || 'CWE-1035',
                owasp: 'A06:2021',
                remediation: finding.fixAvailable ?
                  `Update ${pkg} to version ${finding.fixAvailable.version}` :
                  `No fix available yet for ${pkg}`,
                exploitability: finding.severity === 'critical' ? 'high' : 'medium'
              });
            }
          }
        }
      }
    } catch (error) {
      // npm audit might return non-zero exit code
    }

    // Check for packages with known vulnerabilities
    const packageJson = JSON.parse(
      fs.readFileSync(path.join(this.workspaceRoot, 'package.json'), 'utf-8')
    );

    const riskyPackages = [
      'request', // Deprecated
      'node-uuid', // Renamed to uuid
      'jade', // Renamed to pug
      'constantinople', // Known RCE
      'js-yaml', // Older versions have RCE
    ];

    const allDeps = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies
    };

    for (const [pkg, version] of Object.entries(allDeps)) {
      if (riskyPackages.includes(pkg)) {
        this.vulnerabilities.push({
          severity: 'high',
          type: 'deprecated_package',
          description: `Using deprecated/vulnerable package: ${pkg}`,
          owasp: 'A06:2021',
          cwe: 'CWE-1104',
          remediation: `Replace ${pkg} with modern alternative`,
          exploitability: 'medium'
        });
      }
    }
  }

  private async scanForInjectionVulnerabilities(targetPath?: string): Promise<void> {
    const files = this.getSourceFiles(targetPath);

    for (const file of files) {
      const content = fs.readFileSync(file, 'utf-8');
      const lines = content.split('\n');

      for (const [vulnType, vulnData] of this.vulnerablePatterns) {
        lines.forEach((line, index) => {
          if (vulnData.pattern.test(line)) {
            this.vulnerabilities.push({
              severity: this.getInjectionSeverity(vulnType),
              type: vulnType,
              description: `Potential ${vulnType.replace('_', ' ')} vulnerability`,
              file: path.relative(this.workspaceRoot, file),
              line: index + 1,
              cwe: vulnData.cwe,
              owasp: 'A03:2021',
              remediation: this.getInjectionRemediation(vulnType),
              exploitability: 'high'
            });
          }
        });
      }

      // Additional injection checks
      // NoSQL injection
      if (content.includes('$where') || content.includes('$regex')) {
        this.vulnerabilities.push({
          severity: 'high',
          type: 'nosql_injection',
          description: 'Potential NoSQL injection vulnerability',
          file: path.relative(this.workspaceRoot, file),
          cwe: 'CWE-943',
          owasp: 'A03:2021',
          remediation: 'Sanitize user input before using in NoSQL queries',
          exploitability: 'high'
        });
      }

      // LDAP injection
      if (content.includes('ldap') && content.includes('${')) {
        this.vulnerabilities.push({
          severity: 'high',
          type: 'ldap_injection',
          description: 'Potential LDAP injection vulnerability',
          file: path.relative(this.workspaceRoot, file),
          cwe: 'CWE-90',
          owasp: 'A03:2021',
          remediation: 'Use parameterized LDAP queries',
          exploitability: 'medium'
        });
      }

      // Template injection
      if (/\{\{.*user.*\}\}/.test(content)) {
        this.vulnerabilities.push({
          severity: 'high',
          type: 'template_injection',
          description: 'Potential template injection vulnerability',
          file: path.relative(this.workspaceRoot, file),
          cwe: 'CWE-1336',
          owasp: 'A03:2021',
          remediation: 'Sanitize user input in templates',
          exploitability: 'medium'
        });
      }
    }
  }

  private async scanForAuthIssues(targetPath?: string): Promise<void> {
    const files = this.getSourceFiles(targetPath);

    for (const file of files) {
      const content = fs.readFileSync(file, 'utf-8');

      // Check for hardcoded credentials
      if (/(?:username|user).*=.*["'][^"']+["'].*(?:password|pass).*=.*["'][^"']+["']/i.test(content)) {
        this.vulnerabilities.push({
          severity: 'critical',
          type: 'hardcoded_credentials',
          description: 'Hardcoded username and password detected',
          file: path.relative(this.workspaceRoot, file),
          cwe: 'CWE-798',
          owasp: 'A07:2021',
          remediation: 'Use environment variables or secure credential storage',
          exploitability: 'high'
        });
      }

      // Check for weak password requirements
      if (/password.*length.*<\s*[1-7]\D/.test(content)) {
        this.vulnerabilities.push({
          severity: 'medium',
          type: 'weak_password_policy',
          description: 'Weak password length requirement',
          file: path.relative(this.workspaceRoot, file),
          cwe: 'CWE-521',
          owasp: 'A07:2021',
          remediation: 'Require minimum 8 characters for passwords',
          exploitability: 'low'
        });
      }

      // Check for missing MFA
      if (content.includes('login') && !content.includes('totp') && !content.includes('2fa')) {
        this.vulnerabilities.push({
          severity: 'medium',
          type: 'missing_mfa',
          description: 'No multi-factor authentication implemented',
          file: path.relative(this.workspaceRoot, file),
          cwe: 'CWE-308',
          owasp: 'A07:2021',
          remediation: 'Implement multi-factor authentication for sensitive operations',
          exploitability: 'medium'
        });
      }

      // Check for session fixation
      if (content.includes('session') && !content.includes('regenerate')) {
        this.vulnerabilities.push({
          severity: 'medium',
          type: 'session_fixation',
          description: 'Session ID not regenerated after login',
          file: path.relative(this.workspaceRoot, file),
          cwe: 'CWE-384',
          owasp: 'A07:2021',
          remediation: 'Regenerate session ID after successful authentication',
          exploitability: 'medium'
        });
      }
    }
  }

  private async scanForCryptoWeaknesses(targetPath?: string): Promise<void> {
    const files = this.getSourceFiles(targetPath);

    for (const file of files) {
      const content = fs.readFileSync(file, 'utf-8');

      // Weak hashing algorithms
      if (/md5|sha1/i.test(content)) {
        this.vulnerabilities.push({
          severity: 'high',
          type: 'weak_hash',
          description: 'Using weak hashing algorithm (MD5/SHA1)',
          file: path.relative(this.workspaceRoot, file),
          cwe: 'CWE-328',
          owasp: 'A02:2021',
          remediation: 'Use SHA-256, SHA-3, or better for hashing',
          exploitability: 'medium'
        });
      }

      // Weak encryption
      if (/des|rc4/i.test(content)) {
        this.vulnerabilities.push({
          severity: 'high',
          type: 'weak_encryption',
          description: 'Using weak encryption algorithm (DES/RC4)',
          file: path.relative(this.workspaceRoot, file),
          cwe: 'CWE-327',
          owasp: 'A02:2021',
          remediation: 'Use AES-256-GCM or ChaCha20-Poly1305',
          exploitability: 'medium'
        });
      }

      // Insufficient key length
      if (/(?:key|secret).*\.length\s*<\s*(?:16|128)/i.test(content)) {
        this.vulnerabilities.push({
          severity: 'medium',
          type: 'weak_key',
          description: 'Insufficient cryptographic key length',
          file: path.relative(this.workspaceRoot, file),
          cwe: 'CWE-326',
          owasp: 'A02:2021',
          remediation: 'Use at least 128-bit keys for symmetric encryption',
          exploitability: 'low'
        });
      }

      // Predictable random values
      if (/Math\.random.*(?:token|session|key)/i.test(content)) {
        this.vulnerabilities.push({
          severity: 'high',
          type: 'weak_random',
          description: 'Using Math.random() for security-sensitive values',
          file: path.relative(this.workspaceRoot, file),
          cwe: 'CWE-330',
          owasp: 'A02:2021',
          remediation: 'Use crypto.randomBytes() for cryptographic randomness',
          exploitability: 'high'
        });
      }
    }
  }

  private async scanConfigurationSecurity(): Promise<void> {
    // Check for security headers
    const configFiles = [
      'nginx.conf',
      'apache.conf',
      '.htaccess',
      'server.js',
      'app.js'
    ];

    for (const configFile of configFiles) {
      const fullPath = path.join(this.workspaceRoot, configFile);
      if (fs.existsSync(fullPath)) {
        const content = fs.readFileSync(fullPath, 'utf-8');

        // Check for missing security headers
        const securityHeaders = [
          'X-Frame-Options',
          'X-Content-Type-Options',
          'Content-Security-Policy',
          'Strict-Transport-Security'
        ];

        for (const header of securityHeaders) {
          if (!content.includes(header)) {
            this.vulnerabilities.push({
              severity: 'medium',
              type: 'missing_security_header',
              description: `Missing security header: ${header}`,
              file: configFile,
              cwe: 'CWE-693',
              owasp: 'A05:2021',
              remediation: `Add ${header} header to response`,
              exploitability: 'low'
            });
          }
        }
      }
    }

    // Check package.json for security issues
    const packagePath = path.join(this.workspaceRoot, 'package.json');
    if (fs.existsSync(packagePath)) {
      const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf-8'));

      // Check for missing security scripts
      if (!packageJson.scripts?.['audit']) {
        this.vulnerabilities.push({
          severity: 'low',
          type: 'missing_security_tooling',
          description: 'No npm audit script in package.json',
          file: 'package.json',
          cwe: 'CWE-1127',
          owasp: 'A06:2021',
          remediation: 'Add "audit": "npm audit" to scripts',
          exploitability: 'low'
        });
      }
    }
  }

  private async scanApiSecurity(targetPath?: string): Promise<void> {
    const files = this.getSourceFiles(targetPath);

    for (const file of files) {
      if (!file.includes('route') && !file.includes('api')) continue;

      const content = fs.readFileSync(file, 'utf-8');

      // Check for missing input validation
      if (content.includes('req.body') && !content.includes('validate')) {
        this.vulnerabilities.push({
          severity: 'high',
          type: 'missing_input_validation',
          description: 'API endpoint accepts unvalidated input',
          file: path.relative(this.workspaceRoot, file),
          cwe: 'CWE-20',
          owasp: 'A03:2021',
          remediation: 'Add input validation middleware (e.g., Joi, express-validator)',
          exploitability: 'high'
        });
      }

      // Check for missing rate limiting
      if (!content.includes('rateLimit') && !content.includes('throttle')) {
        this.vulnerabilities.push({
          severity: 'medium',
          type: 'missing_rate_limit',
          description: 'API endpoint without rate limiting',
          file: path.relative(this.workspaceRoot, file),
          cwe: 'CWE-799',
          owasp: 'A04:2021',
          remediation: 'Implement rate limiting (e.g., express-rate-limit)',
          exploitability: 'medium'
        });
      }

      // Check for API key in URL
      if (/\?.*api[_-]?key=/i.test(content)) {
        this.vulnerabilities.push({
          severity: 'high',
          type: 'api_key_in_url',
          description: 'API key passed in URL parameters',
          file: path.relative(this.workspaceRoot, file),
          cwe: 'CWE-598',
          owasp: 'A01:2021',
          remediation: 'Pass API keys in headers, not URL parameters',
          exploitability: 'high'
        });
      }
    }
  }

  private async scanInfrastructureSecurity(targetPath?: string): Promise<void> {
    // Check Dockerfile for security issues
    const dockerfilePath = path.join(this.workspaceRoot, 'Dockerfile');
    if (fs.existsSync(dockerfilePath)) {
      const content = fs.readFileSync(dockerfilePath, 'utf-8');

      // Running as root
      if (!content.includes('USER ')) {
        this.vulnerabilities.push({
          severity: 'medium',
          type: 'container_root_user',
          description: 'Container running as root user',
          file: 'Dockerfile',
          cwe: 'CWE-250',
          owasp: 'A05:2021',
          remediation: 'Add USER directive to run as non-root',
          exploitability: 'low'
        });
      }

      // Using latest tag
      if (/FROM.*:latest/.test(content)) {
        this.vulnerabilities.push({
          severity: 'low',
          type: 'unpinned_dependency',
          description: 'Using :latest tag in Dockerfile',
          file: 'Dockerfile',
          cwe: 'CWE-1104',
          owasp: 'A06:2021',
          remediation: 'Pin to specific version tags',
          exploitability: 'low'
        });
      }
    }

    // Check for terraform/CloudFormation security issues
    const terraformFiles = this.getAllFiles(targetPath).filter(f => f.endsWith('.tf'));
    for (const tfFile of terraformFiles) {
      const content = fs.readFileSync(tfFile, 'utf-8');

      // Check for public S3 buckets
      if (/acl\s*=\s*"public-read"/.test(content)) {
        this.vulnerabilities.push({
          severity: 'critical',
          type: 's3_public_access',
          description: 'S3 bucket with public read access',
          file: path.relative(this.workspaceRoot, tfFile),
          cwe: 'CWE-732',
          owasp: 'A01:2021',
          remediation: 'Set appropriate bucket ACL (private)',
          exploitability: 'high'
        });
      }
    }
  }

  private async checkCompliance(): Promise<{owasp: boolean, pci: boolean, gdpr: boolean}> {
    const criticalVulns = this.vulnerabilities.filter(v => v.severity === 'critical');
    const highVulns = this.vulnerabilities.filter(v => v.severity === 'high');

    return {
      owasp: criticalVulns.length === 0,
      pci: criticalVulns.length === 0 && highVulns.length < 3,
      gdpr: !this.vulnerabilities.some(v =>
        v.type === 'exposed_secret' ||
        v.type === 'hardcoded_credentials' ||
        v.type === 'missing_encryption'
      )
    };
  }

  private calculateRiskScore(): number {
    let score = 0;

    for (const vuln of this.vulnerabilities) {
      switch (vuln.severity) {
        case 'critical':
          score += 25;
          break;
        case 'high':
          score += 15;
          break;
        case 'medium':
          score += 5;
          break;
        case 'low':
          score += 1;
          break;
      }

      // Add exploitability factor
      if (vuln.exploitability === 'high') {
        score += 5;
      }
    }

    return Math.min(100, score);
  }

  private generateSecurityRecommendations(): string[] {
    const recommendations: string[] = [];
    const vulnTypes = new Set(this.vulnerabilities.map(v => v.type));

    // Priority recommendations based on findings
    if (this.vulnerabilities.some(v => v.type === 'exposed_secret')) {
      recommendations.push('ðŸ”´ CRITICAL: Rotate all exposed secrets immediately and implement secret scanning in CI/CD');
    }

    if (this.vulnerabilities.some(v => v.type.includes('injection'))) {
      recommendations.push('ðŸ”´ CRITICAL: Fix all injection vulnerabilities - use parameterized queries and input validation');
    }

    if (this.vulnerabilities.some(v => v.type === 'vulnerable_dependency')) {
      recommendations.push('âš ï¸ HIGH: Update vulnerable dependencies and enable automated dependency scanning');
    }

    if (!vulnTypes.has('rate_limit')) {
      recommendations.push('ðŸ’¡ Implement rate limiting on all API endpoints');
    }

    if (vulnTypes.has('weak_crypto')) {
      recommendations.push('âš ï¸ HIGH: Upgrade to modern cryptographic algorithms (AES-256, SHA-256+)');
    }

    // General recommendations
    recommendations.push('ðŸ›¡ï¸ Enable security headers (CSP, HSTS, X-Frame-Options)');
    recommendations.push('ðŸ” Implement comprehensive logging and monitoring');
    recommendations.push('ðŸ“‹ Conduct regular security audits and penetration testing');

    return recommendations;
  }

  // Helper methods
  private getAllFiles(targetPath?: string): string[] {
    const root = targetPath || this.workspaceRoot;
    const files: string[] = [];

    const walk = (dir: string) => {
      const entries = fs.readdirSync(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory() && !entry.name.includes('node_modules')) {
          walk(fullPath);
        } else if (entry.isFile()) {
          files.push(fullPath);
        }
      }
    };

    walk(root);
    return files;
  }

  private getSourceFiles(targetPath?: string): string[] {
    return this.getAllFiles(targetPath).filter(f =>
      f.endsWith('.ts') || f.endsWith('.js') ||
      f.endsWith('.tsx') || f.endsWith('.jsx')
    );
  }

  private isBinaryFile(filePath: string): boolean {
    const binaryExtensions = ['.jpg', '.png', '.gif', '.pdf', '.zip', '.exe', '.dll'];
    return binaryExtensions.some(ext => filePath.endsWith(ext));
  }

  private isFalsePositive(line: string, secretType: string): boolean {
    // Check for common false positives
    const falsePositivePatterns = [
      /example/i,
      /test/i,
      /demo/i,
      /placeholder/i,
      /your[_-]?api[_-]?key/i,
      /<.*>/,
      /\.\.\./
    ];

    return falsePositivePatterns.some(pattern => pattern.test(line));
  }

  private mapNpmSeverity(severity: string): 'critical' | 'high' | 'medium' | 'low' {
    switch (severity) {
      case 'critical': return 'critical';
      case 'high': return 'high';
      case 'moderate': return 'medium';
      default: return 'low';
    }
  }

  private getInjectionSeverity(vulnType: string): 'critical' | 'high' | 'medium' | 'low' {
    switch (vulnType) {
      case 'sql_injection':
      case 'command_injection':
      case 'eval_usage':
        return 'critical';
      case 'xss':
      case 'xxe':
      case 'ssrf':
        return 'high';
      case 'path_traversal':
        return 'medium';
      default:
        return 'low';
    }
  }

  private getInjectionRemediation(vulnType: string): string {
    const remediations: Record<string, string> = {
      'sql_injection': 'Use parameterized queries or prepared statements',
      'xss': 'Sanitize output and use Content Security Policy',
      'command_injection': 'Never pass user input directly to system commands',
      'path_traversal': 'Validate and sanitize file paths',
      'xxe': 'Disable XML external entity processing',
      'ssrf': 'Validate and whitelist URLs',
      'eval_usage': 'Never use eval() with user input',
      'insecure_random': 'Use crypto.randomBytes() for security tokens',
      'weak_crypto': 'Use strong cryptographic algorithms (AES-256, SHA-256)',
      'unsafe_deserialization': 'Validate JSON schema before parsing'
    };
    return remediations[vulnType] || 'Apply appropriate security controls';
  }
}