/**
 * Test: MCP Integration Required (No Template Fallback)
 *
 * This test verifies that tasks FAIL when MCP is unavailable,
 * instead of silently falling back to template generation.
 */

import { describe, it as test, expect } from 'vitest';
import { RealMCPClient } from '../real_mcp_client.js';

describe('MCP Integration', () => {
  test('Task fails if MCP unavailable (no template fallback)', async () => {
    const client = new RealMCPClient();

    // Attempt to use MCP without initializing (simulates connection failure)
    await expect(async () => {
      await client.executeTool('plan_next', { limit: 1 });
    }).rejects.toThrow('MCP not connected');
  });

  test('Evidence generated via MCP, not templates', async () => {
    // This test requires actual MCP connection
    // We'll verify that template markers are NOT present

    const client = new RealMCPClient();

    try {
      await client.initialize();

      // If MCP works, great
      const status = client.getStatus();
      expect(status.connected).toBe(true);

      // Test a simple tool call
      const result = await client.executeTool('plan_next', { limit: 1, minimal: true });

      // Result should be from MCP, not a template
      expect(result.success).toBe(true);

      if (result.success && result.result) {
        const resultStr = JSON.stringify(result.result);

        // Should NOT contain template markers
        expect(resultStr).not.toContain('Generated by Wave 0.1 Autonomous Runner (AFP-compliant)');
        expect(resultStr).not.toContain('Autonomous execution by Wave 0.1');
        expect(resultStr).not.toContain('Generic template');
      }

      await client.disconnect();
    } catch (error) {
      // If MCP initialization fails, that's acceptable for this test
      // The important thing is it throws an error instead of falling back to templates
      expect(error).toBeDefined();

      const errorMessage = error instanceof Error ? error.message : String(error);
      expect(errorMessage).toMatch(/MCP|connection|server/i);

      // Should NOT be a template fallback error
      expect(errorMessage).not.toContain('Using template fallback');
      expect(errorMessage).not.toContain('Generating template evidence');
    }
  });

  test('MCP client fails loudly, not silently', async () => {
    const client = new RealMCPClient();

    // Don't initialize - should throw clear error
    await expect(async () => {
      await client.read('/some/file.txt');
    }).rejects.toThrow();

    // Verify it's not connected
    expect(client.isHealthy()).toBe(false);
  });

  test('No silent fallback in RealMCPClient methods', async () => {
    const client = new RealMCPClient();

    // Test each major method throws when not connected
    await expect(client.read('/test')).rejects.toThrow();
    await expect(client.write('/test', 'content')).rejects.toThrow();
    await expect(client.bash('echo test')).rejects.toThrow();
    await expect(client.planNext()).rejects.toThrow();
    await expect(client.updateTask('TEST', 'done')).rejects.toThrow();

    // All should throw, none should return fake/template data
  });
});
