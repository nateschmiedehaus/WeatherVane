import fs from "node:fs";
import path from "node:path";
import { resolveStateRoot } from "../utils/config.js";
import type { ProofResult } from "../prove/types.js";

export type PhaseKey =
  | "strategize"
  | "spec"
  | "plan"
  | "think"
  | "design"
  | "implement"
  | "discovery"
  | "verify"
  | "review"
  | "monitor";

export type PhaseStatus = "seeded" | "pending" | "in_progress" | "done" | "blocked";

interface PhaseStateEntry {
  status: PhaseStatus;
  note?: string;
  updatedAt: string;
}

type PhaseState = Record<PhaseKey, PhaseStateEntry>;

interface SummaryUpdate {
  status: "initialized" | "in_progress" | "done" | "blocked";
  stage: "seed" | "implementation" | "proof" | "final";
  note?: string;
  proof?: ProofSummary;
  timestamp?: string;
}

interface ProofSummary {
  status: string;
  checks: {
    total: number;
    passed: number;
    failed: number;
  };
  executionMs?: number;
}

interface FinalizeOptions {
  taskTitle: string;
  finalStatus: "done" | "blocked";
  proofResult?: ProofResult | null;
  note?: string;
}

const PHASE_CONFIG: Record<
  PhaseKey,
  { filename: string; title: string; generator: (taskTitle: string, timestamp: string) => string }
> = {
  strategize: {
    filename: "strategy.md",
    title: "Strategy",
    generator: (taskTitle, timestamp) =>
      `# Strategy — ${taskTitle}

*Auto-generated by Wave 0 on ${timestamp}*

- Capture the high-level intent for this task.
- Reference upstream epic/milestone context once available.
`,
  },
  spec: {
    filename: "spec.md",
    title: "Specification",
    generator: (taskTitle, timestamp) =>
      `# Specification — ${taskTitle}

*Auto-generated by Wave 0 on ${timestamp}*

## Acceptance Criteria
- Placeholder criteria recorded automatically. Update with real requirements.

## Non-Functional Requirements
- Ensure build/test automation remains green.
`,
  },
  plan: {
    filename: "plan.md",
    title: "Plan",
    generator: (taskTitle, timestamp) =>
      `# Plan — ${taskTitle}

*Auto-generated by Wave 0 on ${timestamp}*

## Work Plan
1. Wave 0 autopilot executes the placeholder implementation step to capture repository state.
2. ProofSystem runs default build + test checks inside \`tools/wvo_mcp\`.

## Proof Criteria
- Build Verification: \`npm run build\`
- Test Verification: \`npm run test\`

## Verification Strategy
- Use ProofSystem output (\`verify.md\`) as canonical evidence.
- Review summary + review/monitor files for final notes.
`,
  },
  think: {
    filename: "think.md",
    title: "Think",
    generator: (taskTitle, timestamp) =>
      `# Think — ${taskTitle}

*Auto-generated by Wave 0 on ${timestamp}*

- Document edge cases and failure modes here.
- Update once human/agent analysis is available.
`,
  },
  design: {
    filename: "design.md",
    title: "Design",
    generator: (taskTitle, timestamp) =>
      `# Design — ${taskTitle}

*Auto-generated by Wave 0 on ${timestamp}*

Describe the approach before implementation. Replace this stub when real design work occurs.
`,
  },
  implement: {
    filename: "implement.md",
    title: "Implementation",
    generator: (taskTitle, timestamp) =>
      `# Implementation — ${taskTitle}

*Auto-generated by Wave 0 on ${timestamp}*

Wave 0 records implementation progress in this document. See appended sections for execution logs.
`,
  },
  discovery: {
    filename: "discovery.md",
    title: "Discovery",
    generator: (taskTitle, timestamp) =>
      `# Discovery — ${taskTitle}

*Auto-generated by Wave 0 on ${timestamp}*

Proof discoveries (if any) will be summarized here.
`,
  },
  verify: {
    filename: "verify.md",
    title: "Verification",
    generator: (taskTitle, timestamp) =>
      `# Verification — ${taskTitle}

*Auto-generated by Wave 0 on ${timestamp}*

Summarize final verification evidence here. ProofSystem writes \`verify.md\` for machine-readable output; use this document for human annotations.
`,
  },
  review: {
    filename: "review.md",
    title: "Review",
    generator: (taskTitle, timestamp) =>
      `# Review — ${taskTitle}

*Auto-generated by Wave 0 on ${timestamp}*

Wave 0 appends proof outcomes and reviewer notes below.
`,
  },
  monitor: {
    filename: "monitor.md",
    title: "Monitor",
    generator: (taskTitle, timestamp) =>
      `# Monitor — ${taskTitle}

*Auto-generated by Wave 0 on ${timestamp}*

Use this log to capture post-task monitoring or regressions.
`,
  },
};

const SUMMARY_FILE = "summary.md";
const PHASES_JSON = "phases.json";
const PHASES_MARKDOWN = "phases.md";
const DEFAULT_EXECUTOR = "Wave 0 Autopilot";

const PHASE_ORDER: PhaseKey[] = [
  "strategize",
  "spec",
  "plan",
  "think",
  "design",
  "implement",
  "discovery",
  "verify",
  "review",
  "monitor",
];

export class EvidenceScaffolder {
  private stateRoot: string;

  constructor(private readonly workspaceRoot: string) {
    this.stateRoot = resolveStateRoot(workspaceRoot);
  }

  seed(taskId: string, taskTitle: string): void {
    const evidenceDir = this.getEvidenceDir(taskId);
    if (!fs.existsSync(evidenceDir)) {
      fs.mkdirSync(evidenceDir, { recursive: true });
    }

    const timestamp = new Date().toISOString();

    // Seed phase files
    for (const phase of PHASE_ORDER) {
      const config = PHASE_CONFIG[phase];
      if (!config) continue;
      const filePath = path.join(evidenceDir, config.filename);
      if (!fs.existsSync(filePath)) {
        fs.writeFileSync(filePath, config.generator(taskTitle, timestamp), "utf-8");
      }
    }

    // Seed phases state
    if (!fs.existsSync(path.join(evidenceDir, PHASES_JSON))) {
      const initialState: PhaseState = {} as PhaseState;
      for (const phase of PHASE_ORDER) {
        const status: PhaseStatus = phase === "strategize" || phase === "spec" || phase === "plan" || phase === "think" || phase === "design" ? "seeded" : "pending";
        initialState[phase] = {
          status,
          note: "Auto-generated by Wave 0 scaffolder.",
          updatedAt: timestamp,
        };
      }
      this.writePhaseState(taskId, initialState);
    }

    this.renderPhasesMarkdown(taskId);

    // Seed summary
    if (!fs.existsSync(path.join(evidenceDir, SUMMARY_FILE))) {
      this.updateSummary(taskId, taskTitle, {
        status: "initialized",
        stage: "seed",
        note: "Evidence bundle initialized by Wave 0.",
        timestamp,
      });
    }
  }

  updateSummary(taskId: string, taskTitle: string, update: SummaryUpdate): void {
    const evidenceDir = this.getEvidenceDir(taskId);
    const summaryPath = path.join(evidenceDir, SUMMARY_FILE);
    const timestamp = update.timestamp ?? new Date().toISOString();
    const lines: string[] = [];

    lines.push("# Task Execution Summary");
    lines.push("");
    lines.push(`**Task ID:** ${taskId}`);
    lines.push(`**Task Title:** ${taskTitle}`);
    lines.push(`**Executed by:** ${DEFAULT_EXECUTOR}`);
    lines.push(`**Last Updated:** ${timestamp}`);
    lines.push(`**Current Status:** ${update.status.toUpperCase()}`);
    lines.push("");

    lines.push("## Overview");
    const overviewNotes = update.note ? [update.note] : [];
    if (update.proof) {
      overviewNotes.push(
        `Proof ${update.proof.status.toUpperCase()} — ${update.proof.checks.passed}/${update.proof.checks.total} checks passed.`,
      );
    }
    if (overviewNotes.length === 0) {
      overviewNotes.push("Awaiting manual updates.");
    }
    for (const note of overviewNotes) {
      lines.push(`- ${note}`);
    }
    lines.push("");

    if (update.proof) {
      lines.push("## Proof Snapshot");
      lines.push(`- Status: ${update.proof.status}`);
      lines.push(`- Checks Passed: ${update.proof.checks.passed}/${update.proof.checks.total}`);
      lines.push(`- Checks Failed: ${update.proof.checks.failed}`);
      if (update.proof.executionMs !== undefined) {
        lines.push(`- Execution Time: ${(update.proof.executionMs / 1000).toFixed(2)}s`);
      }
      lines.push("- Evidence: `verify.md`");
      lines.push("");
    }

    lines.push("## References");
    lines.push("- Strategy/Spec/Plan/Think artifacts capture upstream context.");
    lines.push("- Implementation log: `implement.md`");
    lines.push("- Review log: `review.md`");
    lines.push("- Monitoring log: `monitor.md`");
    lines.push("");

    fs.writeFileSync(summaryPath, lines.join("\n"), "utf-8");
  }

  appendImplementLog(taskId: string, entry: string): void {
    const implementPath = path.join(this.getEvidenceDir(taskId), PHASE_CONFIG.implement.filename);
    const timestamp = new Date().toISOString();
    const section = `\n## Wave 0 Execution — ${timestamp}\n- ${entry}\n`;
    fs.appendFileSync(implementPath, section, "utf-8");
  }

  writePhaseDocument(taskId: string, phase: PhaseKey, content: string): void {
    const config = PHASE_CONFIG[phase];
    if (!config) {
      return;
    }
    const filePath = path.join(this.getEvidenceDir(taskId), config.filename);
    fs.writeFileSync(filePath, content, "utf-8");
  }

  updatePhase(taskId: string, phase: PhaseKey, status: PhaseStatus, note?: string): void {
    const state = this.readPhaseState(taskId);
    if (!state[phase]) {
      state[phase] = {
        status,
        note,
        updatedAt: new Date().toISOString(),
      };
    } else {
      state[phase].status = status;
      state[phase].note = note ?? state[phase].note;
      state[phase].updatedAt = new Date().toISOString();
    }
    this.writePhaseState(taskId, state);
    this.renderPhasesMarkdown(taskId);
  }

  finalizeTask(taskId: string, options: FinalizeOptions): void {
    const proofSummary = options.proofResult ? this.summarizeProof(options.proofResult) : undefined;
    const note =
      options.finalStatus === "done"
        ? "Wave 0 autopilot completed implementation and proof checks."
        : "Wave 0 autopilot blocked pending remediation.";

    this.updateSummary(taskId, options.taskTitle, {
      status: options.finalStatus,
      stage: "final",
      note: options.note ?? note,
      proof: proofSummary,
    });

    const timestamp = new Date().toISOString();
    if (options.finalStatus === "done") {
      this.updatePhase(taskId, "discovery", "done", "Proof system reported zero discoveries.");
      this.updatePhase(taskId, "verify", "done", "Proof verified build + test checks.");
      this.updatePhase(taskId, "review", "done", "Wave 0 recorded review notes.");
      this.updatePhase(taskId, "monitor", "in_progress", "Monitoring for follow-up regressions.");
    } else {
      const blockerNote = proofSummary
        ? `Proof status: ${proofSummary.status}.`
        : "Proof system reported issues.";
      this.updatePhase(taskId, "discovery", "blocked", blockerNote);
      this.updatePhase(taskId, "verify", "blocked", "Verification blocked by failed proof.");
      this.updatePhase(taskId, "review", "pending", "Awaiting human/agent remediation.");
      this.updatePhase(taskId, "monitor", "pending", "Monitoring deferred until remediation.");
    }

    this.appendReviewEntry(taskId, {
      finalStatus: options.finalStatus,
      proofSummary,
      timestamp,
    });
    this.appendMonitorEntry(taskId, {
      finalStatus: options.finalStatus,
      proofSummary,
      timestamp,
    });
  }

  private summarizeProof(proofResult: ProofResult): ProofSummary {
    const total = proofResult.checks.length;
    const passed = proofResult.checks.filter((check) => check.success || check.skipped).length;
    const failed = proofResult.checks.filter((check) => !check.success && !check.skipped).length;
    return {
      status: proofResult.status,
      checks: {
        total,
        passed,
        failed,
      },
      executionMs: proofResult.executionTimeMs,
    };
  }

  private appendReviewEntry(
    taskId: string,
    {
      finalStatus,
      proofSummary,
      timestamp,
    }: { finalStatus: "done" | "blocked"; proofSummary?: ProofSummary; timestamp: string },
  ): void {
    const reviewPath = path.join(this.getEvidenceDir(taskId), PHASE_CONFIG.review.filename);
    const lines: string[] = [];
    lines.push(`\n## Wave 0 Review — ${timestamp}`);
    lines.push(`- Final Status: ${finalStatus.toUpperCase()}`);
    if (proofSummary) {
      lines.push(
        `- Proof Result: ${proofSummary.status.toUpperCase()} (${proofSummary.checks.passed}/${proofSummary.checks.total} checks)`,
      );
    } else {
      lines.push("- Proof Result: Not available");
    }
    fs.appendFileSync(reviewPath, lines.join("\n") + "\n", "utf-8");
  }

  private appendMonitorEntry(
    taskId: string,
    {
      finalStatus,
      proofSummary,
      timestamp,
    }: { finalStatus: "done" | "blocked"; proofSummary?: ProofSummary; timestamp: string },
  ): void {
    const monitorPath = path.join(this.getEvidenceDir(taskId), PHASE_CONFIG.monitor.filename);
    const lines: string[] = [];
    lines.push(`\n## Wave 0 Monitor — ${timestamp}`);
    lines.push(`- Final Status: ${finalStatus.toUpperCase()}`);
    if (proofSummary) {
      lines.push(`- Proof Checks: ${proofSummary.checks.passed}/${proofSummary.checks.total}`);
    }
    lines.push("- Action: Continue monitoring for regressions via subsequent Wave 0 runs.");
    fs.appendFileSync(monitorPath, lines.join("\n") + "\n", "utf-8");
  }

  private renderPhasesMarkdown(taskId: string): void {
    const evidenceDir = this.getEvidenceDir(taskId);
    const phaseState = this.readPhaseState(taskId);
    const lines: string[] = [];
    lines.push("# Phase Progress");
    lines.push("");
    lines.push("| Phase | Status | Notes |");
    lines.push("| --- | --- | --- |");
    for (const phase of PHASE_ORDER) {
      const state = phaseState[phase];
      lines.push(
        `| ${capitalizePhase(phase)} | ${state?.status ?? "pending"} | ${state?.note ?? ""} |`,
      );
    }
    fs.writeFileSync(path.join(evidenceDir, PHASES_MARKDOWN), lines.join("\n") + "\n", "utf-8");
  }

  private getEvidenceDir(taskId: string): string {
    return path.join(this.stateRoot, "evidence", taskId);
  }

  private readPhaseState(taskId: string): PhaseState {
    const filePath = path.join(this.getEvidenceDir(taskId), PHASES_JSON);
    if (!fs.existsSync(filePath)) {
      const state: PhaseState = {} as PhaseState;
      for (const phase of PHASE_ORDER) {
        state[phase] = {
          status: "pending",
          note: undefined,
          updatedAt: new Date().toISOString(),
        };
      }
      return state;
    }

    try {
      const raw = fs.readFileSync(filePath, "utf-8");
      return JSON.parse(raw) as PhaseState;
    } catch {
      const fallback: PhaseState = {} as PhaseState;
      for (const phase of PHASE_ORDER) {
        fallback[phase] = {
          status: "pending",
          note: undefined,
          updatedAt: new Date().toISOString(),
        };
      }
      return fallback;
    }
  }

  private writePhaseState(taskId: string, state: PhaseState): void {
    const filePath = path.join(this.getEvidenceDir(taskId), PHASES_JSON);
    fs.writeFileSync(filePath, JSON.stringify(state, null, 2), "utf-8");
  }
}

function capitalizePhase(phase: PhaseKey): string {
  return phase.charAt(0).toUpperCase() + phase.slice(1);
}
