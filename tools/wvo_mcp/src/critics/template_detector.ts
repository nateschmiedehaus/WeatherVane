import fs from 'node:fs';
import path from 'node:path';
import { pathToFileURL } from 'node:url';

import YAML from 'yaml';

import { resolveWorkspaceRoot } from '../utils/config.js';

const BANNED_PHRASES = [
  'lorem ipsum',
  'generated by',
  'this is a template',
  'boilerplate',
];
const DEFAULT_UNIQUE_THRESHOLD = 0.55;
const UNIQUE_THRESHOLD = Number(
  process.env.TEMPLATE_UNIQUE_MIN ?? DEFAULT_UNIQUE_THRESHOLD.toString(),
);
const TRIGRAM_THRESHOLD = Number(process.env.TEMPLATE_TRIGRAM_MAX ?? '0.15');
const DEFAULT_RELAXED_THRESHOLD = Number(
  process.env.TEMPLATE_UNIQUE_FALLBACK_MIN ?? '0.45',
);

type TemplateRelaxConfig = {
  enabled?: boolean;
  min_citations?: number;
  require_kb?: boolean;
  require_reranker_section?: boolean;
  require_drqc_citations?: boolean;
  fallback_unique_threshold?: number;
  fallback_trigram_threshold?: number;
};

type TemplateDetectorContext = {
  workspaceRoot?: string;
  stateRoot?: string;
  taskId?: string;
  frontmatter?: Record<string, unknown>;
  body?: string;
};

export type TemplateDetectorResult = {
  banned_hits: string[];
  unique_token_ratio: number;
  trigram_repetition: number;
  passes: boolean;
  mode: 'strict' | 'relaxed';
  score: number;
  reasons: string[];
  metrics: {
    banned_hits: number;
    unique_token_ratio: number;
    trigram_repetition: number;
  };
  isTemplate: boolean;
};

function tokenize(content: string): string[] {
  return content.toLowerCase().match(/[a-z0-9]+/g) ?? [];
}

function uniqueRatio(tokens: string[]): number {
  if (tokens.length === 0) {
    return 1;
  }
  const uniq = new Set(tokens);
  return uniq.size / tokens.length;
}

function trigramRepeat(tokens: string[]): number {
  if (tokens.length < 3) {
    return 0;
  }
  const counts = new Map<string, number>();
  for (let i = 0; i < tokens.length - 2; i += 1) {
    const key = `${tokens[i]} ${tokens[i + 1]} ${tokens[i + 2]}`;
    counts.set(key, (counts.get(key) ?? 0) + 1);
  }
  const repeats = Array.from(counts.values()).filter((count) => count > 1);
  const repeatedOccurrences = repeats.reduce((sum, count) => sum + count, 0);
  return repeatedOccurrences / Math.max(1, tokens.length - 2);
}

function loadDrqcConfig(workspaceRoot: string): any | null {
  try {
    const configPath = path.join(workspaceRoot, 'state', 'config', 'drqc.json');
    if (!fs.existsSync(configPath)) {
      return null;
    }
    return JSON.parse(fs.readFileSync(configPath, 'utf-8'));
  } catch {
    return null;
  }
}

function hasKbEvidence(taskId: string | undefined, stateRoot: string | undefined): boolean {
  if (!taskId || !stateRoot) {
    return false;
  }
  const kbPath = path.join(stateRoot, 'logs', taskId, 'kb', `${taskId}.json`);
  if (!fs.existsSync(kbPath)) {
    return false;
  }
  try {
    const parsed = JSON.parse(fs.readFileSync(kbPath, 'utf-8'));
    return (
      Array.isArray(parsed?.chosen) &&
      parsed.chosen.length > 0 &&
      parsed.chosen.every((entry: any) => typeof entry?.score === 'number')
    );
  } catch {
    return false;
  }
}

function shouldRelax(
  config: TemplateRelaxConfig | undefined,
  context: TemplateDetectorContext | undefined,
): { allow: boolean; uniqueThreshold: number; trigramThreshold: number } {
  if (!config || config.enabled === false || !context) {
    return { allow: false, uniqueThreshold: UNIQUE_THRESHOLD, trigramThreshold: TRIGRAM_THRESHOLD };
  }
  const citations = Array.isArray(context.frontmatter?.citations)
    ? (context.frontmatter?.citations as unknown[])
    : Array.isArray(context.frontmatter?.drqc_citations)
      ? (context.frontmatter?.drqc_citations as unknown[])
      : [];
  const drqcCitations = Array.isArray(context.frontmatter?.drqc_citations)
    ? (context.frontmatter?.drqc_citations as unknown[])
    : [];
  const hasRerankerSection =
    typeof context.body === 'string' && /##\s+Reranker Evidence/i.test(context.body);
  const meetsCitations = citations.length >= (config.min_citations ?? 3);
  const meetsDrqc = !config.require_drqc_citations || drqcCitations.length > 0;
  const meetsKb = !config.require_kb || hasKbEvidence(context.taskId, context.stateRoot);
  const meetsSection = !config.require_reranker_section || hasRerankerSection;
  if (meetsCitations && meetsDrqc && meetsKb && meetsSection) {
    const fallback =
      config.fallback_unique_threshold ??
      Number(process.env.TEMPLATE_UNIQUE_FALLBACK_MIN ?? DEFAULT_RELAXED_THRESHOLD);
    const trigramFallback =
      config.fallback_trigram_threshold ??
      Number(process.env.TEMPLATE_TRIGRAM_FALLBACK_MAX ?? TRIGRAM_THRESHOLD);
    return { allow: true, uniqueThreshold: fallback, trigramThreshold: trigramFallback };
  }
  return { allow: false, uniqueThreshold: UNIQUE_THRESHOLD, trigramThreshold: TRIGRAM_THRESHOLD };
}

export function analyzeTemplate(
  content: string,
  context?: TemplateDetectorContext,
): TemplateDetectorResult {
  const parsed = parseFrontmatter(content);
  const effectiveBody = context?.body ?? parsed.body;
  const effectiveFrontmatter = context?.frontmatter ?? parsed.frontmatter;
  const lowered = effectiveBody.toLowerCase();
  const banned_hits = BANNED_PHRASES.filter((phrase) => lowered.includes(phrase));
  const tokens = tokenize(effectiveBody);
  const unique_token_ratio = uniqueRatio(tokens);
  const trigram_repetition = trigramRepeat(tokens);
  const workspaceRoot = context?.workspaceRoot ?? resolveWorkspaceRoot();
  const drqcConfig = loadDrqcConfig(workspaceRoot);
  const relaxation = shouldRelax(drqcConfig?.template_detector?.relaxed_when, {
    ...context,
    frontmatter: effectiveFrontmatter,
    body: effectiveBody,
  });
  const strictPass =
    banned_hits.length === 0 &&
    unique_token_ratio >= UNIQUE_THRESHOLD &&
    trigram_repetition <= TRIGRAM_THRESHOLD;
  let passes = strictPass;
  let mode: 'strict' | 'relaxed' = 'strict';
  if (!passes && relaxation.allow) {
    passes =
      banned_hits.length === 0 &&
      unique_token_ratio >= relaxation.uniqueThreshold &&
      trigram_repetition <= relaxation.trigramThreshold;
    if (passes) {
      mode = 'relaxed';
    }
  }
  const reasons: string[] = [];
  if (banned_hits.length > 0) {
    reasons.push(`banned phrases detected: ${banned_hits.join(', ')}`);
  }
  if (unique_token_ratio < UNIQUE_THRESHOLD) {
    reasons.push(`unique_token_ratio ${unique_token_ratio.toFixed(3)} below ${UNIQUE_THRESHOLD}`);
  }
  if (trigram_repetition > TRIGRAM_THRESHOLD) {
    reasons.push(`trigram_repetition ${trigram_repetition.toFixed(3)} above ${TRIGRAM_THRESHOLD}`);
  }
  const score = Number(Math.max(0, 1 - reasons.length * 0.25).toFixed(4));
  return {
    banned_hits,
    unique_token_ratio,
    trigram_repetition,
    passes,
    mode,
    score,
    reasons,
    metrics: {
      banned_hits: banned_hits.length,
      unique_token_ratio,
      trigram_repetition,
    },
    isTemplate: !passes,
  };
}

export function detectTemplate(
  content: string,
  taskId?: string,
  phase?: string,
  overrides?: Partial<TemplateDetectorContext>,
): TemplateDetectorResult {
  const workspaceRoot = overrides?.workspaceRoot ?? resolveWorkspaceRoot();
  const stateRoot =
    overrides?.stateRoot ??
    (process.env.WVO_STATE_ROOT && process.env.WVO_STATE_ROOT.trim().length > 0
      ? path.resolve(process.env.WVO_STATE_ROOT)
      : path.join(workspaceRoot, 'state'));
  return analyzeTemplate(content, {
    workspaceRoot,
    stateRoot,
    taskId,
    frontmatter: overrides?.frontmatter,
    body: overrides?.body,
  });
}

export function writeTemplateResult(
  taskId: string,
  result: TemplateDetectorResult,
  stateRoot: string,
): string {
  const dir = path.join(stateRoot, 'logs', taskId, 'critics');
  fs.mkdirSync(dir, { recursive: true });
  const target = path.join(dir, 'template_detector.json');
  fs.writeFileSync(target, JSON.stringify({ ...result, generated_at: new Date().toISOString() }, null, 2));
  return target;
}

function parseFrontmatter(
  raw: string,
): { frontmatter?: Record<string, unknown>; body: string } {
  const match = raw.match(/^---\s*\n([\s\S]+?)\n---\s*\n([\s\S]*)$/m);
  if (!match) {
    return { body: raw };
  }
  const frontmatter = YAML.parse(match[1]) ?? {};
  const [, , body] = match;
  return { frontmatter, body };
}

function cli(): void {
  const [, , ...args] = process.argv;
  const fileIndex = args.indexOf('--file');
  const taskIndex = args.indexOf('--task');
  if (fileIndex === -1 || !args[fileIndex + 1]) {
    console.error('Usage: node template_detector.js --file <path> [--task TASK-ID]');
    process.exit(1);
  }
  const filePath = args[fileIndex + 1];
  const taskId = taskIndex !== -1 ? args[taskIndex + 1] : 'ADHOC';
  const raw = fs.readFileSync(filePath, 'utf-8');
  const stateRoot = process.env.WVO_STATE_ROOT ?? path.join(process.cwd(), 'state');
  const workspaceRoot = resolveWorkspaceRoot();
  const result = analyzeTemplate(raw, {
    workspaceRoot,
    stateRoot,
    taskId,
  });
  const outputPath = writeTemplateResult(taskId, result, stateRoot);
  console.log(`Template detector report written to ${outputPath} (${result.mode})`);
  if (!result.passes) {
    process.exit(2);
  }
}

if (process.argv[1] && pathToFileURL(process.argv[1]).href === import.meta.url) {
  cli();
}
