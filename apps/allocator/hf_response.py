"""
High-frequency (intraday) spend-response modelling for the allocator.

The module builds an intraday scenario by expanding each marketing channel into
hourly "micro-cells".  It reuses the existing allocator heuristics to solve the
resulting optimisation problem, then aggregates the schedule back into per-hour
and per-channel summaries.  The goal is to support intraday budget nudges while
respecting ROAS floors and hourly caps.
"""
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Mapping, Sequence, Tuple

import json
import math

from apps.allocator.heuristics import AllocationInput, AllocationResult, Guardrails, allocate


HOURS_PER_DAY = 24


@dataclass(frozen=True)
class IntradayChannel:
    """Static parameters describing a channel's short-horizon response."""

    name: str
    peak_roas: float
    saturation_spend: float
    diminishing: float
    max_hourly_spend: float
    min_hourly_spend: float = 0.0


@dataclass(frozen=True)
class IntradayScenario:
    """Configuration required to run an intraday allocation simulation."""

    channels: Sequence[IntradayChannel]
    demand_profile: Mapping[str, Sequence[float]]
    total_budget: float
    roas_floor: float = 1.1

    def validate(self) -> None:
        if self.total_budget <= 0:
            raise ValueError("total_budget must be positive")
        if not self.channels:
            raise ValueError("scenario must include at least one channel")
        for channel in self.channels:
            profile = self.demand_profile.get(channel.name)
            if profile is None:
                raise ValueError(f"missing demand profile for channel '{channel.name}'")
            if len(profile) != HOURS_PER_DAY:
                raise ValueError(
                    f"demand profile for '{channel.name}' must contain {HOURS_PER_DAY} entries"
                )
            if channel.max_hourly_spend <= 0:
                raise ValueError(f"max_hourly_spend must be positive for '{channel.name}'")
            if channel.saturation_spend <= 0:
                raise ValueError(f"saturation_spend must be positive for '{channel.name}'")
            if channel.peak_roas <= 0:
                raise ValueError(f"peak_roas must be positive for '{channel.name}'")


def _effective_roas(channel: IntradayChannel, spend: float, demand_multiplier: float) -> float:
    """Compute the instantaneous ROAS at the given spend level."""
    if spend <= 0:
        return 0.0
    multiplier = max(demand_multiplier, 0.05)
    adjusted_peak = channel.peak_roas * multiplier
    denominator = 1.0 + (spend / channel.saturation_spend) ** max(channel.diminishing, 1e-6)
    return adjusted_peak / denominator


def _hourly_revenue(channel: IntradayChannel, spend: float, demand_multiplier: float) -> float:
    """Return revenue generated by spending `spend` during the hour."""
    roas = _effective_roas(channel, spend, demand_multiplier)
    return roas * spend


def _spend_grid(max_spend: float) -> List[float]:
    """Generate a monotonic grid of spend values for ROI curve sampling."""
    if max_spend <= 0:
        return [0.0]
    step = max_spend / 4.0
    return [round(x, 4) for x in (0.0, step, 2 * step, 3 * step, max_spend)]


def _build_allocation_input(
    scenario: IntradayScenario,
    *,
    seed: int = 42,
) -> Tuple[AllocationInput, Dict[str, Tuple[IntradayChannel, int, float]]]:
    """Expand an intraday scenario into an AllocationInput for the core allocator."""
    scenario.validate()

    cells: List[str] = []
    roi_curves: Dict[str, List[Dict[str, float]]] = {}
    expected_roas: Dict[str, float] = {}
    current_spend: Dict[str, float] = {}
    min_by_cell: Dict[str, float] = {}
    max_by_cell: Dict[str, float] = {}
    cell_meta: Dict[str, Tuple[IntradayChannel, int, float]] = {}

    hours = HOURS_PER_DAY
    baseline_cell_budget = scenario.total_budget / (len(scenario.channels) * hours)

    for channel in scenario.channels:
        demand = scenario.demand_profile[channel.name]
        for hour in range(hours):
            multiplier = demand[hour]
            cell_id = f"{channel.name}_h{hour:02d}"
            cells.append(cell_id)
            hourly_cap = channel.max_hourly_spend * max(multiplier, 0.25)
            spend_grid = _spend_grid(hourly_cap)
            roi_curve: List[Dict[str, float]] = []
            for spend in spend_grid:
                roi_curve.append(
                    {"spend": spend, "revenue": _hourly_revenue(channel, spend, multiplier)}
                )
            roi_curves[cell_id] = roi_curve
            probe_spend = max(spend_grid[1], 1e-3) if len(spend_grid) > 1 else hourly_cap
            expected_roas[cell_id] = _effective_roas(channel, probe_spend, multiplier)
            baseline = min(
                hourly_cap,
                max(channel.min_hourly_spend, baseline_cell_budget * multiplier),
            )
            current_spend[cell_id] = baseline
            min_by_cell[cell_id] = channel.min_hourly_spend
            max_by_cell[cell_id] = hourly_cap
            cell_meta[cell_id] = (channel, hour, multiplier)

    guardrails = Guardrails(
        min_spend=0.0,
        max_spend=scenario.total_budget,  # per-cell guardrails enforce tighter caps
        roas_floor=scenario.roas_floor,
        learning_cap=0.35,
        min_spend_by_cell=min_by_cell,
        max_spend_by_cell=max_by_cell,
    )

    allocation_input = AllocationInput(
        cells=cells,
        total_budget=scenario.total_budget,
        current_spend=current_spend,
        expected_roas=expected_roas,
        roi_curves=roi_curves,
        guardrails=guardrails,
        context_tags=["intraday"],
        quantile_factors={"p10": 0.8, "p50": 1.0, "p90": 1.25},
        risk_aversion=0.25,
    )

    allocation_input.context_tags.append(f"seed.{seed}")
    return allocation_input, cell_meta


def optimise_intraday_schedule(
    scenario: IntradayScenario,
    *,
    seed: int = 42,
) -> Tuple[AllocationResult, Dict[str, Tuple[IntradayChannel, int, float]]]:
    """Solve the intraday allocation problem using the existing allocator."""
    allocation_input, cell_meta = _build_allocation_input(scenario, seed=seed)
    result = allocate(allocation_input, seed=seed)
    return result, cell_meta


def _initialise_hourly_matrix(channels: Iterable[str]) -> List[Dict[str, float]]:
    return [{channel: 0.0 for channel in channels} for _ in range(HOURS_PER_DAY)]


def summarise_intraday_result(
    result: AllocationResult,
    scenario: IntradayScenario,
    cell_meta: Mapping[str, Tuple[IntradayChannel, int, float]],
) -> Dict[str, object]:
    """Aggregate allocator output into per-channel/hour summaries."""
    total_spend = sum(result.spends.values())
    per_channel: Dict[str, Dict[str, float]] = {
        channel.name: {"spend": 0.0, "revenue": 0.0} for channel in scenario.channels
    }
    per_hour = _initialise_hourly_matrix(per_channel.keys())
    revenue_hour = _initialise_hourly_matrix(per_channel.keys())

    for cell_id, spend in result.spends.items():
        channel, hour, multiplier = cell_meta[cell_id]
        revenue = _hourly_revenue(channel, spend, multiplier)
        per_channel[channel.name]["spend"] += spend
        per_channel[channel.name]["revenue"] += revenue
        per_hour[hour][channel.name] += spend
        revenue_hour[hour][channel.name] += revenue

    channel_summaries: List[Dict[str, float]] = []
    total_revenue = 0.0
    for channel in scenario.channels:
        summary = per_channel[channel.name]
        spend = summary["spend"]
        revenue = summary["revenue"]
        total_revenue += revenue
        avg_roas = revenue / spend if spend > 0 else 0.0
        channel_summaries.append(
            {
                "channel": channel.name,
                "total_spend": round(spend, 2),
                "total_revenue": round(revenue, 2),
                "average_roas": round(avg_roas, 3),
                "peak_roas": channel.peak_roas,
                "saturation_spend": channel.saturation_spend,
                "max_hourly_spend": channel.max_hourly_spend,
            }
        )

    timeline: List[Dict[str, object]] = []
    for hour in range(HOURS_PER_DAY):
        spend_row = {ch: round(value, 2) for ch, value in per_hour[hour].items()}
        revenue_row = {ch: round(value, 2) for ch, value in revenue_hour[hour].items()}
        timeline.append(
            {
                "hour": hour,
                "spend": spend_row,
                "revenue": revenue_row,
                "roi": {
                    ch: round(revenue_row[ch] / spend_row[ch], 3) if spend_row[ch] > 0 else 0.0
                    for ch in spend_row
                },
            }
        )

    profit = total_revenue - total_spend
    average_roas = total_revenue / total_spend if total_spend > 0 else 0.0
    diagnostics = dict(result.diagnostics)
    diagnostics.setdefault("optimizer", diagnostics.get("optimizer_winner", "unknown"))

    return {
        "budget": round(total_spend, 2),
        "total_revenue": round(total_revenue, 2),
        "profit": round(profit, 2),
        "average_roas": round(average_roas, 3),
        "roas_floor": scenario.roas_floor,
        "channels": channel_summaries,
        "timeline": timeline,
        "optimizer_diagnostics": diagnostics,
    }


def _gaussian_profile(peak_hour: float, width: float, *, base: float, amplitude: float) -> List[float]:
    values: List[float] = []
    for hour in range(HOURS_PER_DAY):
        exponent = -((hour - peak_hour) ** 2) / (2 * width ** 2)
        values.append(base + amplitude * math.exp(exponent))
    return values


def _blend_profiles(profiles: Sequence[Sequence[float]]) -> List[float]:
    combined = [0.0] * HOURS_PER_DAY
    for profile in profiles:
        if len(profile) != HOURS_PER_DAY:
            raise ValueError("profile length mismatch during blending")
        for hour, value in enumerate(profile):
            combined[hour] += value
    return combined


def _normalise_profile(values: Sequence[float]) -> List[float]:
    mean = sum(values) / len(values)
    if mean <= 0:
        return [1.0 for _ in values]
    return [value / mean for value in values]


def default_intraday_scenario() -> IntradayScenario:
    """Provide a canonical scenario for tests and the published experiment."""
    channels = [
        IntradayChannel(
            name="meta",
            peak_roas=3.2,
            saturation_spend=420.0,
            diminishing=1.6,
            max_hourly_spend=220.0,
            min_hourly_spend=12.0,
        ),
        IntradayChannel(
            name="search",
            peak_roas=2.4,
            saturation_spend=360.0,
            diminishing=1.4,
            max_hourly_spend=190.0,
            min_hourly_spend=8.0,
        ),
        IntradayChannel(
            name="display",
            peak_roas=1.8,
            saturation_spend=240.0,
            diminishing=1.3,
            max_hourly_spend=140.0,
            min_hourly_spend=5.0,
        ),
    ]

    demand_profile: Dict[str, Sequence[float]] = {
        "meta": _normalise_profile(
            _blend_profiles(
                [
                    _gaussian_profile(10.0, 2.8, base=0.25, amplitude=0.55),
                    _gaussian_profile(19.5, 3.0, base=0.0, amplitude=0.4),
                ]
            )
        ),
        "search": _normalise_profile(
            _blend_profiles(
                [
                    _gaussian_profile(9.0, 2.2, base=0.35, amplitude=0.5),
                    _gaussian_profile(14.0, 3.0, base=0.0, amplitude=0.25),
                ]
            )
        ),
        "display": _normalise_profile(
            _blend_profiles(
                [
                    _gaussian_profile(12.0, 4.0, base=0.4, amplitude=0.3),
                    _gaussian_profile(21.0, 2.6, base=0.0, amplitude=0.35),
                ]
            )
        ),
    }

    return IntradayScenario(
        channels=channels,
        demand_profile=demand_profile,
        total_budget=7200.0,
        roas_floor=1.15,
    )


def generate_intraday_report(
    scenario: IntradayScenario | None = None,
    *,
    seed: int = 42,
) -> Dict[str, object]:
    """Run the simulation and attach scenario metadata for persistence."""
    scenario = scenario or default_intraday_scenario()
    allocation, cell_meta = optimise_intraday_schedule(scenario, seed=seed)
    summary = summarise_intraday_result(allocation, scenario, cell_meta)
    summary["scenario"] = {
        "total_budget": scenario.total_budget,
        "roas_floor": scenario.roas_floor,
        "channels": [
            {
                "name": channel.name,
                "peak_roas": channel.peak_roas,
                "saturation_spend": channel.saturation_spend,
                "diminishing": channel.diminishing,
                "max_hourly_spend": channel.max_hourly_spend,
                "min_hourly_spend": channel.min_hourly_spend,
            }
            for channel in scenario.channels
        ],
        "demand_profile": {
            channel: [round(value, 3) for value in multipliers]
            for channel, multipliers in scenario.demand_profile.items()
        },
    }
    return summary


def write_intraday_report(path: str | Path, scenario: IntradayScenario | None = None) -> Dict[str, object]:
    """Generate and persist the intraday report as JSON."""
    report = generate_intraday_report(scenario=scenario)
    output_path = Path(path)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(json.dumps(report, indent=2))
    return report


def main() -> None:
    """CLI entry-point to regenerate the published experiment artifact."""
    write_intraday_report(Path("experiments/allocator/hf_response.json"))


if __name__ == "__main__":
    main()
