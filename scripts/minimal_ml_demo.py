from __future__ import annotations

import argparse
import json
import os
from datetime import datetime, timedelta
from pathlib import Path

from apps.allocator.marketing_mix import (
    ChannelConstraint,
    MarketingMixScenario,
    solve_marketing_mix,
)
from apps.model.mmm import MMMModel
from apps.model.train import train_baseline
from shared.libs.testing.synthetic import WeatherShock, seed_synthetic_tenant


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Run a lightweight ML demo pipeline.")
    parser.add_argument("--tenant", default="demo-ml-tenant", help="Synthetic tenant identifier.")
    scope_group = parser.add_mutually_exclusive_group()
    scope_group.add_argument(
        "--days",
        type=int,
        default=None,
        help="Number of synthetic history days to seed (min 7 recommended).",
    )
    scope_group.add_argument(
        "--years",
        type=float,
        default=None,
        help="History window in years (converted to days; overrides --days).",
    )
    parser.add_argument(
        "--output",
        default="tmp/demo_ml",
        help="Directory where synthetic lake + artifacts will be written.",
    )
    parser.add_argument(
        "--seed-weather-shock",
        action="store_true",
        help="Inject a small weather shock to highlight weather sensitivity.",
    )
    parser.add_argument(
        "--plan",
        type=str,
        default=None,
        help="Optional JSON plan generated by plan_brand_demo.py to auto-configure scope.",
    )
    parser.add_argument(
        "--geo",
        nargs=2,
        type=float,
        metavar=("LAT", "LON"),
        default=None,
        help="Optional single geo (latitude longitude) to seed data for.",
    )
    parser.add_argument(
        "--product",
        default="demo-product",
        help="Identifier for the demo product focus (for reporting only).",
    )
    parser.add_argument(
        "--category",
        default="demo-category",
        help="Friendly category name for reporting.",
    )
    return parser.parse_args()


def _prepare_environment() -> None:
    # Ensure optional heavy dependencies stay disabled for demo runs.
    os.environ.setdefault("WEATHERVANE_ENABLE_SCIPY", "0")
    os.environ.setdefault("PYGAM_DISABLE", "1")
    os.environ.setdefault("WEATHERVANE_DISABLE_EXPERIMENTS_ROUTES", "1")


def _seed_data(
    lake_root: Path,
    tenant: str,
    days: int,
    weather_shock: bool,
    geos: list[tuple[float, float]] | None,
) -> None:
    shocks = [WeatherShock(start_day=2, end_day=4, temp_delta=6.0, rain_mm=10.0)] if weather_shock else []
    seed_synthetic_tenant(lake_root, tenant, days=days, geos=geos, shocks=shocks)


def _train_baseline(
    tenant: str,
    lake_root: Path,
    output_root: Path,
    days: int,
) -> dict[str, object]:
    end = datetime(2024, 1, 7)
    start = end - timedelta(days=days - 1)
    result = train_baseline(
        tenant_id=tenant,
        start=start,
        end=end,
        lake_root=lake_root,
        output_root=output_root,
        feature_min_rows=min(days, 14),
    )
    return {
        "model_path": str(result.model_path),
        "metadata_path": str(result.metadata_path),
        "observed_rows": result.metadata["data"]["observed_rows"],
        "features": result.metadata["features"],
        "train_r2": result.metadata["training"]["r2"],
        "holdout_r2": result.metadata["holdout"]["r2"],
    }


def _marketing_mix_demo(seed: int = 21) -> dict[str, object]:
    mmm = MMMModel(
        base_roas=1.75,
        elasticity={"meta": 0.32, "search": -0.15, "display": 0.08},
        mean_roas={"meta": 2.2, "search": 1.6, "display": 1.4},
        mean_spend={"meta": 95.0, "search": 105.0, "display": 45.0},
        features=["meta", "search", "display"],
    )
    channels = [
        ChannelConstraint(
            name="meta",
            current_spend=90.0,
            min_spend=60.0,
            max_spend=140.0,
            weather_multiplier=1.2,
            commentary="Weather uplift boosts paid social during storms.",
        ),
        ChannelConstraint(
            name="search",
            current_spend=85.0,
            min_spend=50.0,
            max_spend=130.0,
            weather_multiplier=0.9,
            commentary="Search dampens slightly when store traffic slows.",
        ),
        ChannelConstraint(
            name="display",
            current_spend=40.0,
            min_spend=20.0,
            max_spend=80.0,
            weather_multiplier=1.05,
            commentary="Storytelling inventory used to reinforce weather messaging.",
        ),
    ]
    total_budget = sum(channel.current_spend for channel in channels)
    scenario = MarketingMixScenario(
        mmm_model=mmm,
        channels=channels,
        total_budget=total_budget,
        roas_floor=1.1,
        learning_cap=0.25,
        risk_aversion=0.2,
        quantile_factors={"p10": 0.85, "p50": 1.0, "p90": 1.15},
        context_tags=("demo",),
    )
    result = solve_marketing_mix(scenario, seed=seed)
    summary = []
    for rec in result.recommendations.values():
        summary.append(
            {
                "channel": rec.name,
                "spend": round(rec.recommended_spend, 2),
                "avg_roas": round(rec.average_roas, 3),
                "marginal_roas": round(rec.marginal_roas, 3),
            }
        )
    return {
        "total_revenue": round(result.total_revenue, 2),
        "profit": round(result.profit, 2),
        "recommendations": summary,
        "diagnostics": result.diagnostics,
    }


def main() -> None:
    args = _parse_args()
    _prepare_environment()

    days = args.days
    product_label = args.product
    category_label = args.category
    plan_geo = args.geo

    if args.plan:
        plan_path = Path(args.plan)
        if not plan_path.exists():
            raise FileNotFoundError(f"Plan file not found: {plan_path}")
        plan = json.loads(plan_path.read_text(encoding="utf-8"))
        days = plan.get("recommended_history_days", days)
        product_label = plan.get("recommended_product", product_label)
        category_label = plan.get("recommended_category", category_label)
        if not args.geo:
            geo_info = plan.get("top_geo") or {}
            lat = geo_info.get("latitude")
            lon = geo_info.get("longitude")
            if lat is not None and lon is not None:
                plan_geo = (float(lat), float(lon))
        plan_notes = plan.get("notes")
        if plan_notes:
            print("ðŸ“‹ Demo plan notes:")
            for note in plan_notes:
                print(f"   - {note}")

    if args.years is not None:
        days = max(int(args.years * 365), 7)
    if days is None:
        days = 14

    output_root = Path(args.output).resolve()
    lake_root = output_root / "lake"
    model_root = output_root / "models"
    lake_root.mkdir(parents=True, exist_ok=True)
    model_root.mkdir(parents=True, exist_ok=True)

    geo_list = [(37.7749, -122.4194)]
    if plan_geo:
        lat, lon = plan_geo
        geo_list = [(lat, lon)]

    _seed_data(lake_root, args.tenant, days, args.seed_weather_shock, geo_list)
    baseline_info = _train_baseline(args.tenant, lake_root, model_root, days)
    mix_info = _marketing_mix_demo()

    print("âœ… Minimal ML demo pipeline complete")
    print(f"   Synthetic lake data: {lake_root}")
    print(f"   Demo scope: product={product_label} category={category_label} tenant={args.tenant}")
    if plan_geo:
        print(f"   Geo focus: lat={plan_geo[0]:.4f}, lon={plan_geo[1]:.4f}")
    window_years = days / 365.0
    print(f"   History window: {days} days (~{window_years:.2f} years)")
    print(f"   Baseline model:     {baseline_info['model_path']}")
    print(f"   Metadata:           {baseline_info['metadata_path']}")
    print(f"   Observations:       {baseline_info['observed_rows']} rows, features={len(baseline_info['features'])}")
    print(f"   RÂ² (train/holdout): {baseline_info['train_r2']:.3f} / {baseline_info['holdout_r2']:.3f}")
    print("")
    print("ðŸ“Š Marketing mix recommendation (synthetic MMM demo)")
    for rec in mix_info["recommendations"]:
        print(
            f"   - {rec['channel']:<7} spend={rec['spend']:>6.2f} avg_roas={rec['avg_roas']:.3f} "
            f"marginal={rec['marginal_roas']:.3f}"
        )
    print(f"   Total revenue: {mix_info['total_revenue']:.2f} | Profit: {mix_info['profit']:.2f}")
    print("")
    print("Use `pytest tests/model/test_model_pipeline.py::test_model_pipeline` for an automated regression of this flow.")


if __name__ == "__main__":
    main()
