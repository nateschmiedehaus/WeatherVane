# STRATEGIZE - Wave 0 Self-Improvement Test

**Task ID:** AFP-W0-SELF-IMPROVEMENT-TEST-20251106
**Date:** 2025-11-06
**Objective:** Build a fully functional Wave 0 that matches manual mode capabilities

## Problem Analysis

### Current State (Wave 0.0)
Wave 0 is mechanically functional but produces **zero value**:
- Generates placeholder content ("Auto-generated by Wave 0")
- No real tool execution (fake MCP calls)
- No provider switching (hardcoded to one)
- No actual code generation
- No real testing or verification
- Pure compliance theater

### Root Cause
1. **MCPClient is a stub** - doesn't actually execute tools, just returns fake success
2. **No provider integration** - can't switch between Claude/Codex
3. **No task type awareness** - treats all tasks identically
4. **No content generation** - just templates with timestamps

## Goal

Create Wave 0.1 that:
1. **Executes real MCP tools** - file operations, builds, tests
2. **Switches providers intelligently** - Claude for reasoning, Codex for coding
3. **Generates real content** - actual code, tests, documentation
4. **Self-tests improvements** - can modify itself safely
5. **Matches manual mode** - full feature parity

## Success Criteria

1. Wave 0 can complete a real coding task with:
   - Actual file changes that compile
   - Tests that pass
   - Documentation that explains the change

2. Wave 0 can improve itself:
   - Clone itself for testing
   - Test improvements in isolation
   - Apply validated changes to production

3. Observable evidence:
   - Git commits with real changes
   - Build logs showing compilation
   - Test results showing coverage
   - Provider switching in telemetry

## AFP/SCAS Alignment

### Via Negativa (What to Delete)
- Remove ALL placeholder generation code
- Delete fake MCP responses
- Remove hardcoded provider selection
- Delete template-only content generation

### Refactor Not Repair
Instead of patching Wave 0.0, we'll:
1. Refactor MCPClient to use real MCP server connection
2. Refactor TaskExecutor to handle provider switching
3. Refactor PhaseExecutors to generate real content
4. Refactor runner to support self-testing

### Simplicity Score: 8/10
- Clear separation: runner → executor → phases → tools
- Each component has single responsibility
- No complex state management needed

## Strategic Approach

### Phase 1: Real Tool Execution
- Connect to actual MCP server (not stub)
- Execute real file operations
- Get actual command outputs

### Phase 2: Provider Intelligence
- Detect task complexity
- Route to appropriate provider
- Handle provider failures/limits

### Phase 3: Content Generation
- Use LLMs to generate real code
- Create actual tests
- Write meaningful documentation

### Phase 4: Self-Testing
- Clone process with new PID
- Test changes in isolation
- Validate before production rollout

## Risk Assessment

1. **MCP Server Connection** - May fail if server not running
   - Mitigation: Auto-start MCP server if needed

2. **Provider Rate Limits** - May hit token/request limits
   - Mitigation: Implement backoff and provider switching

3. **Self-Modification** - Could break production Wave 0
   - Mitigation: Always test in cloned instance first

## Next Steps
Proceed to SPEC phase to define detailed requirements for each component.