[
  {
    "query_task": {
      "task_id": "IMP-API-01",
      "title": "Add GET /api/v1/users endpoint with cursor-based pagination",
      "description": "Implement REST API endpoint for listing users with cursor-based pagination (not offset/limit).\n\nTechnical requirements:\n- Endpoint: GET /api/v1/users?cursor=<id>&limit=50\n- Return fields: id, email, display_name, created_at, role\n- Default limit: 50, max limit: 100\n- Sort by: id ASC (stable ordering for cursor)\n- Response includes next_cursor for pagination\n- Filter support: ?role=admin,user&status=active\n- Return 400 for invalid cursor, 401 for unauthenticated\n\nImplementation approach:\n- Use Prisma ORM with cursor pagination\n- Add index on (id, created_at) for performance\n- Implement CursorPaginationDTO with Zod validation\n- Unit tests: pagination, filtering, edge cases (empty result, last page)\n- OpenAPI spec in docs/api.yaml\n\nAcceptance criteria:\n- Paginate through 10,000 users in <2s total\n- No duplicate users across pages\n- Works with concurrent updates (stable cursor)",
      "files_touched": [
        "src/api/users/list.ts",
        "src/api/users/list.test.ts",
        "src/dto/pagination.ts",
        "docs/api.yaml"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "CRIT-UI-01",
        "title": "Fix React form losing data on validation error (state management bug)",
        "description": "Contact form clears all fields when server returns validation error, losing user's work.\n\nBug details:\n- User fills out 10-field contact form (takes 5 minutes)\n- Submit fails with \"Email already registered\" error\n- Form state resets to empty, all data lost\n- Users complaining: \"I had to re-enter everything!\"\n\nRoot cause:\n- Form component calls setFormData({}) on any error response\n- Should preserve form data, only show error message\n- Current code: `onError: () => setFormData(initialFormData)` \u274c\n\nFix approach:\n1. Remove setFormData({}) from error handler\n2. Add auto-save to localStorage every 2 seconds:\n   - Key: `form_draft_contact_${Date.now()}`\n   - Value: JSON.stringify(formData)\n   - Clear localStorage on successful submit\n3. On page load: Restore draft if present (show \"Restore previous draft?\" prompt)\n4. Show inline field errors (don't clear valid fields):\n   - Server returns: {errors: {email: \"Already registered\", phone: \"Invalid format\"}}\n   - Only highlight email and phone fields, preserve other data\n\nAdditional improvements:\n- Add \"Save draft\" button (manual save to localStorage)\n- Show \"*Unsaved changes\" indicator\n- Warn before leaving page: beforeunload event if form has data\n\nTests:\n- Submit with validation error preserves form data\n- Auto-save writes to localStorage every 2s\n- Draft restored on page reload\n- Draft cleared after successful submit\n- beforeunload warns when form has unsaved data",
        "files_touched": [
          "src/components/ContactForm.tsx",
          "src/hooks/useFormPersistence.ts",
          "src/components/ContactForm.test.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5294810619785162,
        "is_confident": true
      },
      {
        "task_id": "IMP-UI-02",
        "title": "Implement dark mode with CSS custom properties and system preference detection",
        "description": "Add dark/light theme support with smooth transitions and persistent preference.\n\nTheme implementation:\n- CSS custom properties in :root for colors:\n  ```css\n  :root {\n    --bg-primary: #ffffff;\n    --text-primary: #000000;\n    --border: #e0e0e0;\n  }\n  :root[data-theme=\"dark\"] {\n    --bg-primary: #121212;\n    --text-primary: #ffffff;\n    --border: #333333;\n  }\n  ```\n- All components use: background-color: var(--bg-primary)\n- Smooth transition: transition: background-color 0.3s, color 0.3s\n\nUser preference flow:\n1. On first visit: Detect system preference (prefers-color-scheme: dark)\n2. User toggles theme: Save to localStorage (theme: \"dark\" | \"light\" | \"auto\")\n3. On subsequent visits: Load from localStorage, fall back to system preference\n\nTheme toggle UI:\n- Header button with icon (sun/moon)\n- Three states: Light, Dark, Auto (follows system)\n- Tooltip: \"Light mode\", \"Dark mode\", \"Auto (currently dark)\"\n- Smooth icon transition (fade + rotate)\n\nEdge cases:\n- System preference changes while app open \u2192 update if user has \"auto\"\n- Multiple tabs \u2192 sync theme across tabs (localStorage change event)\n- Print mode \u2192 force light theme (CSS: @media print)\n\nTests:\n- Toggle changes theme immediately\n- Theme persists after page reload\n- System preference respected when \"auto\"\n- All components render correctly in both themes",
        "files_touched": [
          "src/theme/ThemeProvider.tsx",
          "src/theme/theme.css",
          "src/components/ThemeToggle.tsx",
          "src/hooks/useTheme.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5244419895249567,
        "is_confident": true
      },
      {
        "task_id": "IMP-DB-01",
        "title": "Add Postgres migration for user_preferences JSONB column",
        "description": "Create migration to add user preferences as flexible JSONB column.\n\nSchema change:\n- Table: users\n- New column: preferences JSONB DEFAULT '{}'::jsonb NOT NULL\n- Add GIN index: CREATE INDEX idx_users_preferences_gin ON users USING GIN (preferences)\n- Example data: {\"theme\": \"dark\", \"language\": \"en-US\", \"timezone\": \"America/Los_Angeles\", \"notifications\": {\"email\": true, \"push\": false}}\n\nMigration file structure:\n- up.sql: ALTER TABLE users ADD COLUMN preferences JSONB DEFAULT '{}'::jsonb NOT NULL; CREATE INDEX ...\n- down.sql: DROP INDEX idx_users_preferences_gin; ALTER TABLE users DROP COLUMN preferences;\n- Estimated time: <100ms on 1M rows (column default doesn't rewrite table)\n\nApplication code changes:\n- Update User model with preferences: Record<string, any>\n- Add preference validation schema (max 50KB, valid JSON)\n- Add endpoint: PATCH /api/v1/users/:id/preferences (merge with existing prefs)\n- Query optimization: WHERE preferences @> '{\"theme\": \"dark\"}' uses GIN index\n\nRollback plan:\n- Run down.sql to remove column\n- No data loss (preferences are optional settings)",
        "files_touched": [
          "migrations/20251029_add_user_preferences.sql",
          "src/models/user.ts",
          "src/api/users/preferences.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5121639604735129,
        "is_confident": true
      },
      {
        "task_id": "IMP-PERF-01",
        "title": "Implement Redis caching layer with TTL and cache invalidation",
        "description": "Add Redis caching for frequently accessed data (user sessions, product catalog) to reduce database load by 80%.\n\nCaching strategy:\n\n1. User sessions (high read frequency):\n   - Key: session:{session_id}\n   - Value: {user_id, role, permissions, expires_at}\n   - TTL: 15 minutes (refresh on each request)\n   - Invalidation: On logout or password change\n   - Pattern: Read-through cache (check Redis, fallback to DB, populate cache)\n\n2. Product catalog (read-heavy, infrequent updates):\n   - Key: product:{product_id}\n   - Value: {id, name, price, description, inventory, images}\n   - TTL: 1 hour\n   - Invalidation: On product update (PATCH /products/:id)\n   - Pattern: Cache-aside (application manages cache explicitly)\n\n3. API rate limits (write-heavy):\n   - Key: ratelimit:{ip}:{endpoint}\n   - Value: Request count\n   - TTL: 1 minute (sliding window)\n   - Increment on each request: INCR key, check if > limit\n\nRedis client setup:\n- Use ioredis library (supports Redis Cluster, pipelining)\n- Connection pool: 10 connections max\n- Retry strategy: Exponential backoff (1s, 2s, 4s, max 10s)\n- Error handling: If Redis unavailable, fallback to database (log warning)\n\nCache patterns implementation:\n\nRead-through cache:\n```typescript\nasync function getUser(userId: string): Promise<User> {\n  // Try cache first\n  const cached = await redis.get(`user:${userId}`);\n  if (cached) {\n    return JSON.parse(cached);\n  }\n\n  // Cache miss: fetch from database\n  const user = await db.users.findUnique({where: {id: userId}});\n\n  // Populate cache with 15min TTL\n  await redis.setex(`user:${userId}`, 900, JSON.stringify(user));\n\n  return user;\n}\n```\n\nCache invalidation:\n```typescript\nasync function updateProduct(id: string, data: UpdateData): Promise<Product> {\n  // Update database\n  const product = await db.products.update({where: {id}, data});\n\n  // Invalidate cache\n  await redis.del(`product:${id}`);\n\n  // Optional: Also invalidate list caches\n  await redis.del('products:list:page:*');  // Use SCAN to find keys\n\n  return product;\n}\n```\n\nPerformance optimization:\n- Pipeline multiple operations: redis.pipeline().get('key1').get('key2').exec()\n- Use mget for bulk reads: redis.mget(['key1', 'key2', 'key3'])\n- Compress large values: Use zlib to gzip JSON before storing\n\nMonitoring:\n- Cache hit rate: hits / (hits + misses), target >90%\n- Eviction rate: Monitor evicted_keys metric, alert if >1000/min\n- Memory usage: Alert if >80% of max memory\n- Connection errors: Alert on connection failures\n\nCache warming:\n- On application startup: Preload hot data (top 100 products)\n- Scheduled job: Refresh catalog every hour\n- Avoid thundering herd: Use locks (SET key NX EX 10) for cache regeneration\n\nTests:\n- Cache hit: Verify second read from cache (faster than DB)\n- Cache miss: Verify fallback to DB\n- Cache invalidation: Update data, verify cache cleared\n- Redis failure: Verify graceful degradation to DB\n- Concurrent requests: No cache stampede (use locking)",
        "files_touched": [
          "src/cache/redis-client.ts",
          "src/cache/cache-strategy.ts",
          "src/cache/redis-client.test.ts",
          "src/middleware/rate-limit.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5106723538614579,
        "is_confident": true
      },
      {
        "task_id": "DOC-02",
        "title": "Generate OpenAPI 3.1 specification with request/response examples",
        "description": "Create comprehensive OpenAPI specification for all REST API endpoints with rich examples.\n\nOpenAPI file structure (openapi.yaml):\n\n```yaml\nopenapi: 3.1.0\ninfo:\n  title: Company API\n  version: 1.2.3\n  description: REST API for company platform\n  contact:\n    email: api-team@company.com\nservers:\n  - url: https://api.company.com/v1\n    description: Production\n  - url: https://api-staging.company.com/v1\n    description: Staging\n```\n\nAuthentication:\n- Security scheme: Bearer JWT token\n- Header: Authorization: Bearer <token>\n- Token obtained from POST /auth/login\n- Include security requirement on all protected endpoints\n\nEndpoint documentation (30 endpoints total):\n\nExample: GET /users\n```yaml\n/users:\n  get:\n    summary: List users with pagination\n    operationId: listUsers\n    tags: [Users]\n    parameters:\n      - name: cursor\n        in: query\n        schema: {type: string}\n        description: Pagination cursor from previous response\n      - name: limit\n        in: query\n        schema: {type: integer, minimum: 1, maximum: 100, default: 50}\n      - name: role\n        in: query\n        schema: {type: string, enum: [admin, user, guest]}\n    responses:\n      '200':\n        description: Successful response\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                users:\n                  type: array\n                  items: {$ref: '#/components/schemas/User'}\n                next_cursor: {type: string, nullable: true}\n            examples:\n              page1:\n                summary: First page of results\n                value:\n                  users: [{id: 1, email: \"alice@example.com\", role: \"admin\"}]\n                  next_cursor: \"eyJpZCI6MX0=\"\n      '401': {$ref: '#/components/responses/Unauthorized'}\n      '429': {$ref: '#/components/responses/RateLimited'}\n```\n\nSchemas (components/schemas):\n- User: id, email, display_name, role, created_at\n- Error: code, message, details\n- PaginationMeta: cursor, limit, has_more\n\nResponse examples:\n- Include success case (200)\n- Include error cases (400, 401, 404, 500)\n- Include edge cases (empty results, max limit exceeded)\n\nRate limiting documentation:\n- Global: 1000 requests/hour per IP\n- Per-endpoint: Varies (auth: 10/min, search: 100/min)\n- Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- 429 response includes Retry-After header\n\nCode generation:\n- Generate TypeScript types: openapi-typescript openapi.yaml -o types/api.ts\n- Generate client SDK: openapi-generator-cli generate -i openapi.yaml -g typescript-axios -o sdk/\n- Validate spec: openapi-generator-cli validate -i openapi.yaml\n\nInteractive documentation:\n- Host Swagger UI: Serve openapi.yaml at https://api.company.com/docs\n- Try it out: Allow users to make test requests directly from docs\n- Authentication: Users can input their JWT token in Swagger UI\n\nVersioning:\n- API version in URL: /v1/users\n- Breaking changes require new version: /v2/users\n- Document deprecated endpoints: deprecated: true, description: \"Use /v2/users instead\"\n\nValidation:\n- Ensure all endpoints documented (compare with actual routes)\n- Ensure all schemas used (no orphaned definitions)\n- Ensure examples valid (match schema)",
        "files_touched": [
          "docs/openapi.yaml",
          "docs/api-reference.md",
          "scripts/generate-docs.sh",
          "docs/swagger-ui.html"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.506892282599123,
        "is_confident": true
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "IMP-API-02",
      "title": "Implement JWT access/refresh token authentication with Redis",
      "description": "Add JWT-based authentication with access tokens (15min TTL) and refresh tokens (7 day TTL).\n\nTechnical approach:\n- Access token: JWT with user_id, role, issued_at (HS256 signature)\n- Refresh token: Opaque UUID stored in Redis with user_id mapping\n- Middleware: validateAccessToken() extracts claims, attaches to req.user\n- Endpoint: POST /api/v1/auth/refresh (exchange refresh for new access token)\n- Redis key pattern: refresh_token:{uuid} -> {user_id, expires_at}\n- Token rotation: Issue new refresh token on each use (invalidate old)\n\nSecurity requirements:\n- Access token in Authorization: Bearer header\n- Refresh token in httpOnly secure cookie\n- Rate limit: 10 refresh/minute per IP\n- Reject tokens after user logout (blacklist in Redis)\n- Audit log: token issued, refreshed, revoked events\n\nError handling:\n- 401: Token expired, invalid signature, malformed\n- 403: User deactivated, role changed, token blacklisted\n- Include WWW-Authenticate header with error details\n\nTests:\n- Valid token flow\n- Expired token rejection\n- Refresh token rotation\n- Concurrent refresh handling (only one succeeds)",
      "files_touched": [
        "src/middleware/auth.ts",
        "src/auth/tokens.ts",
        "src/auth/tokens.test.ts",
        "src/redis/client.ts"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "CRIT-UI-01",
        "title": "Fix React form losing data on validation error (state management bug)",
        "description": "Contact form clears all fields when server returns validation error, losing user's work.\n\nBug details:\n- User fills out 10-field contact form (takes 5 minutes)\n- Submit fails with \"Email already registered\" error\n- Form state resets to empty, all data lost\n- Users complaining: \"I had to re-enter everything!\"\n\nRoot cause:\n- Form component calls setFormData({}) on any error response\n- Should preserve form data, only show error message\n- Current code: `onError: () => setFormData(initialFormData)` \u274c\n\nFix approach:\n1. Remove setFormData({}) from error handler\n2. Add auto-save to localStorage every 2 seconds:\n   - Key: `form_draft_contact_${Date.now()}`\n   - Value: JSON.stringify(formData)\n   - Clear localStorage on successful submit\n3. On page load: Restore draft if present (show \"Restore previous draft?\" prompt)\n4. Show inline field errors (don't clear valid fields):\n   - Server returns: {errors: {email: \"Already registered\", phone: \"Invalid format\"}}\n   - Only highlight email and phone fields, preserve other data\n\nAdditional improvements:\n- Add \"Save draft\" button (manual save to localStorage)\n- Show \"*Unsaved changes\" indicator\n- Warn before leaving page: beforeunload event if form has data\n\nTests:\n- Submit with validation error preserves form data\n- Auto-save writes to localStorage every 2s\n- Draft restored on page reload\n- Draft cleared after successful submit\n- beforeunload warns when form has unsaved data",
        "files_touched": [
          "src/components/ContactForm.tsx",
          "src/hooks/useFormPersistence.ts",
          "src/components/ContactForm.test.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5479098601998265,
        "is_confident": true
      },
      {
        "task_id": "CRIT-API-01",
        "title": "Fix SQL injection vulnerability in search endpoint",
        "description": "CRITICAL: GET /api/v1/products/search?q=<query> is vulnerable to SQL injection.\n\nVulnerability details:\n- Endpoint: GET /api/v1/products/search?q=foo\n- Current code: db.query(`SELECT * FROM products WHERE name LIKE '%${req.query.q}%'`)\n- Attack vector: ?q='; DROP TABLE products; --\n- Confirmed exploitable in production (no damage yet)\n\nFix approach:\n- Replace with parameterized query: db.query('SELECT * FROM products WHERE name LIKE ?', [`%${query}%`])\n- Use Prisma raw query with $1 placeholders\n- Add input validation: alphanumeric + spaces only (reject special chars)\n- Escape wildcards: replace % and _ in user input\n- Add rate limiting: 100 searches/minute per IP\n\nAdditional security:\n- Audit all other endpoints for SQL injection (grep for string concatenation in queries)\n- Add SAST check in CI: semgrep rule for SQL injection patterns\n- Add database user with read-only permissions for search queries\n\nTests:\n- Test injection attempts return 400 Bad Request\n- Test escaped wildcards don't match unintended results\n- Test rate limiting blocks excessive requests",
        "files_touched": [
          "src/api/products/search.ts",
          "src/api/products/search.test.ts",
          "src/db/validation.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5285800874423546,
        "is_confident": true
      },
      {
        "task_id": "IMP-OBS-02",
        "title": "Build Grafana dashboard for application health with Prometheus metrics",
        "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
        "files_touched": [
          "src/metrics/prometheus.ts",
          "src/metrics/collectors.ts",
          "grafana/dashboard.json",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.49153274414624387,
        "is_confident": false
      },
      {
        "task_id": "DOC-02",
        "title": "Generate OpenAPI 3.1 specification with request/response examples",
        "description": "Create comprehensive OpenAPI specification for all REST API endpoints with rich examples.\n\nOpenAPI file structure (openapi.yaml):\n\n```yaml\nopenapi: 3.1.0\ninfo:\n  title: Company API\n  version: 1.2.3\n  description: REST API for company platform\n  contact:\n    email: api-team@company.com\nservers:\n  - url: https://api.company.com/v1\n    description: Production\n  - url: https://api-staging.company.com/v1\n    description: Staging\n```\n\nAuthentication:\n- Security scheme: Bearer JWT token\n- Header: Authorization: Bearer <token>\n- Token obtained from POST /auth/login\n- Include security requirement on all protected endpoints\n\nEndpoint documentation (30 endpoints total):\n\nExample: GET /users\n```yaml\n/users:\n  get:\n    summary: List users with pagination\n    operationId: listUsers\n    tags: [Users]\n    parameters:\n      - name: cursor\n        in: query\n        schema: {type: string}\n        description: Pagination cursor from previous response\n      - name: limit\n        in: query\n        schema: {type: integer, minimum: 1, maximum: 100, default: 50}\n      - name: role\n        in: query\n        schema: {type: string, enum: [admin, user, guest]}\n    responses:\n      '200':\n        description: Successful response\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                users:\n                  type: array\n                  items: {$ref: '#/components/schemas/User'}\n                next_cursor: {type: string, nullable: true}\n            examples:\n              page1:\n                summary: First page of results\n                value:\n                  users: [{id: 1, email: \"alice@example.com\", role: \"admin\"}]\n                  next_cursor: \"eyJpZCI6MX0=\"\n      '401': {$ref: '#/components/responses/Unauthorized'}\n      '429': {$ref: '#/components/responses/RateLimited'}\n```\n\nSchemas (components/schemas):\n- User: id, email, display_name, role, created_at\n- Error: code, message, details\n- PaginationMeta: cursor, limit, has_more\n\nResponse examples:\n- Include success case (200)\n- Include error cases (400, 401, 404, 500)\n- Include edge cases (empty results, max limit exceeded)\n\nRate limiting documentation:\n- Global: 1000 requests/hour per IP\n- Per-endpoint: Varies (auth: 10/min, search: 100/min)\n- Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- 429 response includes Retry-After header\n\nCode generation:\n- Generate TypeScript types: openapi-typescript openapi.yaml -o types/api.ts\n- Generate client SDK: openapi-generator-cli generate -i openapi.yaml -g typescript-axios -o sdk/\n- Validate spec: openapi-generator-cli validate -i openapi.yaml\n\nInteractive documentation:\n- Host Swagger UI: Serve openapi.yaml at https://api.company.com/docs\n- Try it out: Allow users to make test requests directly from docs\n- Authentication: Users can input their JWT token in Swagger UI\n\nVersioning:\n- API version in URL: /v1/users\n- Breaking changes require new version: /v2/users\n- Document deprecated endpoints: deprecated: true, description: \"Use /v2/users instead\"\n\nValidation:\n- Ensure all endpoints documented (compare with actual routes)\n- Ensure all schemas used (no orphaned definitions)\n- Ensure examples valid (match schema)",
        "files_touched": [
          "docs/openapi.yaml",
          "docs/api-reference.md",
          "scripts/generate-docs.sh",
          "docs/swagger-ui.html"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.4835299851296618,
        "is_confident": false
      },
      {
        "task_id": "IMP-API-01",
        "title": "Add GET /api/v1/users endpoint with cursor-based pagination",
        "description": "Implement REST API endpoint for listing users with cursor-based pagination (not offset/limit).\n\nTechnical requirements:\n- Endpoint: GET /api/v1/users?cursor=<id>&limit=50\n- Return fields: id, email, display_name, created_at, role\n- Default limit: 50, max limit: 100\n- Sort by: id ASC (stable ordering for cursor)\n- Response includes next_cursor for pagination\n- Filter support: ?role=admin,user&status=active\n- Return 400 for invalid cursor, 401 for unauthenticated\n\nImplementation approach:\n- Use Prisma ORM with cursor pagination\n- Add index on (id, created_at) for performance\n- Implement CursorPaginationDTO with Zod validation\n- Unit tests: pagination, filtering, edge cases (empty result, last page)\n- OpenAPI spec in docs/api.yaml\n\nAcceptance criteria:\n- Paginate through 10,000 users in <2s total\n- No duplicate users across pages\n- Works with concurrent updates (stable cursor)",
        "files_touched": [
          "src/api/users/list.ts",
          "src/api/users/list.test.ts",
          "src/dto/pagination.ts",
          "docs/api.yaml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.478177013295565,
        "is_confident": false
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "CRIT-API-01",
      "title": "Fix SQL injection vulnerability in search endpoint",
      "description": "CRITICAL: GET /api/v1/products/search?q=<query> is vulnerable to SQL injection.\n\nVulnerability details:\n- Endpoint: GET /api/v1/products/search?q=foo\n- Current code: db.query(`SELECT * FROM products WHERE name LIKE '%${req.query.q}%'`)\n- Attack vector: ?q='; DROP TABLE products; --\n- Confirmed exploitable in production (no damage yet)\n\nFix approach:\n- Replace with parameterized query: db.query('SELECT * FROM products WHERE name LIKE ?', [`%${query}%`])\n- Use Prisma raw query with $1 placeholders\n- Add input validation: alphanumeric + spaces only (reject special chars)\n- Escape wildcards: replace % and _ in user input\n- Add rate limiting: 100 searches/minute per IP\n\nAdditional security:\n- Audit all other endpoints for SQL injection (grep for string concatenation in queries)\n- Add SAST check in CI: semgrep rule for SQL injection patterns\n- Add database user with read-only permissions for search queries\n\nTests:\n- Test injection attempts return 400 Bad Request\n- Test escaped wildcards don't match unintended results\n- Test rate limiting blocks excessive requests",
      "files_touched": [
        "src/api/products/search.ts",
        "src/api/products/search.test.ts",
        "src/db/validation.ts"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "CRIT-UI-01",
        "title": "Fix React form losing data on validation error (state management bug)",
        "description": "Contact form clears all fields when server returns validation error, losing user's work.\n\nBug details:\n- User fills out 10-field contact form (takes 5 minutes)\n- Submit fails with \"Email already registered\" error\n- Form state resets to empty, all data lost\n- Users complaining: \"I had to re-enter everything!\"\n\nRoot cause:\n- Form component calls setFormData({}) on any error response\n- Should preserve form data, only show error message\n- Current code: `onError: () => setFormData(initialFormData)` \u274c\n\nFix approach:\n1. Remove setFormData({}) from error handler\n2. Add auto-save to localStorage every 2 seconds:\n   - Key: `form_draft_contact_${Date.now()}`\n   - Value: JSON.stringify(formData)\n   - Clear localStorage on successful submit\n3. On page load: Restore draft if present (show \"Restore previous draft?\" prompt)\n4. Show inline field errors (don't clear valid fields):\n   - Server returns: {errors: {email: \"Already registered\", phone: \"Invalid format\"}}\n   - Only highlight email and phone fields, preserve other data\n\nAdditional improvements:\n- Add \"Save draft\" button (manual save to localStorage)\n- Show \"*Unsaved changes\" indicator\n- Warn before leaving page: beforeunload event if form has data\n\nTests:\n- Submit with validation error preserves form data\n- Auto-save writes to localStorage every 2s\n- Draft restored on page reload\n- Draft cleared after successful submit\n- beforeunload warns when form has unsaved data",
        "files_touched": [
          "src/components/ContactForm.tsx",
          "src/hooks/useFormPersistence.ts",
          "src/components/ContactForm.test.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5986898274193144,
        "is_confident": true
      },
      {
        "task_id": "CRIT-DB-01",
        "title": "Fix N+1 query causing 2000+ database roundtrips on orders page",
        "description": "Orders list page loads in 8 seconds due to N+1 query problem (2000 queries for 100 orders).\n\nCurrent problem:\n- Query 1: SELECT * FROM orders LIMIT 100 (1 query)\n- Loop: For each order, SELECT * FROM customers WHERE id = order.customer_id (100 queries)\n- Loop: For each order, SELECT * FROM order_items WHERE order_id = order.id (100 queries)\n- Loop: For each item, SELECT * FROM products WHERE id = item.product_id (2000 queries)\n- Total: 2201 queries, 8 seconds page load\n\nSolution approach:\n- Single query with JOINs and aggregation:\n  ```sql\n  SELECT\n    o.id, o.total, o.status, o.created_at,\n    c.id as customer_id, c.name as customer_name, c.email,\n    jsonb_agg(jsonb_build_object(\n      'product_id', p.id,\n      'product_name', p.name,\n      'quantity', oi.quantity,\n      'price', oi.price\n    )) as items\n  FROM orders o\n  JOIN customers c ON o.customer_id = c.id\n  JOIN order_items oi ON oi.order_id = o.id\n  JOIN products p ON oi.product_id = p.id\n  GROUP BY o.id, c.id\n  ORDER BY o.created_at DESC\n  LIMIT 100\n  ```\n- Add indexes: customers(id), order_items(order_id), order_items(product_id)\n- Use Prisma include: order.include({customer: true, items: {include: {product: true}}})\n\nPerformance improvement:\n- Before: 2201 queries, 8000ms\n- After: 1 query, 120ms (66x faster)\n\nVerification:\n- Enable query logging\n- Load page, verify single query executed\n- Load test: 100 concurrent requests, p95 < 300ms",
        "files_touched": [
          "src/api/orders/list.ts",
          "migrations/20251029_add_order_indexes.sql",
          "src/api/orders/list.test.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5582172843983969,
        "is_confident": true
      },
      {
        "task_id": "IMP-OBS-02",
        "title": "Build Grafana dashboard for application health with Prometheus metrics",
        "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
        "files_touched": [
          "src/metrics/prometheus.ts",
          "src/metrics/collectors.ts",
          "grafana/dashboard.json",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5450198710921413,
        "is_confident": true
      },
      {
        "task_id": "IMP-API-02",
        "title": "Implement JWT access/refresh token authentication with Redis",
        "description": "Add JWT-based authentication with access tokens (15min TTL) and refresh tokens (7 day TTL).\n\nTechnical approach:\n- Access token: JWT with user_id, role, issued_at (HS256 signature)\n- Refresh token: Opaque UUID stored in Redis with user_id mapping\n- Middleware: validateAccessToken() extracts claims, attaches to req.user\n- Endpoint: POST /api/v1/auth/refresh (exchange refresh for new access token)\n- Redis key pattern: refresh_token:{uuid} -> {user_id, expires_at}\n- Token rotation: Issue new refresh token on each use (invalidate old)\n\nSecurity requirements:\n- Access token in Authorization: Bearer header\n- Refresh token in httpOnly secure cookie\n- Rate limit: 10 refresh/minute per IP\n- Reject tokens after user logout (blacklist in Redis)\n- Audit log: token issued, refreshed, revoked events\n\nError handling:\n- 401: Token expired, invalid signature, malformed\n- 403: User deactivated, role changed, token blacklisted\n- Include WWW-Authenticate header with error details\n\nTests:\n- Valid token flow\n- Expired token rejection\n- Refresh token rotation\n- Concurrent refresh handling (only one succeeds)",
        "files_touched": [
          "src/middleware/auth.ts",
          "src/auth/tokens.ts",
          "src/auth/tokens.test.ts",
          "src/redis/client.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5285800874423546,
        "is_confident": true
      },
      {
        "task_id": "CRIT-OBS-01",
        "title": "Fix memory leak in background job processor (25GB heap growth over 24h)",
        "description": "Worker process memory grows from 500MB to 25GB over 24 hours, crashing with OOM error.\n\nSymptoms:\n- Worker starts: 500MB heap\n- After 24h: 25GB heap (50x growth!)\n- Eventually crashes: \"JavaScript heap out of memory\"\n- Requires manual restart every day\n\nInvestigation steps:\n1. Take heap snapshots: node --expose-gc --max-old-space-size=2048 worker.js\n2. Capture snapshots: Every hour for 24 hours\n3. Analyze with Chrome DevTools Memory Profiler\n4. Compare snapshots: Identify growing objects\n\nFindings (from heap analysis):\n- Retained size: 23GB in Array of Job objects\n- Retaining path: jobQueue \u2192 processedJobs \u2192 Job[]\n- Root cause: processedJobs.push(job) on every job completion, never cleared\n- Jobs accumulate: 1000 jobs/hour * 24 hours = 24,000 jobs * 1MB each = 24GB\n\nFix:\n1. Remove processedJobs array (not needed, jobs logged to database)\n2. Alternative: Limit array size with LRU cache (keep last 1000 jobs only)\n3. Add memory monitoring: Log heap size every minute, alert if >2GB\n\nVerification approach:\n- Run worker for 48 hours with fix\n- Monitor heap size: Should stay flat at ~500MB\n- Load test: Process 100,000 jobs, verify no memory growth\n\nAdditional improvements:\n- Add job.cleanup() method to release resources (close file handles, clear buffers)\n- Use WeakMap for temporary job metadata (auto garbage collected)\n- Set maxJobRetention: 1000 (after 1000 jobs, clear oldest)\n\nMemory profile comparison:\n- Before: 500MB \u2192 25GB over 24h (linear growth)\n- After: 500MB \u2192 520MB over 48h (stable)\n\nTests:\n- Process 10,000 jobs in test, verify heap <1GB\n- Check no memory leaks with --expose-gc and manual GC after each job",
        "files_touched": [
          "src/workers/job-processor.ts",
          "src/workers/cleanup.ts",
          "src/workers/memory-monitor.ts",
          "src/workers/job-processor.test.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5213532819676842,
        "is_confident": true
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "IMP-DB-01",
      "title": "Add Postgres migration for user_preferences JSONB column",
      "description": "Create migration to add user preferences as flexible JSONB column.\n\nSchema change:\n- Table: users\n- New column: preferences JSONB DEFAULT '{}'::jsonb NOT NULL\n- Add GIN index: CREATE INDEX idx_users_preferences_gin ON users USING GIN (preferences)\n- Example data: {\"theme\": \"dark\", \"language\": \"en-US\", \"timezone\": \"America/Los_Angeles\", \"notifications\": {\"email\": true, \"push\": false}}\n\nMigration file structure:\n- up.sql: ALTER TABLE users ADD COLUMN preferences JSONB DEFAULT '{}'::jsonb NOT NULL; CREATE INDEX ...\n- down.sql: DROP INDEX idx_users_preferences_gin; ALTER TABLE users DROP COLUMN preferences;\n- Estimated time: <100ms on 1M rows (column default doesn't rewrite table)\n\nApplication code changes:\n- Update User model with preferences: Record<string, any>\n- Add preference validation schema (max 50KB, valid JSON)\n- Add endpoint: PATCH /api/v1/users/:id/preferences (merge with existing prefs)\n- Query optimization: WHERE preferences @> '{\"theme\": \"dark\"}' uses GIN index\n\nRollback plan:\n- Run down.sql to remove column\n- No data loss (preferences are optional settings)",
      "files_touched": [
        "migrations/20251029_add_user_preferences.sql",
        "src/models/user.ts",
        "src/api/users/preferences.ts"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "CRIT-UI-01",
        "title": "Fix React form losing data on validation error (state management bug)",
        "description": "Contact form clears all fields when server returns validation error, losing user's work.\n\nBug details:\n- User fills out 10-field contact form (takes 5 minutes)\n- Submit fails with \"Email already registered\" error\n- Form state resets to empty, all data lost\n- Users complaining: \"I had to re-enter everything!\"\n\nRoot cause:\n- Form component calls setFormData({}) on any error response\n- Should preserve form data, only show error message\n- Current code: `onError: () => setFormData(initialFormData)` \u274c\n\nFix approach:\n1. Remove setFormData({}) from error handler\n2. Add auto-save to localStorage every 2 seconds:\n   - Key: `form_draft_contact_${Date.now()}`\n   - Value: JSON.stringify(formData)\n   - Clear localStorage on successful submit\n3. On page load: Restore draft if present (show \"Restore previous draft?\" prompt)\n4. Show inline field errors (don't clear valid fields):\n   - Server returns: {errors: {email: \"Already registered\", phone: \"Invalid format\"}}\n   - Only highlight email and phone fields, preserve other data\n\nAdditional improvements:\n- Add \"Save draft\" button (manual save to localStorage)\n- Show \"*Unsaved changes\" indicator\n- Warn before leaving page: beforeunload event if form has data\n\nTests:\n- Submit with validation error preserves form data\n- Auto-save writes to localStorage every 2s\n- Draft restored on page reload\n- Draft cleared after successful submit\n- beforeunload warns when form has unsaved data",
        "files_touched": [
          "src/components/ContactForm.tsx",
          "src/hooks/useFormPersistence.ts",
          "src/components/ContactForm.test.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5247366128089127,
        "is_confident": true
      },
      {
        "task_id": "IMP-API-01",
        "title": "Add GET /api/v1/users endpoint with cursor-based pagination",
        "description": "Implement REST API endpoint for listing users with cursor-based pagination (not offset/limit).\n\nTechnical requirements:\n- Endpoint: GET /api/v1/users?cursor=<id>&limit=50\n- Return fields: id, email, display_name, created_at, role\n- Default limit: 50, max limit: 100\n- Sort by: id ASC (stable ordering for cursor)\n- Response includes next_cursor for pagination\n- Filter support: ?role=admin,user&status=active\n- Return 400 for invalid cursor, 401 for unauthenticated\n\nImplementation approach:\n- Use Prisma ORM with cursor pagination\n- Add index on (id, created_at) for performance\n- Implement CursorPaginationDTO with Zod validation\n- Unit tests: pagination, filtering, edge cases (empty result, last page)\n- OpenAPI spec in docs/api.yaml\n\nAcceptance criteria:\n- Paginate through 10,000 users in <2s total\n- No duplicate users across pages\n- Works with concurrent updates (stable cursor)",
        "files_touched": [
          "src/api/users/list.ts",
          "src/api/users/list.test.ts",
          "src/dto/pagination.ts",
          "docs/api.yaml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5121639604735129,
        "is_confident": true
      },
      {
        "task_id": "CRIT-API-01",
        "title": "Fix SQL injection vulnerability in search endpoint",
        "description": "CRITICAL: GET /api/v1/products/search?q=<query> is vulnerable to SQL injection.\n\nVulnerability details:\n- Endpoint: GET /api/v1/products/search?q=foo\n- Current code: db.query(`SELECT * FROM products WHERE name LIKE '%${req.query.q}%'`)\n- Attack vector: ?q='; DROP TABLE products; --\n- Confirmed exploitable in production (no damage yet)\n\nFix approach:\n- Replace with parameterized query: db.query('SELECT * FROM products WHERE name LIKE ?', [`%${query}%`])\n- Use Prisma raw query with $1 placeholders\n- Add input validation: alphanumeric + spaces only (reject special chars)\n- Escape wildcards: replace % and _ in user input\n- Add rate limiting: 100 searches/minute per IP\n\nAdditional security:\n- Audit all other endpoints for SQL injection (grep for string concatenation in queries)\n- Add SAST check in CI: semgrep rule for SQL injection patterns\n- Add database user with read-only permissions for search queries\n\nTests:\n- Test injection attempts return 400 Bad Request\n- Test escaped wildcards don't match unintended results\n- Test rate limiting blocks excessive requests",
        "files_touched": [
          "src/api/products/search.ts",
          "src/api/products/search.test.ts",
          "src/db/validation.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5020312629897923,
        "is_confident": true
      },
      {
        "task_id": "DOC-01",
        "title": "Write comprehensive production deployment guide with blue-green strategy",
        "description": "Create step-by-step deployment documentation for production environment with zero-downtime blue-green deployments.\n\nDocument structure:\n\n1. Prerequisites:\n   - AWS account with EC2, RDS, S3, Route53 access\n   - Kubernetes cluster (EKS) with kubectl configured\n   - Docker registry access (ECR)\n   - Terraform v1.5+ for infrastructure\n   - Required secrets in AWS Secrets Manager\n\n2. Pre-deployment checklist:\n   - Run test suite: npm test (must be 100% passing)\n   - Run security scan: npm audit (0 high/critical vulnerabilities)\n   - Build Docker image: docker build -t api:v1.2.3 .\n   - Push to registry: docker push ecr.../api:v1.2.3\n   - Database migrations ready: Review migrations/*.sql\n   - Feature flags configured: Check LaunchDarkly dashboard\n\n3. Blue-green deployment steps:\n\n   Step 1: Deploy to GREEN environment (staging)\n   - Update Kubernetes deployment: kubectl set image deployment/api-green api=api:v1.2.3\n   - Wait for rollout: kubectl rollout status deployment/api-green (5 min timeout)\n   - Run smoke tests: curl https://api-green.company.com/health\n   - Verify metrics: Check Grafana dashboard (request rate, error rate, latency)\n\n   Step 2: Run database migrations (if needed)\n   - Migrations run from Kubernetes job: kubectl apply -f k8s/migrate-job.yaml\n   - Forward-compatible only (old code still works): ADD COLUMN (not DROP COLUMN)\n   - Verify migration success: Check job logs, query database\n\n   Step 3: Traffic switch (blue \u2192 green)\n   - Update Route53 weighted routing: 0% blue, 100% green\n   - Monitor error rates: Watch for spike in errors (rollback trigger)\n   - Gradual rollout: 10% \u2192 50% \u2192 100% over 30 minutes\n   - Rollback criteria: Error rate >5% OR p95 latency >500ms OR manual abort\n\n   Step 4: Verify production traffic\n   - Check logs: kubectl logs -f deployment/api-green (look for errors)\n   - Check metrics: Request rate matches expected (no traffic loss)\n   - Check APM: Verify traces in Datadog show expected flow\n   - User testing: QA team tests critical flows in production\n\n   Step 5: Decommission BLUE environment\n   - Scale down old deployment: kubectl scale deployment/api-blue --replicas=0\n   - Keep for 24h as rollback option\n   - After 24h: Delete blue deployment\n\n4. Rollback procedure:\n   - Immediate rollback: kubectl set image deployment/api-green api=api:v1.2.2 (previous version)\n   - Or traffic switch: Route53 100% to blue (old version still running)\n   - Investigate issues: Check logs, metrics, error reports\n   - Fix forward: Deploy hotfix to green, switch traffic back\n\n5. Post-deployment:\n   - Update release notes: docs/CHANGELOG.md\n   - Notify team: Slack message to #deployments channel\n   - Monitor for 1 hour: Watch metrics, error logs, user reports\n   - Tag release: git tag v1.2.3 && git push --tags\n\n6. Troubleshooting common issues:\n   - Issue: Deployment stuck in \"Progressing\" state\n     - Cause: Image pull error (invalid tag)\n     - Fix: Verify image exists: docker pull ecr.../api:v1.2.3\n\n   - Issue: Pods crashing (CrashLoopBackOff)\n     - Cause: Missing environment variable or secret\n     - Fix: Check pod logs: kubectl logs api-green-xxxx\n\n   - Issue: High error rate after deployment\n     - Cause: Breaking change in API, clients sending old format\n     - Fix: Rollback immediately, implement backward compatibility\n\nAppendices:\n- A: Environment variables reference (50+ vars with descriptions)\n- B: Kubernetes resource definitions (deployment.yaml, service.yaml)\n- C: Monitoring runbooks (what to do when alerts fire)\n- D: Database migration best practices",
        "files_touched": [
          "docs/deployment.md",
          "docs/troubleshooting.md",
          "docs/runbooks.md",
          "k8s/deployment.yaml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.4804112682356673,
        "is_confident": false
      },
      {
        "task_id": "IMP-API-02",
        "title": "Implement JWT access/refresh token authentication with Redis",
        "description": "Add JWT-based authentication with access tokens (15min TTL) and refresh tokens (7 day TTL).\n\nTechnical approach:\n- Access token: JWT with user_id, role, issued_at (HS256 signature)\n- Refresh token: Opaque UUID stored in Redis with user_id mapping\n- Middleware: validateAccessToken() extracts claims, attaches to req.user\n- Endpoint: POST /api/v1/auth/refresh (exchange refresh for new access token)\n- Redis key pattern: refresh_token:{uuid} -> {user_id, expires_at}\n- Token rotation: Issue new refresh token on each use (invalidate old)\n\nSecurity requirements:\n- Access token in Authorization: Bearer header\n- Refresh token in httpOnly secure cookie\n- Rate limit: 10 refresh/minute per IP\n- Reject tokens after user logout (blacklist in Redis)\n- Audit log: token issued, refreshed, revoked events\n\nError handling:\n- 401: Token expired, invalid signature, malformed\n- 403: User deactivated, role changed, token blacklisted\n- Include WWW-Authenticate header with error details\n\nTests:\n- Valid token flow\n- Expired token rejection\n- Refresh token rotation\n- Concurrent refresh handling (only one succeeds)",
        "files_touched": [
          "src/middleware/auth.ts",
          "src/auth/tokens.ts",
          "src/auth/tokens.test.ts",
          "src/redis/client.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.46793790534071983,
        "is_confident": false
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "CRIT-DB-01",
      "title": "Fix N+1 query causing 2000+ database roundtrips on orders page",
      "description": "Orders list page loads in 8 seconds due to N+1 query problem (2000 queries for 100 orders).\n\nCurrent problem:\n- Query 1: SELECT * FROM orders LIMIT 100 (1 query)\n- Loop: For each order, SELECT * FROM customers WHERE id = order.customer_id (100 queries)\n- Loop: For each order, SELECT * FROM order_items WHERE order_id = order.id (100 queries)\n- Loop: For each item, SELECT * FROM products WHERE id = item.product_id (2000 queries)\n- Total: 2201 queries, 8 seconds page load\n\nSolution approach:\n- Single query with JOINs and aggregation:\n  ```sql\n  SELECT\n    o.id, o.total, o.status, o.created_at,\n    c.id as customer_id, c.name as customer_name, c.email,\n    jsonb_agg(jsonb_build_object(\n      'product_id', p.id,\n      'product_name', p.name,\n      'quantity', oi.quantity,\n      'price', oi.price\n    )) as items\n  FROM orders o\n  JOIN customers c ON o.customer_id = c.id\n  JOIN order_items oi ON oi.order_id = o.id\n  JOIN products p ON oi.product_id = p.id\n  GROUP BY o.id, c.id\n  ORDER BY o.created_at DESC\n  LIMIT 100\n  ```\n- Add indexes: customers(id), order_items(order_id), order_items(product_id)\n- Use Prisma include: order.include({customer: true, items: {include: {product: true}}})\n\nPerformance improvement:\n- Before: 2201 queries, 8000ms\n- After: 1 query, 120ms (66x faster)\n\nVerification:\n- Enable query logging\n- Load page, verify single query executed\n- Load test: 100 concurrent requests, p95 < 300ms",
      "files_touched": [
        "src/api/orders/list.ts",
        "migrations/20251029_add_order_indexes.sql",
        "src/api/orders/list.test.ts"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "CRIT-API-01",
        "title": "Fix SQL injection vulnerability in search endpoint",
        "description": "CRITICAL: GET /api/v1/products/search?q=<query> is vulnerable to SQL injection.\n\nVulnerability details:\n- Endpoint: GET /api/v1/products/search?q=foo\n- Current code: db.query(`SELECT * FROM products WHERE name LIKE '%${req.query.q}%'`)\n- Attack vector: ?q='; DROP TABLE products; --\n- Confirmed exploitable in production (no damage yet)\n\nFix approach:\n- Replace with parameterized query: db.query('SELECT * FROM products WHERE name LIKE ?', [`%${query}%`])\n- Use Prisma raw query with $1 placeholders\n- Add input validation: alphanumeric + spaces only (reject special chars)\n- Escape wildcards: replace % and _ in user input\n- Add rate limiting: 100 searches/minute per IP\n\nAdditional security:\n- Audit all other endpoints for SQL injection (grep for string concatenation in queries)\n- Add SAST check in CI: semgrep rule for SQL injection patterns\n- Add database user with read-only permissions for search queries\n\nTests:\n- Test injection attempts return 400 Bad Request\n- Test escaped wildcards don't match unintended results\n- Test rate limiting blocks excessive requests",
        "files_touched": [
          "src/api/products/search.ts",
          "src/api/products/search.test.ts",
          "src/db/validation.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5582172843983969,
        "is_confident": true
      },
      {
        "task_id": "IMP-API-01",
        "title": "Add GET /api/v1/users endpoint with cursor-based pagination",
        "description": "Implement REST API endpoint for listing users with cursor-based pagination (not offset/limit).\n\nTechnical requirements:\n- Endpoint: GET /api/v1/users?cursor=<id>&limit=50\n- Return fields: id, email, display_name, created_at, role\n- Default limit: 50, max limit: 100\n- Sort by: id ASC (stable ordering for cursor)\n- Response includes next_cursor for pagination\n- Filter support: ?role=admin,user&status=active\n- Return 400 for invalid cursor, 401 for unauthenticated\n\nImplementation approach:\n- Use Prisma ORM with cursor pagination\n- Add index on (id, created_at) for performance\n- Implement CursorPaginationDTO with Zod validation\n- Unit tests: pagination, filtering, edge cases (empty result, last page)\n- OpenAPI spec in docs/api.yaml\n\nAcceptance criteria:\n- Paginate through 10,000 users in <2s total\n- No duplicate users across pages\n- Works with concurrent updates (stable cursor)",
        "files_touched": [
          "src/api/users/list.ts",
          "src/api/users/list.test.ts",
          "src/dto/pagination.ts",
          "docs/api.yaml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.49979297681858964,
        "is_confident": false
      },
      {
        "task_id": "IMP-UI-01",
        "title": "Build responsive navigation with mobile hamburger menu (Material UI)",
        "description": "Create responsive navigation component using Material-UI with mobile-first design.\n\nComponent requirements:\n- Desktop (>900px): Horizontal nav bar with logo, links, user menu\n- Mobile (<900px): Hamburger icon, slide-out drawer with links\n- Support nested dropdowns (Account > Profile, Settings, Logout)\n- Active link highlighting (match current route)\n- Keyboard navigation: Tab through links, Enter to activate, Escape to close drawer\n\nTechnical implementation:\n- Material-UI AppBar + Drawer components\n- React Router useLocation for active link detection\n- Animated transitions: slide drawer from left (300ms ease-out)\n- Prevent body scroll when drawer open (CSS: overflow: hidden)\n- Focus trap in drawer (focus cycles through links)\n\nAccessibility (WCAG AA):\n- Hamburger button: aria-label=\"Open navigation menu\", aria-expanded\n- Drawer: role=\"navigation\", aria-labelledby=\"nav-title\"\n- Links: Descriptive text (not \"Click here\")\n- Focus visible indicator (2px outline)\n- Color contrast ratio >4.5:1 (text on background)\n\nResponsive breakpoints:\n- Mobile: <600px (stacked links, larger tap targets 48px)\n- Tablet: 600-900px (compact nav, smaller text)\n- Desktop: >900px (full horizontal layout)\n\nTests:\n- Renders correctly at all breakpoints (visual regression)\n- Keyboard navigation works (tab order, enter, escape)\n- Active link highlights current page\n- Drawer opens/closes with animation",
        "files_touched": [
          "src/components/Navigation.tsx",
          "src/components/Navigation.test.tsx",
          "src/styles/navigation.css",
          "src/components/NavDrawer.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.4781630231730234,
        "is_confident": false
      },
      {
        "task_id": "IMP-UI-02",
        "title": "Implement dark mode with CSS custom properties and system preference detection",
        "description": "Add dark/light theme support with smooth transitions and persistent preference.\n\nTheme implementation:\n- CSS custom properties in :root for colors:\n  ```css\n  :root {\n    --bg-primary: #ffffff;\n    --text-primary: #000000;\n    --border: #e0e0e0;\n  }\n  :root[data-theme=\"dark\"] {\n    --bg-primary: #121212;\n    --text-primary: #ffffff;\n    --border: #333333;\n  }\n  ```\n- All components use: background-color: var(--bg-primary)\n- Smooth transition: transition: background-color 0.3s, color 0.3s\n\nUser preference flow:\n1. On first visit: Detect system preference (prefers-color-scheme: dark)\n2. User toggles theme: Save to localStorage (theme: \"dark\" | \"light\" | \"auto\")\n3. On subsequent visits: Load from localStorage, fall back to system preference\n\nTheme toggle UI:\n- Header button with icon (sun/moon)\n- Three states: Light, Dark, Auto (follows system)\n- Tooltip: \"Light mode\", \"Dark mode\", \"Auto (currently dark)\"\n- Smooth icon transition (fade + rotate)\n\nEdge cases:\n- System preference changes while app open \u2192 update if user has \"auto\"\n- Multiple tabs \u2192 sync theme across tabs (localStorage change event)\n- Print mode \u2192 force light theme (CSS: @media print)\n\nTests:\n- Toggle changes theme immediately\n- Theme persists after page reload\n- System preference respected when \"auto\"\n- All components render correctly in both themes",
        "files_touched": [
          "src/theme/ThemeProvider.tsx",
          "src/theme/theme.css",
          "src/components/ThemeToggle.tsx",
          "src/hooks/useTheme.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.43252673734224734,
        "is_confident": false
      },
      {
        "task_id": "CRIT-UI-01",
        "title": "Fix React form losing data on validation error (state management bug)",
        "description": "Contact form clears all fields when server returns validation error, losing user's work.\n\nBug details:\n- User fills out 10-field contact form (takes 5 minutes)\n- Submit fails with \"Email already registered\" error\n- Form state resets to empty, all data lost\n- Users complaining: \"I had to re-enter everything!\"\n\nRoot cause:\n- Form component calls setFormData({}) on any error response\n- Should preserve form data, only show error message\n- Current code: `onError: () => setFormData(initialFormData)` \u274c\n\nFix approach:\n1. Remove setFormData({}) from error handler\n2. Add auto-save to localStorage every 2 seconds:\n   - Key: `form_draft_contact_${Date.now()}`\n   - Value: JSON.stringify(formData)\n   - Clear localStorage on successful submit\n3. On page load: Restore draft if present (show \"Restore previous draft?\" prompt)\n4. Show inline field errors (don't clear valid fields):\n   - Server returns: {errors: {email: \"Already registered\", phone: \"Invalid format\"}}\n   - Only highlight email and phone fields, preserve other data\n\nAdditional improvements:\n- Add \"Save draft\" button (manual save to localStorage)\n- Show \"*Unsaved changes\" indicator\n- Warn before leaving page: beforeunload event if form has data\n\nTests:\n- Submit with validation error preserves form data\n- Auto-save writes to localStorage every 2s\n- Draft restored on page reload\n- Draft cleared after successful submit\n- beforeunload warns when form has unsaved data",
        "files_touched": [
          "src/components/ContactForm.tsx",
          "src/hooks/useFormPersistence.ts",
          "src/components/ContactForm.test.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.42748204524313776,
        "is_confident": false
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "IMP-UI-01",
      "title": "Build responsive navigation with mobile hamburger menu (Material UI)",
      "description": "Create responsive navigation component using Material-UI with mobile-first design.\n\nComponent requirements:\n- Desktop (>900px): Horizontal nav bar with logo, links, user menu\n- Mobile (<900px): Hamburger icon, slide-out drawer with links\n- Support nested dropdowns (Account > Profile, Settings, Logout)\n- Active link highlighting (match current route)\n- Keyboard navigation: Tab through links, Enter to activate, Escape to close drawer\n\nTechnical implementation:\n- Material-UI AppBar + Drawer components\n- React Router useLocation for active link detection\n- Animated transitions: slide drawer from left (300ms ease-out)\n- Prevent body scroll when drawer open (CSS: overflow: hidden)\n- Focus trap in drawer (focus cycles through links)\n\nAccessibility (WCAG AA):\n- Hamburger button: aria-label=\"Open navigation menu\", aria-expanded\n- Drawer: role=\"navigation\", aria-labelledby=\"nav-title\"\n- Links: Descriptive text (not \"Click here\")\n- Focus visible indicator (2px outline)\n- Color contrast ratio >4.5:1 (text on background)\n\nResponsive breakpoints:\n- Mobile: <600px (stacked links, larger tap targets 48px)\n- Tablet: 600-900px (compact nav, smaller text)\n- Desktop: >900px (full horizontal layout)\n\nTests:\n- Renders correctly at all breakpoints (visual regression)\n- Keyboard navigation works (tab order, enter, escape)\n- Active link highlights current page\n- Drawer opens/closes with animation",
      "files_touched": [
        "src/components/Navigation.tsx",
        "src/components/Navigation.test.tsx",
        "src/styles/navigation.css",
        "src/components/NavDrawer.tsx"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "IMP-OBS-02",
        "title": "Build Grafana dashboard for application health with Prometheus metrics",
        "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
        "files_touched": [
          "src/metrics/prometheus.ts",
          "src/metrics/collectors.ts",
          "grafana/dashboard.json",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.6504772334073105,
        "is_confident": true
      },
      {
        "task_id": "IMP-OBS-01",
        "title": "Instrument API layer with OpenTelemetry distributed tracing to Jaeger",
        "description": "Add OpenTelemetry tracing to capture request flows through API \u2192 database \u2192 external services.\n\nInstrumentation approach:\n- Use @opentelemetry/sdk-node for auto-instrumentation\n- Export traces to Jaeger (localhost:14268) via OTLP\n- Capture spans for: HTTP requests, database queries, Redis operations, external API calls\n\nSpan structure:\n- Root span: http.server (entire request/response cycle)\n  - Attributes: http.method, http.url, http.status_code, http.user_agent\n- Child spans:\n  - db.query (for each SQL query): db.statement, db.table, db.duration_ms\n  - redis.operation (get/set/del): redis.key, redis.ttl\n  - http.client (external API calls): http.url, http.method, http.status_code\n\nCustom spans:\n- Add manual spans for business logic: tracer.startSpan('process_order')\n- Add span events: span.addEvent('validation_failed', {reason: 'invalid_email'})\n- Add span links: Link payment span to order span (trace causality)\n\nPerformance:\n- Sampling: 10% of requests in production (100% in dev)\n- Batch export: Buffer 100 spans, flush every 5s\n- Low overhead: <5ms per request (confirmed with benchmark)\n\nConfiguration:\n- Environment variables: OTEL_EXPORTER_JAEGER_ENDPOINT, OTEL_SERVICE_NAME=api-server\n- Graceful degradation: If Jaeger unavailable, log warning and continue\n\nVerification:\n- Generate test traffic\n- Open Jaeger UI (http://localhost:16686)\n- Search for traces, verify complete request flow visible\n- Verify spans show correct duration, attributes, errors\n\nError tracking:\n- Failed requests: span.setStatus(SpanStatusCode.ERROR)\n- Exception details: span.recordException(error)\n- Error rate alert: If >5% requests have error status, alert",
        "files_touched": [
          "src/tracing/tracer.ts",
          "src/middleware/tracing.ts",
          "src/config/otel.ts",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5510216367324134,
        "is_confident": true
      },
      {
        "task_id": "DOC-02",
        "title": "Generate OpenAPI 3.1 specification with request/response examples",
        "description": "Create comprehensive OpenAPI specification for all REST API endpoints with rich examples.\n\nOpenAPI file structure (openapi.yaml):\n\n```yaml\nopenapi: 3.1.0\ninfo:\n  title: Company API\n  version: 1.2.3\n  description: REST API for company platform\n  contact:\n    email: api-team@company.com\nservers:\n  - url: https://api.company.com/v1\n    description: Production\n  - url: https://api-staging.company.com/v1\n    description: Staging\n```\n\nAuthentication:\n- Security scheme: Bearer JWT token\n- Header: Authorization: Bearer <token>\n- Token obtained from POST /auth/login\n- Include security requirement on all protected endpoints\n\nEndpoint documentation (30 endpoints total):\n\nExample: GET /users\n```yaml\n/users:\n  get:\n    summary: List users with pagination\n    operationId: listUsers\n    tags: [Users]\n    parameters:\n      - name: cursor\n        in: query\n        schema: {type: string}\n        description: Pagination cursor from previous response\n      - name: limit\n        in: query\n        schema: {type: integer, minimum: 1, maximum: 100, default: 50}\n      - name: role\n        in: query\n        schema: {type: string, enum: [admin, user, guest]}\n    responses:\n      '200':\n        description: Successful response\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                users:\n                  type: array\n                  items: {$ref: '#/components/schemas/User'}\n                next_cursor: {type: string, nullable: true}\n            examples:\n              page1:\n                summary: First page of results\n                value:\n                  users: [{id: 1, email: \"alice@example.com\", role: \"admin\"}]\n                  next_cursor: \"eyJpZCI6MX0=\"\n      '401': {$ref: '#/components/responses/Unauthorized'}\n      '429': {$ref: '#/components/responses/RateLimited'}\n```\n\nSchemas (components/schemas):\n- User: id, email, display_name, role, created_at\n- Error: code, message, details\n- PaginationMeta: cursor, limit, has_more\n\nResponse examples:\n- Include success case (200)\n- Include error cases (400, 401, 404, 500)\n- Include edge cases (empty results, max limit exceeded)\n\nRate limiting documentation:\n- Global: 1000 requests/hour per IP\n- Per-endpoint: Varies (auth: 10/min, search: 100/min)\n- Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- 429 response includes Retry-After header\n\nCode generation:\n- Generate TypeScript types: openapi-typescript openapi.yaml -o types/api.ts\n- Generate client SDK: openapi-generator-cli generate -i openapi.yaml -g typescript-axios -o sdk/\n- Validate spec: openapi-generator-cli validate -i openapi.yaml\n\nInteractive documentation:\n- Host Swagger UI: Serve openapi.yaml at https://api.company.com/docs\n- Try it out: Allow users to make test requests directly from docs\n- Authentication: Users can input their JWT token in Swagger UI\n\nVersioning:\n- API version in URL: /v1/users\n- Breaking changes require new version: /v2/users\n- Document deprecated endpoints: deprecated: true, description: \"Use /v2/users instead\"\n\nValidation:\n- Ensure all endpoints documented (compare with actual routes)\n- Ensure all schemas used (no orphaned definitions)\n- Ensure examples valid (match schema)",
        "files_touched": [
          "docs/openapi.yaml",
          "docs/api-reference.md",
          "scripts/generate-docs.sh",
          "docs/swagger-ui.html"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5393362919795819,
        "is_confident": true
      },
      {
        "task_id": "CRIT-UI-01",
        "title": "Fix React form losing data on validation error (state management bug)",
        "description": "Contact form clears all fields when server returns validation error, losing user's work.\n\nBug details:\n- User fills out 10-field contact form (takes 5 minutes)\n- Submit fails with \"Email already registered\" error\n- Form state resets to empty, all data lost\n- Users complaining: \"I had to re-enter everything!\"\n\nRoot cause:\n- Form component calls setFormData({}) on any error response\n- Should preserve form data, only show error message\n- Current code: `onError: () => setFormData(initialFormData)` \u274c\n\nFix approach:\n1. Remove setFormData({}) from error handler\n2. Add auto-save to localStorage every 2 seconds:\n   - Key: `form_draft_contact_${Date.now()}`\n   - Value: JSON.stringify(formData)\n   - Clear localStorage on successful submit\n3. On page load: Restore draft if present (show \"Restore previous draft?\" prompt)\n4. Show inline field errors (don't clear valid fields):\n   - Server returns: {errors: {email: \"Already registered\", phone: \"Invalid format\"}}\n   - Only highlight email and phone fields, preserve other data\n\nAdditional improvements:\n- Add \"Save draft\" button (manual save to localStorage)\n- Show \"*Unsaved changes\" indicator\n- Warn before leaving page: beforeunload event if form has data\n\nTests:\n- Submit with validation error preserves form data\n- Auto-save writes to localStorage every 2s\n- Draft restored on page reload\n- Draft cleared after successful submit\n- beforeunload warns when form has unsaved data",
        "files_touched": [
          "src/components/ContactForm.tsx",
          "src/hooks/useFormPersistence.ts",
          "src/components/ContactForm.test.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5251816220249899,
        "is_confident": true
      },
      {
        "task_id": "IMP-TEST-01",
        "title": "Add Playwright E2E tests for complete user registration flow",
        "description": "Create comprehensive end-to-end tests covering user registration with Playwright.\n\nTest scenarios:\n1. Happy path:\n   - Navigate to /register\n   - Fill form: email, password (8+ chars), confirm password, accept terms\n   - Submit form\n   - Verify \"Check your email\" message\n   - Open email (use Mailhog test SMTP server)\n   - Click verification link\n   - Verify redirect to /login\n   - Login with new credentials\n   - Verify dashboard loads\n\n2. Validation errors:\n   - Test weak password (< 8 chars): Shows \"Password must be 8+ characters\"\n   - Test password mismatch: Shows \"Passwords do not match\"\n   - Test existing email: Shows \"Email already registered\"\n   - Test invalid email format: Shows \"Invalid email address\"\n   - Test missing required fields: All fields highlighted\n\n3. Email verification edge cases:\n   - Expired link (24h): Shows \"Link expired, resend verification\"\n   - Already verified: Redirect to login with \"Already verified\" message\n   - Invalid token: Shows \"Invalid verification link\"\n\n4. Concurrency:\n   - Two users register with same email simultaneously\n   - Only one succeeds, other gets \"Email already registered\"\n\nTest fixtures:\n- users.fixture.ts: Generate random test users\n- smtp.fixture.ts: Mailhog client for reading verification emails\n- Cleanup: Delete test users after each test\n\nPage objects:\n- RegisterPage: fill(), submit(), getError()\n- LoginPage: login()\n- EmailInbox: getVerificationEmail(), clickLink()\n\nAssertions:\n- Form validation messages appear/disappear correctly\n- Network requests succeed (check status 200/400)\n- Email contains correct verification link\n- User can login after verification\n- User data visible on dashboard",
        "files_touched": [
          "e2e/registration.spec.ts",
          "e2e/fixtures/users.ts",
          "e2e/fixtures/smtp.ts",
          "e2e/pages/RegisterPage.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5183226885090317,
        "is_confident": true
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "IMP-UI-02",
      "title": "Implement dark mode with CSS custom properties and system preference detection",
      "description": "Add dark/light theme support with smooth transitions and persistent preference.\n\nTheme implementation:\n- CSS custom properties in :root for colors:\n  ```css\n  :root {\n    --bg-primary: #ffffff;\n    --text-primary: #000000;\n    --border: #e0e0e0;\n  }\n  :root[data-theme=\"dark\"] {\n    --bg-primary: #121212;\n    --text-primary: #ffffff;\n    --border: #333333;\n  }\n  ```\n- All components use: background-color: var(--bg-primary)\n- Smooth transition: transition: background-color 0.3s, color 0.3s\n\nUser preference flow:\n1. On first visit: Detect system preference (prefers-color-scheme: dark)\n2. User toggles theme: Save to localStorage (theme: \"dark\" | \"light\" | \"auto\")\n3. On subsequent visits: Load from localStorage, fall back to system preference\n\nTheme toggle UI:\n- Header button with icon (sun/moon)\n- Three states: Light, Dark, Auto (follows system)\n- Tooltip: \"Light mode\", \"Dark mode\", \"Auto (currently dark)\"\n- Smooth icon transition (fade + rotate)\n\nEdge cases:\n- System preference changes while app open \u2192 update if user has \"auto\"\n- Multiple tabs \u2192 sync theme across tabs (localStorage change event)\n- Print mode \u2192 force light theme (CSS: @media print)\n\nTests:\n- Toggle changes theme immediately\n- Theme persists after page reload\n- System preference respected when \"auto\"\n- All components render correctly in both themes",
      "files_touched": [
        "src/theme/ThemeProvider.tsx",
        "src/theme/theme.css",
        "src/components/ThemeToggle.tsx",
        "src/hooks/useTheme.ts"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "IMP-OBS-02",
        "title": "Build Grafana dashboard for application health with Prometheus metrics",
        "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
        "files_touched": [
          "src/metrics/prometheus.ts",
          "src/metrics/collectors.ts",
          "grafana/dashboard.json",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5259500109510178,
        "is_confident": true
      },
      {
        "task_id": "IMP-API-01",
        "title": "Add GET /api/v1/users endpoint with cursor-based pagination",
        "description": "Implement REST API endpoint for listing users with cursor-based pagination (not offset/limit).\n\nTechnical requirements:\n- Endpoint: GET /api/v1/users?cursor=<id>&limit=50\n- Return fields: id, email, display_name, created_at, role\n- Default limit: 50, max limit: 100\n- Sort by: id ASC (stable ordering for cursor)\n- Response includes next_cursor for pagination\n- Filter support: ?role=admin,user&status=active\n- Return 400 for invalid cursor, 401 for unauthenticated\n\nImplementation approach:\n- Use Prisma ORM with cursor pagination\n- Add index on (id, created_at) for performance\n- Implement CursorPaginationDTO with Zod validation\n- Unit tests: pagination, filtering, edge cases (empty result, last page)\n- OpenAPI spec in docs/api.yaml\n\nAcceptance criteria:\n- Paginate through 10,000 users in <2s total\n- No duplicate users across pages\n- Works with concurrent updates (stable cursor)",
        "files_touched": [
          "src/api/users/list.ts",
          "src/api/users/list.test.ts",
          "src/dto/pagination.ts",
          "docs/api.yaml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5244419895249567,
        "is_confident": true
      },
      {
        "task_id": "IMP-UI-01",
        "title": "Build responsive navigation with mobile hamburger menu (Material UI)",
        "description": "Create responsive navigation component using Material-UI with mobile-first design.\n\nComponent requirements:\n- Desktop (>900px): Horizontal nav bar with logo, links, user menu\n- Mobile (<900px): Hamburger icon, slide-out drawer with links\n- Support nested dropdowns (Account > Profile, Settings, Logout)\n- Active link highlighting (match current route)\n- Keyboard navigation: Tab through links, Enter to activate, Escape to close drawer\n\nTechnical implementation:\n- Material-UI AppBar + Drawer components\n- React Router useLocation for active link detection\n- Animated transitions: slide drawer from left (300ms ease-out)\n- Prevent body scroll when drawer open (CSS: overflow: hidden)\n- Focus trap in drawer (focus cycles through links)\n\nAccessibility (WCAG AA):\n- Hamburger button: aria-label=\"Open navigation menu\", aria-expanded\n- Drawer: role=\"navigation\", aria-labelledby=\"nav-title\"\n- Links: Descriptive text (not \"Click here\")\n- Focus visible indicator (2px outline)\n- Color contrast ratio >4.5:1 (text on background)\n\nResponsive breakpoints:\n- Mobile: <600px (stacked links, larger tap targets 48px)\n- Tablet: 600-900px (compact nav, smaller text)\n- Desktop: >900px (full horizontal layout)\n\nTests:\n- Renders correctly at all breakpoints (visual regression)\n- Keyboard navigation works (tab order, enter, escape)\n- Active link highlights current page\n- Drawer opens/closes with animation",
        "files_touched": [
          "src/components/Navigation.tsx",
          "src/components/Navigation.test.tsx",
          "src/styles/navigation.css",
          "src/components/NavDrawer.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5161140628656594,
        "is_confident": true
      },
      {
        "task_id": "CRIT-API-01",
        "title": "Fix SQL injection vulnerability in search endpoint",
        "description": "CRITICAL: GET /api/v1/products/search?q=<query> is vulnerable to SQL injection.\n\nVulnerability details:\n- Endpoint: GET /api/v1/products/search?q=foo\n- Current code: db.query(`SELECT * FROM products WHERE name LIKE '%${req.query.q}%'`)\n- Attack vector: ?q='; DROP TABLE products; --\n- Confirmed exploitable in production (no damage yet)\n\nFix approach:\n- Replace with parameterized query: db.query('SELECT * FROM products WHERE name LIKE ?', [`%${query}%`])\n- Use Prisma raw query with $1 placeholders\n- Add input validation: alphanumeric + spaces only (reject special chars)\n- Escape wildcards: replace % and _ in user input\n- Add rate limiting: 100 searches/minute per IP\n\nAdditional security:\n- Audit all other endpoints for SQL injection (grep for string concatenation in queries)\n- Add SAST check in CI: semgrep rule for SQL injection patterns\n- Add database user with read-only permissions for search queries\n\nTests:\n- Test injection attempts return 400 Bad Request\n- Test escaped wildcards don't match unintended results\n- Test rate limiting blocks excessive requests",
        "files_touched": [
          "src/api/products/search.ts",
          "src/api/products/search.test.ts",
          "src/db/validation.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.45926788071108027,
        "is_confident": false
      },
      {
        "task_id": "CRIT-UI-01",
        "title": "Fix React form losing data on validation error (state management bug)",
        "description": "Contact form clears all fields when server returns validation error, losing user's work.\n\nBug details:\n- User fills out 10-field contact form (takes 5 minutes)\n- Submit fails with \"Email already registered\" error\n- Form state resets to empty, all data lost\n- Users complaining: \"I had to re-enter everything!\"\n\nRoot cause:\n- Form component calls setFormData({}) on any error response\n- Should preserve form data, only show error message\n- Current code: `onError: () => setFormData(initialFormData)` \u274c\n\nFix approach:\n1. Remove setFormData({}) from error handler\n2. Add auto-save to localStorage every 2 seconds:\n   - Key: `form_draft_contact_${Date.now()}`\n   - Value: JSON.stringify(formData)\n   - Clear localStorage on successful submit\n3. On page load: Restore draft if present (show \"Restore previous draft?\" prompt)\n4. Show inline field errors (don't clear valid fields):\n   - Server returns: {errors: {email: \"Already registered\", phone: \"Invalid format\"}}\n   - Only highlight email and phone fields, preserve other data\n\nAdditional improvements:\n- Add \"Save draft\" button (manual save to localStorage)\n- Show \"*Unsaved changes\" indicator\n- Warn before leaving page: beforeunload event if form has data\n\nTests:\n- Submit with validation error preserves form data\n- Auto-save writes to localStorage every 2s\n- Draft restored on page reload\n- Draft cleared after successful submit\n- beforeunload warns when form has unsaved data",
        "files_touched": [
          "src/components/ContactForm.tsx",
          "src/hooks/useFormPersistence.ts",
          "src/components/ContactForm.test.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.4567078115523203,
        "is_confident": false
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "CRIT-UI-01",
      "title": "Fix React form losing data on validation error (state management bug)",
      "description": "Contact form clears all fields when server returns validation error, losing user's work.\n\nBug details:\n- User fills out 10-field contact form (takes 5 minutes)\n- Submit fails with \"Email already registered\" error\n- Form state resets to empty, all data lost\n- Users complaining: \"I had to re-enter everything!\"\n\nRoot cause:\n- Form component calls setFormData({}) on any error response\n- Should preserve form data, only show error message\n- Current code: `onError: () => setFormData(initialFormData)` \u274c\n\nFix approach:\n1. Remove setFormData({}) from error handler\n2. Add auto-save to localStorage every 2 seconds:\n   - Key: `form_draft_contact_${Date.now()}`\n   - Value: JSON.stringify(formData)\n   - Clear localStorage on successful submit\n3. On page load: Restore draft if present (show \"Restore previous draft?\" prompt)\n4. Show inline field errors (don't clear valid fields):\n   - Server returns: {errors: {email: \"Already registered\", phone: \"Invalid format\"}}\n   - Only highlight email and phone fields, preserve other data\n\nAdditional improvements:\n- Add \"Save draft\" button (manual save to localStorage)\n- Show \"*Unsaved changes\" indicator\n- Warn before leaving page: beforeunload event if form has data\n\nTests:\n- Submit with validation error preserves form data\n- Auto-save writes to localStorage every 2s\n- Draft restored on page reload\n- Draft cleared after successful submit\n- beforeunload warns when form has unsaved data",
      "files_touched": [
        "src/components/ContactForm.tsx",
        "src/hooks/useFormPersistence.ts",
        "src/components/ContactForm.test.tsx"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "IMP-OBS-02",
        "title": "Build Grafana dashboard for application health with Prometheus metrics",
        "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
        "files_touched": [
          "src/metrics/prometheus.ts",
          "src/metrics/collectors.ts",
          "grafana/dashboard.json",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.6595042571419562,
        "is_confident": true
      },
      {
        "task_id": "REFACTOR-02",
        "title": "Migrate callback-based file upload to async/await with streaming",
        "description": "File upload module uses nested callbacks (callback hell), hard to maintain and error-prone.\n\nCurrent code structure (callback pyramid):\n```javascript\nupload.parseMultipart(req, (err, files) => {\n  if (err) return res.status(400).send(err);\n\n  validateFiles(files, (err, validFiles) => {\n    if (err) return res.status(400).send(err);\n\n    storage.uploadToS3(validFiles, (err, urls) => {\n      if (err) return res.status(500).send(err);\n\n      db.saveFileRecords(urls, (err, records) => {\n        if (err) return res.status(500).send(err);\n\n        res.json(records); // Success nested 4 levels deep!\n      });\n    });\n  });\n});\n```\n\nProblems:\n- 4 levels of nesting (hard to read)\n- Error handling duplicated at each level\n- Can't use try/catch (must check err at each callback)\n- Can't use Promise.all for parallel operations\n\nRefactored approach (async/await):\n```javascript\nasync function handleUpload(req, res) {\n  try {\n    const files = await parseMultipart(req);\n    const validFiles = await validateFiles(files);\n    const urls = await uploadToS3(validFiles);\n    const records = await saveFileRecords(urls);\n\n    res.json(records);\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      res.status(400).json({error: error.message});\n    } else {\n      res.status(500).json({error: 'Upload failed'});\n    }\n  }\n}\n```\n\nStreaming improvements:\n- Use streams to avoid loading entire file into memory\n- parseMultipart: Use busboy with streams (process as bytes arrive)\n- uploadToS3: Pipe directly to S3 (no intermediate buffer)\n- Memory usage: 50MB \u2192 5MB for 100MB file upload\n\nError handling improvements:\n- Single try/catch block (centralized error handling)\n- Typed errors: ValidationError, StorageError, DatabaseError\n- Proper cleanup on error: Delete uploaded files, rollback database\n\nProgress tracking:\n- Add upload progress events: req.on('progress', (percent) => sendSSE(percent))\n- Client receives real-time upload progress\n- Cancel upload: req.on('close', () => cleanup())\n\nPerformance:\n- Parallel validation: Use Promise.all to validate multiple files\n- Before: Validate serially (10s for 10 files)\n- After: Validate in parallel (2s for 10 files)\n\nTests:\n- Upload single file: Success\n- Upload multiple files: All succeed\n- Upload with validation error: Reject early, no S3 upload\n- Upload with S3 error: Cleanup temp files\n- Large file upload: Memory usage stays <10MB\n- Cancel upload: Cleanup occurs, no orphaned files",
        "files_touched": [
          "src/upload/file-handler.ts",
          "src/upload/streaming.ts",
          "src/upload/file-handler.test.ts",
          "src/upload/progress.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.616588849833146,
        "is_confident": true
      },
      {
        "task_id": "CRIT-API-01",
        "title": "Fix SQL injection vulnerability in search endpoint",
        "description": "CRITICAL: GET /api/v1/products/search?q=<query> is vulnerable to SQL injection.\n\nVulnerability details:\n- Endpoint: GET /api/v1/products/search?q=foo\n- Current code: db.query(`SELECT * FROM products WHERE name LIKE '%${req.query.q}%'`)\n- Attack vector: ?q='; DROP TABLE products; --\n- Confirmed exploitable in production (no damage yet)\n\nFix approach:\n- Replace with parameterized query: db.query('SELECT * FROM products WHERE name LIKE ?', [`%${query}%`])\n- Use Prisma raw query with $1 placeholders\n- Add input validation: alphanumeric + spaces only (reject special chars)\n- Escape wildcards: replace % and _ in user input\n- Add rate limiting: 100 searches/minute per IP\n\nAdditional security:\n- Audit all other endpoints for SQL injection (grep for string concatenation in queries)\n- Add SAST check in CI: semgrep rule for SQL injection patterns\n- Add database user with read-only permissions for search queries\n\nTests:\n- Test injection attempts return 400 Bad Request\n- Test escaped wildcards don't match unintended results\n- Test rate limiting blocks excessive requests",
        "files_touched": [
          "src/api/products/search.ts",
          "src/api/products/search.test.ts",
          "src/db/validation.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5986898274193144,
        "is_confident": true
      },
      {
        "task_id": "DOC-02",
        "title": "Generate OpenAPI 3.1 specification with request/response examples",
        "description": "Create comprehensive OpenAPI specification for all REST API endpoints with rich examples.\n\nOpenAPI file structure (openapi.yaml):\n\n```yaml\nopenapi: 3.1.0\ninfo:\n  title: Company API\n  version: 1.2.3\n  description: REST API for company platform\n  contact:\n    email: api-team@company.com\nservers:\n  - url: https://api.company.com/v1\n    description: Production\n  - url: https://api-staging.company.com/v1\n    description: Staging\n```\n\nAuthentication:\n- Security scheme: Bearer JWT token\n- Header: Authorization: Bearer <token>\n- Token obtained from POST /auth/login\n- Include security requirement on all protected endpoints\n\nEndpoint documentation (30 endpoints total):\n\nExample: GET /users\n```yaml\n/users:\n  get:\n    summary: List users with pagination\n    operationId: listUsers\n    tags: [Users]\n    parameters:\n      - name: cursor\n        in: query\n        schema: {type: string}\n        description: Pagination cursor from previous response\n      - name: limit\n        in: query\n        schema: {type: integer, minimum: 1, maximum: 100, default: 50}\n      - name: role\n        in: query\n        schema: {type: string, enum: [admin, user, guest]}\n    responses:\n      '200':\n        description: Successful response\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                users:\n                  type: array\n                  items: {$ref: '#/components/schemas/User'}\n                next_cursor: {type: string, nullable: true}\n            examples:\n              page1:\n                summary: First page of results\n                value:\n                  users: [{id: 1, email: \"alice@example.com\", role: \"admin\"}]\n                  next_cursor: \"eyJpZCI6MX0=\"\n      '401': {$ref: '#/components/responses/Unauthorized'}\n      '429': {$ref: '#/components/responses/RateLimited'}\n```\n\nSchemas (components/schemas):\n- User: id, email, display_name, role, created_at\n- Error: code, message, details\n- PaginationMeta: cursor, limit, has_more\n\nResponse examples:\n- Include success case (200)\n- Include error cases (400, 401, 404, 500)\n- Include edge cases (empty results, max limit exceeded)\n\nRate limiting documentation:\n- Global: 1000 requests/hour per IP\n- Per-endpoint: Varies (auth: 10/min, search: 100/min)\n- Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- 429 response includes Retry-After header\n\nCode generation:\n- Generate TypeScript types: openapi-typescript openapi.yaml -o types/api.ts\n- Generate client SDK: openapi-generator-cli generate -i openapi.yaml -g typescript-axios -o sdk/\n- Validate spec: openapi-generator-cli validate -i openapi.yaml\n\nInteractive documentation:\n- Host Swagger UI: Serve openapi.yaml at https://api.company.com/docs\n- Try it out: Allow users to make test requests directly from docs\n- Authentication: Users can input their JWT token in Swagger UI\n\nVersioning:\n- API version in URL: /v1/users\n- Breaking changes require new version: /v2/users\n- Document deprecated endpoints: deprecated: true, description: \"Use /v2/users instead\"\n\nValidation:\n- Ensure all endpoints documented (compare with actual routes)\n- Ensure all schemas used (no orphaned definitions)\n- Ensure examples valid (match schema)",
        "files_touched": [
          "docs/openapi.yaml",
          "docs/api-reference.md",
          "scripts/generate-docs.sh",
          "docs/swagger-ui.html"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5788556795104318,
        "is_confident": true
      },
      {
        "task_id": "IMP-API-02",
        "title": "Implement JWT access/refresh token authentication with Redis",
        "description": "Add JWT-based authentication with access tokens (15min TTL) and refresh tokens (7 day TTL).\n\nTechnical approach:\n- Access token: JWT with user_id, role, issued_at (HS256 signature)\n- Refresh token: Opaque UUID stored in Redis with user_id mapping\n- Middleware: validateAccessToken() extracts claims, attaches to req.user\n- Endpoint: POST /api/v1/auth/refresh (exchange refresh for new access token)\n- Redis key pattern: refresh_token:{uuid} -> {user_id, expires_at}\n- Token rotation: Issue new refresh token on each use (invalidate old)\n\nSecurity requirements:\n- Access token in Authorization: Bearer header\n- Refresh token in httpOnly secure cookie\n- Rate limit: 10 refresh/minute per IP\n- Reject tokens after user logout (blacklist in Redis)\n- Audit log: token issued, refreshed, revoked events\n\nError handling:\n- 401: Token expired, invalid signature, malformed\n- 403: User deactivated, role changed, token blacklisted\n- Include WWW-Authenticate header with error details\n\nTests:\n- Valid token flow\n- Expired token rejection\n- Refresh token rotation\n- Concurrent refresh handling (only one succeeds)",
        "files_touched": [
          "src/middleware/auth.ts",
          "src/auth/tokens.ts",
          "src/auth/tokens.test.ts",
          "src/redis/client.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5479098601998265,
        "is_confident": true
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "IMP-TEST-01",
      "title": "Add Playwright E2E tests for complete user registration flow",
      "description": "Create comprehensive end-to-end tests covering user registration with Playwright.\n\nTest scenarios:\n1. Happy path:\n   - Navigate to /register\n   - Fill form: email, password (8+ chars), confirm password, accept terms\n   - Submit form\n   - Verify \"Check your email\" message\n   - Open email (use Mailhog test SMTP server)\n   - Click verification link\n   - Verify redirect to /login\n   - Login with new credentials\n   - Verify dashboard loads\n\n2. Validation errors:\n   - Test weak password (< 8 chars): Shows \"Password must be 8+ characters\"\n   - Test password mismatch: Shows \"Passwords do not match\"\n   - Test existing email: Shows \"Email already registered\"\n   - Test invalid email format: Shows \"Invalid email address\"\n   - Test missing required fields: All fields highlighted\n\n3. Email verification edge cases:\n   - Expired link (24h): Shows \"Link expired, resend verification\"\n   - Already verified: Redirect to login with \"Already verified\" message\n   - Invalid token: Shows \"Invalid verification link\"\n\n4. Concurrency:\n   - Two users register with same email simultaneously\n   - Only one succeeds, other gets \"Email already registered\"\n\nTest fixtures:\n- users.fixture.ts: Generate random test users\n- smtp.fixture.ts: Mailhog client for reading verification emails\n- Cleanup: Delete test users after each test\n\nPage objects:\n- RegisterPage: fill(), submit(), getError()\n- LoginPage: login()\n- EmailInbox: getVerificationEmail(), clickLink()\n\nAssertions:\n- Form validation messages appear/disappear correctly\n- Network requests succeed (check status 200/400)\n- Email contains correct verification link\n- User can login after verification\n- User data visible on dashboard",
      "files_touched": [
        "e2e/registration.spec.ts",
        "e2e/fixtures/users.ts",
        "e2e/fixtures/smtp.ts",
        "e2e/pages/RegisterPage.ts"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "IMP-OBS-02",
        "title": "Build Grafana dashboard for application health with Prometheus metrics",
        "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
        "files_touched": [
          "src/metrics/prometheus.ts",
          "src/metrics/collectors.ts",
          "grafana/dashboard.json",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5542033497567636,
        "is_confident": true
      },
      {
        "task_id": "DOC-02",
        "title": "Generate OpenAPI 3.1 specification with request/response examples",
        "description": "Create comprehensive OpenAPI specification for all REST API endpoints with rich examples.\n\nOpenAPI file structure (openapi.yaml):\n\n```yaml\nopenapi: 3.1.0\ninfo:\n  title: Company API\n  version: 1.2.3\n  description: REST API for company platform\n  contact:\n    email: api-team@company.com\nservers:\n  - url: https://api.company.com/v1\n    description: Production\n  - url: https://api-staging.company.com/v1\n    description: Staging\n```\n\nAuthentication:\n- Security scheme: Bearer JWT token\n- Header: Authorization: Bearer <token>\n- Token obtained from POST /auth/login\n- Include security requirement on all protected endpoints\n\nEndpoint documentation (30 endpoints total):\n\nExample: GET /users\n```yaml\n/users:\n  get:\n    summary: List users with pagination\n    operationId: listUsers\n    tags: [Users]\n    parameters:\n      - name: cursor\n        in: query\n        schema: {type: string}\n        description: Pagination cursor from previous response\n      - name: limit\n        in: query\n        schema: {type: integer, minimum: 1, maximum: 100, default: 50}\n      - name: role\n        in: query\n        schema: {type: string, enum: [admin, user, guest]}\n    responses:\n      '200':\n        description: Successful response\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                users:\n                  type: array\n                  items: {$ref: '#/components/schemas/User'}\n                next_cursor: {type: string, nullable: true}\n            examples:\n              page1:\n                summary: First page of results\n                value:\n                  users: [{id: 1, email: \"alice@example.com\", role: \"admin\"}]\n                  next_cursor: \"eyJpZCI6MX0=\"\n      '401': {$ref: '#/components/responses/Unauthorized'}\n      '429': {$ref: '#/components/responses/RateLimited'}\n```\n\nSchemas (components/schemas):\n- User: id, email, display_name, role, created_at\n- Error: code, message, details\n- PaginationMeta: cursor, limit, has_more\n\nResponse examples:\n- Include success case (200)\n- Include error cases (400, 401, 404, 500)\n- Include edge cases (empty results, max limit exceeded)\n\nRate limiting documentation:\n- Global: 1000 requests/hour per IP\n- Per-endpoint: Varies (auth: 10/min, search: 100/min)\n- Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- 429 response includes Retry-After header\n\nCode generation:\n- Generate TypeScript types: openapi-typescript openapi.yaml -o types/api.ts\n- Generate client SDK: openapi-generator-cli generate -i openapi.yaml -g typescript-axios -o sdk/\n- Validate spec: openapi-generator-cli validate -i openapi.yaml\n\nInteractive documentation:\n- Host Swagger UI: Serve openapi.yaml at https://api.company.com/docs\n- Try it out: Allow users to make test requests directly from docs\n- Authentication: Users can input their JWT token in Swagger UI\n\nVersioning:\n- API version in URL: /v1/users\n- Breaking changes require new version: /v2/users\n- Document deprecated endpoints: deprecated: true, description: \"Use /v2/users instead\"\n\nValidation:\n- Ensure all endpoints documented (compare with actual routes)\n- Ensure all schemas used (no orphaned definitions)\n- Ensure examples valid (match schema)",
        "files_touched": [
          "docs/openapi.yaml",
          "docs/api-reference.md",
          "scripts/generate-docs.sh",
          "docs/swagger-ui.html"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5363887392981296,
        "is_confident": true
      },
      {
        "task_id": "IMP-UI-01",
        "title": "Build responsive navigation with mobile hamburger menu (Material UI)",
        "description": "Create responsive navigation component using Material-UI with mobile-first design.\n\nComponent requirements:\n- Desktop (>900px): Horizontal nav bar with logo, links, user menu\n- Mobile (<900px): Hamburger icon, slide-out drawer with links\n- Support nested dropdowns (Account > Profile, Settings, Logout)\n- Active link highlighting (match current route)\n- Keyboard navigation: Tab through links, Enter to activate, Escape to close drawer\n\nTechnical implementation:\n- Material-UI AppBar + Drawer components\n- React Router useLocation for active link detection\n- Animated transitions: slide drawer from left (300ms ease-out)\n- Prevent body scroll when drawer open (CSS: overflow: hidden)\n- Focus trap in drawer (focus cycles through links)\n\nAccessibility (WCAG AA):\n- Hamburger button: aria-label=\"Open navigation menu\", aria-expanded\n- Drawer: role=\"navigation\", aria-labelledby=\"nav-title\"\n- Links: Descriptive text (not \"Click here\")\n- Focus visible indicator (2px outline)\n- Color contrast ratio >4.5:1 (text on background)\n\nResponsive breakpoints:\n- Mobile: <600px (stacked links, larger tap targets 48px)\n- Tablet: 600-900px (compact nav, smaller text)\n- Desktop: >900px (full horizontal layout)\n\nTests:\n- Renders correctly at all breakpoints (visual regression)\n- Keyboard navigation works (tab order, enter, escape)\n- Active link highlights current page\n- Drawer opens/closes with animation",
        "files_touched": [
          "src/components/Navigation.tsx",
          "src/components/Navigation.test.tsx",
          "src/styles/navigation.css",
          "src/components/NavDrawer.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5183226885090317,
        "is_confident": true
      },
      {
        "task_id": "IMP-OBS-01",
        "title": "Instrument API layer with OpenTelemetry distributed tracing to Jaeger",
        "description": "Add OpenTelemetry tracing to capture request flows through API \u2192 database \u2192 external services.\n\nInstrumentation approach:\n- Use @opentelemetry/sdk-node for auto-instrumentation\n- Export traces to Jaeger (localhost:14268) via OTLP\n- Capture spans for: HTTP requests, database queries, Redis operations, external API calls\n\nSpan structure:\n- Root span: http.server (entire request/response cycle)\n  - Attributes: http.method, http.url, http.status_code, http.user_agent\n- Child spans:\n  - db.query (for each SQL query): db.statement, db.table, db.duration_ms\n  - redis.operation (get/set/del): redis.key, redis.ttl\n  - http.client (external API calls): http.url, http.method, http.status_code\n\nCustom spans:\n- Add manual spans for business logic: tracer.startSpan('process_order')\n- Add span events: span.addEvent('validation_failed', {reason: 'invalid_email'})\n- Add span links: Link payment span to order span (trace causality)\n\nPerformance:\n- Sampling: 10% of requests in production (100% in dev)\n- Batch export: Buffer 100 spans, flush every 5s\n- Low overhead: <5ms per request (confirmed with benchmark)\n\nConfiguration:\n- Environment variables: OTEL_EXPORTER_JAEGER_ENDPOINT, OTEL_SERVICE_NAME=api-server\n- Graceful degradation: If Jaeger unavailable, log warning and continue\n\nVerification:\n- Generate test traffic\n- Open Jaeger UI (http://localhost:16686)\n- Search for traces, verify complete request flow visible\n- Verify spans show correct duration, attributes, errors\n\nError tracking:\n- Failed requests: span.setStatus(SpanStatusCode.ERROR)\n- Exception details: span.recordException(error)\n- Error rate alert: If >5% requests have error status, alert",
        "files_touched": [
          "src/tracing/tracer.ts",
          "src/middleware/tracing.ts",
          "src/config/otel.ts",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5038708720936244,
        "is_confident": true
      },
      {
        "task_id": "CRIT-UI-01",
        "title": "Fix React form losing data on validation error (state management bug)",
        "description": "Contact form clears all fields when server returns validation error, losing user's work.\n\nBug details:\n- User fills out 10-field contact form (takes 5 minutes)\n- Submit fails with \"Email already registered\" error\n- Form state resets to empty, all data lost\n- Users complaining: \"I had to re-enter everything!\"\n\nRoot cause:\n- Form component calls setFormData({}) on any error response\n- Should preserve form data, only show error message\n- Current code: `onError: () => setFormData(initialFormData)` \u274c\n\nFix approach:\n1. Remove setFormData({}) from error handler\n2. Add auto-save to localStorage every 2 seconds:\n   - Key: `form_draft_contact_${Date.now()}`\n   - Value: JSON.stringify(formData)\n   - Clear localStorage on successful submit\n3. On page load: Restore draft if present (show \"Restore previous draft?\" prompt)\n4. Show inline field errors (don't clear valid fields):\n   - Server returns: {errors: {email: \"Already registered\", phone: \"Invalid format\"}}\n   - Only highlight email and phone fields, preserve other data\n\nAdditional improvements:\n- Add \"Save draft\" button (manual save to localStorage)\n- Show \"*Unsaved changes\" indicator\n- Warn before leaving page: beforeunload event if form has data\n\nTests:\n- Submit with validation error preserves form data\n- Auto-save writes to localStorage every 2s\n- Draft restored on page reload\n- Draft cleared after successful submit\n- beforeunload warns when form has unsaved data",
        "files_touched": [
          "src/components/ContactForm.tsx",
          "src/hooks/useFormPersistence.ts",
          "src/components/ContactForm.test.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.4900016727444803,
        "is_confident": false
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "IMP-TEST-02",
      "title": "Increase payment processing unit test coverage to 95% (focus edge cases)",
      "description": "Expand test coverage for payment module from current 60% to 95%, focusing on error scenarios.\n\nCurrent gaps (from coverage report):\n- PaymentProcessor.processCharge(): 45% covered (missing error paths)\n- RefundManager.partialRefund(): 20% covered (no edge cases tested)\n- CurrencyConverter.convert(): 0% covered (NO TESTS!)\n\nTest scenarios to add:\n\n1. Payment failures:\n   - Card declined (insufficient funds): Verify error code CARD_DECLINED\n   - Card expired: Verify error code EXPIRED_CARD\n   - Invalid CVV: Verify error code INVALID_CVV\n   - Network timeout (5s): Verify retry logic (3 attempts with exponential backoff)\n   - Gateway error 500: Verify fallback to secondary payment provider\n\n2. Partial refunds:\n   - Refund $50 of $100 charge: Verify remaining balance $50\n   - Multiple partial refunds totaling original amount: Verify full refund\n   - Refund exceeds original amount: Throw error \"Refund exceeds charge amount\"\n   - Refund already-refunded charge: Throw error \"Charge already refunded\"\n\n3. Currency conversion:\n   - USD to EUR: Verify exchange rate within 1% of current rate (use ECB API)\n   - Unsupported currency (XYZ): Throw error \"Currency XYZ not supported\"\n   - Conversion with rounding: $10.999 USD \u2192 \u20ac10.00 (round to 2 decimals)\n   - Same currency (USD to USD): Return original amount (no conversion)\n\n4. Concurrency:\n   - Process 100 payments simultaneously: All succeed or fail independently (no race conditions)\n   - Refund same charge twice concurrently: Only one succeeds (use database transaction)\n\nTest utilities:\n- Mock Stripe API responses (use nock or MSW)\n- Test fixtures: createTestCharge(), createTestRefund()\n- Assertions: toHaveBeenCalledWith(expectedParams), toThrow(ExpectedError)\n\nPerformance:\n- All tests complete in <5s (use mocks, no real API calls)\n- Parallel test execution (Jest --maxWorkers=4)",
      "files_touched": [
        "src/payment/processor.test.ts",
        "src/payment/refunds.test.ts",
        "src/payment/currency.test.ts",
        "src/payment/__mocks__/stripe.ts"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "IMP-INFRA-01",
        "title": "Set up GitHub Actions CI/CD with automated testing and blue-green deployment",
        "description": "Automate entire software delivery pipeline: build \u2192 test \u2192 deploy to staging \u2192 deploy to production.\n\nGitHub Actions workflow structure:\n\nWorkflow 1: ci.yml (runs on every PR)\n```yaml\nname: CI\non: [pull_request]\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm run lint  # ESLint + Prettier check\n      - run: npm run typecheck  # TypeScript compiler\n\n  test:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:15\n        env: {POSTGRES_PASSWORD: test}\n      redis:\n        image: redis:7\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm test -- --coverage  # Jest with coverage\n      - uses: codecov/codecov-action@v3  # Upload coverage report\n      - run: npm run test:e2e  # Playwright E2E tests\n\n  security:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm audit --audit-level=high  # Fail on high/critical vulns\n      - uses: snyk/actions/node@master  # Additional security scan\n        env:\n          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}\n\n  build:\n    runs-on: ubuntu-latest\n    needs: [lint, test, security]  # Only build if all checks pass\n    steps:\n      - uses: actions/checkout@v3\n      - run: docker build -t api:${{ github.sha }} .\n      - run: docker push ecr.../api:${{ github.sha }}\n```\n\nWorkflow 2: deploy-staging.yml (runs on merge to main)\n```yaml\nname: Deploy Staging\non:\n  push:\n    branches: [main]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to staging\n        run: |\n          kubectl set image deployment/api-staging api=api:${{ github.sha }}\n          kubectl rollout status deployment/api-staging --timeout=5m\n      - name: Run smoke tests\n        run: npm run test:smoke -- --env staging\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\u2705 Deployed to staging: ${{ github.sha }}\"\n            }\n```\n\nWorkflow 3: deploy-prod.yml (runs on git tag)\n```yaml\nname: Deploy Production\non:\n  push:\n    tags: ['v*']\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    environment: production  # Requires manual approval in GitHub\n    steps:\n      - uses: actions/checkout@v3\n      - name: Blue-green deployment\n        run: |\n          # Deploy to green environment\n          kubectl set image deployment/api-green api=api:${{ github.ref_name }}\n          kubectl rollout status deployment/api-green --timeout=10m\n\n          # Run smoke tests on green\n          npm run test:smoke -- --env green\n\n          # Traffic switch: 0% \u2192 10% \u2192 50% \u2192 100%\n          ./scripts/traffic-switch.sh green 10\n          sleep 300  # Monitor for 5 minutes\n\n          ./scripts/traffic-switch.sh green 50\n          sleep 300\n\n          ./scripts/traffic-switch.sh green 100\n\n          # Scale down blue environment\n          kubectl scale deployment/api-blue --replicas=0\n\n      - name: Create GitHub Release\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: Release ${{ github.ref }}\n          body: |\n            See CHANGELOG.md for details\n\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\ud83d\ude80 Deployed to production: ${{ github.ref_name }}\"\n            }\n```\n\nSecrets configuration:\n- AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY: For ECR push\n- KUBECONFIG: Kubernetes cluster access\n- SNYK_TOKEN: Security scanning\n- SLACK_WEBHOOK_URL: Notifications\n- CODECOV_TOKEN: Coverage upload\n\nBranch protection rules:\n- Require status checks to pass: lint, test, security\n- Require 1 approving review\n- Require linear history (no merge commits)\n- Require signed commits (GPG)\n\nDeployment notifications:\n- Slack: Post to #deployments channel with commit SHA, author, status\n- Email: Send to on-call engineer if production deployment fails\n- PagerDuty: Create incident if deployment fails (rollback required)\n\nRollback procedure:\n- Manual rollback: Re-run deploy workflow with previous git tag\n- Automatic rollback: If smoke tests fail, revert traffic to blue\n\nCost optimization:\n- Use GitHub-hosted runners (free for public repos)\n- Cache npm dependencies: actions/cache@v3 (saves 2 min per build)\n- Cancel redundant runs: concurrency group (auto-cancel old PR runs)\n\nMonitoring:\n- Track deployment frequency: Target 10+ deployments/week\n- Track lead time: PR opened \u2192 production, target <4 hours\n- Track failure rate: Target <5% failed deployments\n- Track MTTR: Mean time to recovery, target <30 minutes",
        "files_touched": [
          ".github/workflows/ci.yml",
          ".github/workflows/deploy-staging.yml",
          ".github/workflows/deploy-prod.yml",
          "scripts/traffic-switch.sh"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.6854532551949154,
        "is_confident": true
      },
      {
        "task_id": "IMP-OBS-02",
        "title": "Build Grafana dashboard for application health with Prometheus metrics",
        "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
        "files_touched": [
          "src/metrics/prometheus.ts",
          "src/metrics/collectors.ts",
          "grafana/dashboard.json",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.584534234444763,
        "is_confident": true
      },
      {
        "task_id": "DOC-02",
        "title": "Generate OpenAPI 3.1 specification with request/response examples",
        "description": "Create comprehensive OpenAPI specification for all REST API endpoints with rich examples.\n\nOpenAPI file structure (openapi.yaml):\n\n```yaml\nopenapi: 3.1.0\ninfo:\n  title: Company API\n  version: 1.2.3\n  description: REST API for company platform\n  contact:\n    email: api-team@company.com\nservers:\n  - url: https://api.company.com/v1\n    description: Production\n  - url: https://api-staging.company.com/v1\n    description: Staging\n```\n\nAuthentication:\n- Security scheme: Bearer JWT token\n- Header: Authorization: Bearer <token>\n- Token obtained from POST /auth/login\n- Include security requirement on all protected endpoints\n\nEndpoint documentation (30 endpoints total):\n\nExample: GET /users\n```yaml\n/users:\n  get:\n    summary: List users with pagination\n    operationId: listUsers\n    tags: [Users]\n    parameters:\n      - name: cursor\n        in: query\n        schema: {type: string}\n        description: Pagination cursor from previous response\n      - name: limit\n        in: query\n        schema: {type: integer, minimum: 1, maximum: 100, default: 50}\n      - name: role\n        in: query\n        schema: {type: string, enum: [admin, user, guest]}\n    responses:\n      '200':\n        description: Successful response\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                users:\n                  type: array\n                  items: {$ref: '#/components/schemas/User'}\n                next_cursor: {type: string, nullable: true}\n            examples:\n              page1:\n                summary: First page of results\n                value:\n                  users: [{id: 1, email: \"alice@example.com\", role: \"admin\"}]\n                  next_cursor: \"eyJpZCI6MX0=\"\n      '401': {$ref: '#/components/responses/Unauthorized'}\n      '429': {$ref: '#/components/responses/RateLimited'}\n```\n\nSchemas (components/schemas):\n- User: id, email, display_name, role, created_at\n- Error: code, message, details\n- PaginationMeta: cursor, limit, has_more\n\nResponse examples:\n- Include success case (200)\n- Include error cases (400, 401, 404, 500)\n- Include edge cases (empty results, max limit exceeded)\n\nRate limiting documentation:\n- Global: 1000 requests/hour per IP\n- Per-endpoint: Varies (auth: 10/min, search: 100/min)\n- Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- 429 response includes Retry-After header\n\nCode generation:\n- Generate TypeScript types: openapi-typescript openapi.yaml -o types/api.ts\n- Generate client SDK: openapi-generator-cli generate -i openapi.yaml -g typescript-axios -o sdk/\n- Validate spec: openapi-generator-cli validate -i openapi.yaml\n\nInteractive documentation:\n- Host Swagger UI: Serve openapi.yaml at https://api.company.com/docs\n- Try it out: Allow users to make test requests directly from docs\n- Authentication: Users can input their JWT token in Swagger UI\n\nVersioning:\n- API version in URL: /v1/users\n- Breaking changes require new version: /v2/users\n- Document deprecated endpoints: deprecated: true, description: \"Use /v2/users instead\"\n\nValidation:\n- Ensure all endpoints documented (compare with actual routes)\n- Ensure all schemas used (no orphaned definitions)\n- Ensure examples valid (match schema)",
        "files_touched": [
          "docs/openapi.yaml",
          "docs/api-reference.md",
          "scripts/generate-docs.sh",
          "docs/swagger-ui.html"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.565895782859834,
        "is_confident": true
      },
      {
        "task_id": "CRIT-OBS-01",
        "title": "Fix memory leak in background job processor (25GB heap growth over 24h)",
        "description": "Worker process memory grows from 500MB to 25GB over 24 hours, crashing with OOM error.\n\nSymptoms:\n- Worker starts: 500MB heap\n- After 24h: 25GB heap (50x growth!)\n- Eventually crashes: \"JavaScript heap out of memory\"\n- Requires manual restart every day\n\nInvestigation steps:\n1. Take heap snapshots: node --expose-gc --max-old-space-size=2048 worker.js\n2. Capture snapshots: Every hour for 24 hours\n3. Analyze with Chrome DevTools Memory Profiler\n4. Compare snapshots: Identify growing objects\n\nFindings (from heap analysis):\n- Retained size: 23GB in Array of Job objects\n- Retaining path: jobQueue \u2192 processedJobs \u2192 Job[]\n- Root cause: processedJobs.push(job) on every job completion, never cleared\n- Jobs accumulate: 1000 jobs/hour * 24 hours = 24,000 jobs * 1MB each = 24GB\n\nFix:\n1. Remove processedJobs array (not needed, jobs logged to database)\n2. Alternative: Limit array size with LRU cache (keep last 1000 jobs only)\n3. Add memory monitoring: Log heap size every minute, alert if >2GB\n\nVerification approach:\n- Run worker for 48 hours with fix\n- Monitor heap size: Should stay flat at ~500MB\n- Load test: Process 100,000 jobs, verify no memory growth\n\nAdditional improvements:\n- Add job.cleanup() method to release resources (close file handles, clear buffers)\n- Use WeakMap for temporary job metadata (auto garbage collected)\n- Set maxJobRetention: 1000 (after 1000 jobs, clear oldest)\n\nMemory profile comparison:\n- Before: 500MB \u2192 25GB over 24h (linear growth)\n- After: 500MB \u2192 520MB over 48h (stable)\n\nTests:\n- Process 10,000 jobs in test, verify heap <1GB\n- Check no memory leaks with --expose-gc and manual GC after each job",
        "files_touched": [
          "src/workers/job-processor.ts",
          "src/workers/cleanup.ts",
          "src/workers/memory-monitor.ts",
          "src/workers/job-processor.test.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5495113232460563,
        "is_confident": true
      },
      {
        "task_id": "REFACTOR-01",
        "title": "Extract email/phone/password validators into shared @company/validators package",
        "description": "Validation logic duplicated across 15 files. Extract into reusable shared package.\n\nCurrent duplication:\n- Email validation: Regex /^[^@]+@[^@]+\\.[^@]+$/ appears in 8 files\n- Phone validation: Regex /^\\+?[1-9]\\d{1,14}$/ appears in 6 files (E.164 format)\n- Password validation: \"8+ chars, uppercase, lowercase, number\" in 12 files\n- Each has slightly different implementation (inconsistent!)\n\nNew package structure:\n- Package: @company/validators\n- Exports: validateEmail(), validatePhone(), validatePassword(), validateURL()\n- TypeScript with type guards: (input: string) => input is ValidEmail\n- Zod integration: emailSchema, phoneSchema, passwordSchema\n\nValidation rules (standardized):\n\n1. Email:\n   - Format: RFC 5322 compliant (use validator.js library)\n   - Max length: 254 characters\n   - Disallow disposable domains (tempmail.com, guerrillamail.com)\n   - Return: {valid: boolean, error?: string}\n\n2. Phone:\n   - Format: E.164 international format (+1234567890)\n   - Use libphonenumber-js for validation\n   - Auto-format: Convert \"(555) 123-4567\" \u2192 \"+15551234567\"\n   - Country code required\n\n3. Password:\n   - Length: 8-128 characters\n   - Requirements: 1 uppercase, 1 lowercase, 1 number, 1 special char (!@#$%^&*)\n   - Reject common passwords (check against top 10k list)\n   - Return strength score: weak/medium/strong\n\n4. URL:\n   - Valid HTTP/HTTPS URL\n   - No localhost or private IPs in production\n   - Max length: 2048 characters\n\nMigration plan:\n1. Publish @company/validators package to private npm registry\n2. Update 15 files to import from package: import {validateEmail} from '@company/validators'\n3. Remove local validation functions\n4. Update tests to use shared validators\n\nBenefits:\n- Single source of truth (no inconsistencies)\n- Easier to update validation rules (change once, affects all services)\n- Comprehensive tests in one place (100% coverage)\n- TypeScript types shared across services\n\nTests:\n- Valid inputs return true\n- Invalid inputs return false with descriptive errors\n- Edge cases: empty string, null, undefined, very long input\n- Locale-specific formats (phone numbers from different countries)",
        "files_touched": [
          "packages/validators/src/email.ts",
          "packages/validators/src/phone.ts",
          "packages/validators/src/password.ts",
          "packages/validators/tests/email.test.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.53782011355656,
        "is_confident": true
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "IMP-OBS-01",
      "title": "Instrument API layer with OpenTelemetry distributed tracing to Jaeger",
      "description": "Add OpenTelemetry tracing to capture request flows through API \u2192 database \u2192 external services.\n\nInstrumentation approach:\n- Use @opentelemetry/sdk-node for auto-instrumentation\n- Export traces to Jaeger (localhost:14268) via OTLP\n- Capture spans for: HTTP requests, database queries, Redis operations, external API calls\n\nSpan structure:\n- Root span: http.server (entire request/response cycle)\n  - Attributes: http.method, http.url, http.status_code, http.user_agent\n- Child spans:\n  - db.query (for each SQL query): db.statement, db.table, db.duration_ms\n  - redis.operation (get/set/del): redis.key, redis.ttl\n  - http.client (external API calls): http.url, http.method, http.status_code\n\nCustom spans:\n- Add manual spans for business logic: tracer.startSpan('process_order')\n- Add span events: span.addEvent('validation_failed', {reason: 'invalid_email'})\n- Add span links: Link payment span to order span (trace causality)\n\nPerformance:\n- Sampling: 10% of requests in production (100% in dev)\n- Batch export: Buffer 100 spans, flush every 5s\n- Low overhead: <5ms per request (confirmed with benchmark)\n\nConfiguration:\n- Environment variables: OTEL_EXPORTER_JAEGER_ENDPOINT, OTEL_SERVICE_NAME=api-server\n- Graceful degradation: If Jaeger unavailable, log warning and continue\n\nVerification:\n- Generate test traffic\n- Open Jaeger UI (http://localhost:16686)\n- Search for traces, verify complete request flow visible\n- Verify spans show correct duration, attributes, errors\n\nError tracking:\n- Failed requests: span.setStatus(SpanStatusCode.ERROR)\n- Exception details: span.recordException(error)\n- Error rate alert: If >5% requests have error status, alert",
      "files_touched": [
        "src/tracing/tracer.ts",
        "src/middleware/tracing.ts",
        "src/config/otel.ts",
        "docker-compose.yml"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "IMP-OBS-02",
        "title": "Build Grafana dashboard for application health with Prometheus metrics",
        "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
        "files_touched": [
          "src/metrics/prometheus.ts",
          "src/metrics/collectors.ts",
          "grafana/dashboard.json",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.6256189349924621,
        "is_confident": true
      },
      {
        "task_id": "IMP-UI-01",
        "title": "Build responsive navigation with mobile hamburger menu (Material UI)",
        "description": "Create responsive navigation component using Material-UI with mobile-first design.\n\nComponent requirements:\n- Desktop (>900px): Horizontal nav bar with logo, links, user menu\n- Mobile (<900px): Hamburger icon, slide-out drawer with links\n- Support nested dropdowns (Account > Profile, Settings, Logout)\n- Active link highlighting (match current route)\n- Keyboard navigation: Tab through links, Enter to activate, Escape to close drawer\n\nTechnical implementation:\n- Material-UI AppBar + Drawer components\n- React Router useLocation for active link detection\n- Animated transitions: slide drawer from left (300ms ease-out)\n- Prevent body scroll when drawer open (CSS: overflow: hidden)\n- Focus trap in drawer (focus cycles through links)\n\nAccessibility (WCAG AA):\n- Hamburger button: aria-label=\"Open navigation menu\", aria-expanded\n- Drawer: role=\"navigation\", aria-labelledby=\"nav-title\"\n- Links: Descriptive text (not \"Click here\")\n- Focus visible indicator (2px outline)\n- Color contrast ratio >4.5:1 (text on background)\n\nResponsive breakpoints:\n- Mobile: <600px (stacked links, larger tap targets 48px)\n- Tablet: 600-900px (compact nav, smaller text)\n- Desktop: >900px (full horizontal layout)\n\nTests:\n- Renders correctly at all breakpoints (visual regression)\n- Keyboard navigation works (tab order, enter, escape)\n- Active link highlights current page\n- Drawer opens/closes with animation",
        "files_touched": [
          "src/components/Navigation.tsx",
          "src/components/Navigation.test.tsx",
          "src/styles/navigation.css",
          "src/components/NavDrawer.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5510216367324134,
        "is_confident": true
      },
      {
        "task_id": "IMP-INFRA-01",
        "title": "Set up GitHub Actions CI/CD with automated testing and blue-green deployment",
        "description": "Automate entire software delivery pipeline: build \u2192 test \u2192 deploy to staging \u2192 deploy to production.\n\nGitHub Actions workflow structure:\n\nWorkflow 1: ci.yml (runs on every PR)\n```yaml\nname: CI\non: [pull_request]\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm run lint  # ESLint + Prettier check\n      - run: npm run typecheck  # TypeScript compiler\n\n  test:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:15\n        env: {POSTGRES_PASSWORD: test}\n      redis:\n        image: redis:7\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm test -- --coverage  # Jest with coverage\n      - uses: codecov/codecov-action@v3  # Upload coverage report\n      - run: npm run test:e2e  # Playwright E2E tests\n\n  security:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm audit --audit-level=high  # Fail on high/critical vulns\n      - uses: snyk/actions/node@master  # Additional security scan\n        env:\n          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}\n\n  build:\n    runs-on: ubuntu-latest\n    needs: [lint, test, security]  # Only build if all checks pass\n    steps:\n      - uses: actions/checkout@v3\n      - run: docker build -t api:${{ github.sha }} .\n      - run: docker push ecr.../api:${{ github.sha }}\n```\n\nWorkflow 2: deploy-staging.yml (runs on merge to main)\n```yaml\nname: Deploy Staging\non:\n  push:\n    branches: [main]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to staging\n        run: |\n          kubectl set image deployment/api-staging api=api:${{ github.sha }}\n          kubectl rollout status deployment/api-staging --timeout=5m\n      - name: Run smoke tests\n        run: npm run test:smoke -- --env staging\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\u2705 Deployed to staging: ${{ github.sha }}\"\n            }\n```\n\nWorkflow 3: deploy-prod.yml (runs on git tag)\n```yaml\nname: Deploy Production\non:\n  push:\n    tags: ['v*']\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    environment: production  # Requires manual approval in GitHub\n    steps:\n      - uses: actions/checkout@v3\n      - name: Blue-green deployment\n        run: |\n          # Deploy to green environment\n          kubectl set image deployment/api-green api=api:${{ github.ref_name }}\n          kubectl rollout status deployment/api-green --timeout=10m\n\n          # Run smoke tests on green\n          npm run test:smoke -- --env green\n\n          # Traffic switch: 0% \u2192 10% \u2192 50% \u2192 100%\n          ./scripts/traffic-switch.sh green 10\n          sleep 300  # Monitor for 5 minutes\n\n          ./scripts/traffic-switch.sh green 50\n          sleep 300\n\n          ./scripts/traffic-switch.sh green 100\n\n          # Scale down blue environment\n          kubectl scale deployment/api-blue --replicas=0\n\n      - name: Create GitHub Release\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: Release ${{ github.ref }}\n          body: |\n            See CHANGELOG.md for details\n\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\ud83d\ude80 Deployed to production: ${{ github.ref_name }}\"\n            }\n```\n\nSecrets configuration:\n- AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY: For ECR push\n- KUBECONFIG: Kubernetes cluster access\n- SNYK_TOKEN: Security scanning\n- SLACK_WEBHOOK_URL: Notifications\n- CODECOV_TOKEN: Coverage upload\n\nBranch protection rules:\n- Require status checks to pass: lint, test, security\n- Require 1 approving review\n- Require linear history (no merge commits)\n- Require signed commits (GPG)\n\nDeployment notifications:\n- Slack: Post to #deployments channel with commit SHA, author, status\n- Email: Send to on-call engineer if production deployment fails\n- PagerDuty: Create incident if deployment fails (rollback required)\n\nRollback procedure:\n- Manual rollback: Re-run deploy workflow with previous git tag\n- Automatic rollback: If smoke tests fail, revert traffic to blue\n\nCost optimization:\n- Use GitHub-hosted runners (free for public repos)\n- Cache npm dependencies: actions/cache@v3 (saves 2 min per build)\n- Cancel redundant runs: concurrency group (auto-cancel old PR runs)\n\nMonitoring:\n- Track deployment frequency: Target 10+ deployments/week\n- Track lead time: PR opened \u2192 production, target <4 hours\n- Track failure rate: Target <5% failed deployments\n- Track MTTR: Mean time to recovery, target <30 minutes",
        "files_touched": [
          ".github/workflows/ci.yml",
          ".github/workflows/deploy-staging.yml",
          ".github/workflows/deploy-prod.yml",
          "scripts/traffic-switch.sh"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5307487828240403,
        "is_confident": true
      },
      {
        "task_id": "DOC-02",
        "title": "Generate OpenAPI 3.1 specification with request/response examples",
        "description": "Create comprehensive OpenAPI specification for all REST API endpoints with rich examples.\n\nOpenAPI file structure (openapi.yaml):\n\n```yaml\nopenapi: 3.1.0\ninfo:\n  title: Company API\n  version: 1.2.3\n  description: REST API for company platform\n  contact:\n    email: api-team@company.com\nservers:\n  - url: https://api.company.com/v1\n    description: Production\n  - url: https://api-staging.company.com/v1\n    description: Staging\n```\n\nAuthentication:\n- Security scheme: Bearer JWT token\n- Header: Authorization: Bearer <token>\n- Token obtained from POST /auth/login\n- Include security requirement on all protected endpoints\n\nEndpoint documentation (30 endpoints total):\n\nExample: GET /users\n```yaml\n/users:\n  get:\n    summary: List users with pagination\n    operationId: listUsers\n    tags: [Users]\n    parameters:\n      - name: cursor\n        in: query\n        schema: {type: string}\n        description: Pagination cursor from previous response\n      - name: limit\n        in: query\n        schema: {type: integer, minimum: 1, maximum: 100, default: 50}\n      - name: role\n        in: query\n        schema: {type: string, enum: [admin, user, guest]}\n    responses:\n      '200':\n        description: Successful response\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                users:\n                  type: array\n                  items: {$ref: '#/components/schemas/User'}\n                next_cursor: {type: string, nullable: true}\n            examples:\n              page1:\n                summary: First page of results\n                value:\n                  users: [{id: 1, email: \"alice@example.com\", role: \"admin\"}]\n                  next_cursor: \"eyJpZCI6MX0=\"\n      '401': {$ref: '#/components/responses/Unauthorized'}\n      '429': {$ref: '#/components/responses/RateLimited'}\n```\n\nSchemas (components/schemas):\n- User: id, email, display_name, role, created_at\n- Error: code, message, details\n- PaginationMeta: cursor, limit, has_more\n\nResponse examples:\n- Include success case (200)\n- Include error cases (400, 401, 404, 500)\n- Include edge cases (empty results, max limit exceeded)\n\nRate limiting documentation:\n- Global: 1000 requests/hour per IP\n- Per-endpoint: Varies (auth: 10/min, search: 100/min)\n- Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- 429 response includes Retry-After header\n\nCode generation:\n- Generate TypeScript types: openapi-typescript openapi.yaml -o types/api.ts\n- Generate client SDK: openapi-generator-cli generate -i openapi.yaml -g typescript-axios -o sdk/\n- Validate spec: openapi-generator-cli validate -i openapi.yaml\n\nInteractive documentation:\n- Host Swagger UI: Serve openapi.yaml at https://api.company.com/docs\n- Try it out: Allow users to make test requests directly from docs\n- Authentication: Users can input their JWT token in Swagger UI\n\nVersioning:\n- API version in URL: /v1/users\n- Breaking changes require new version: /v2/users\n- Document deprecated endpoints: deprecated: true, description: \"Use /v2/users instead\"\n\nValidation:\n- Ensure all endpoints documented (compare with actual routes)\n- Ensure all schemas used (no orphaned definitions)\n- Ensure examples valid (match schema)",
        "files_touched": [
          "docs/openapi.yaml",
          "docs/api-reference.md",
          "scripts/generate-docs.sh",
          "docs/swagger-ui.html"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5266043417213624,
        "is_confident": true
      },
      {
        "task_id": "CRIT-PERF-01",
        "title": "Optimize landing page load time from 8s to <3s (Core Web Vitals)",
        "description": "Landing page loads in 8 seconds with 20MB of unoptimized images, failing Core Web Vitals.\n\nCurrent performance (Lighthouse score):\n- LCP (Largest Contentful Paint): 6.2s (target: <2.5s) \u274c\n- FID (First Input Delay): 180ms (target: <100ms) \u274c\n- CLS (Cumulative Layout Shift): 0.42 (target: <0.1) \u274c\n- Lighthouse score: 32/100 (Poor)\n\nPerformance bottlenecks (from DevTools):\n1. Images: 20MB total, 12 images at full resolution (4000x3000px)\n2. JavaScript: 2MB bundle size (React, unused libraries)\n3. Fonts: 800KB custom fonts loading blocking render\n4. No caching: Every visit downloads everything again\n\nOptimization plan:\n\n1. Image optimization:\n   - Convert to WebP format (70% size reduction)\n   - Serve responsive images with srcset:\n     ```html\n     <img\n       src=\"hero-800w.webp\"\n       srcset=\"hero-400w.webp 400w, hero-800w.webp 800w, hero-1200w.webp 1200w\"\n       sizes=\"(max-width: 600px) 400px, (max-width: 1200px) 800px, 1200px\"\n       loading=\"lazy\"\n       decoding=\"async\"\n     />\n     ```\n   - Lazy load below-fold images (loading=\"lazy\")\n   - Add CDN caching (Cloudflare): Cache-Control: max-age=31536000, immutable\n   - Expected: 20MB \u2192 2MB (10x reduction)\n\n2. Code splitting:\n   - Split bundle by route: React.lazy(() => import('./About'))\n   - Load above-fold code first (~100KB initial bundle)\n   - Defer non-critical scripts: <script defer src=\"analytics.js\">\n   - Tree-shake unused code: Check webpack-bundle-analyzer\n   - Expected: 2MB \u2192 300KB initial load (6x reduction)\n\n3. Font optimization:\n   - Use font-display: swap (show fallback font immediately)\n   - Preload critical fonts: <link rel=\"preload\" as=\"font\" href=\"font.woff2\">\n   - Subset fonts (Latin characters only): 800KB \u2192 80KB\n   - Use system fonts for body text (zero load time)\n\n4. Caching strategy:\n   - Service Worker: Cache static assets for offline use\n   - HTTP headers: Cache-Control: max-age=31536000 for immutable assets\n   - Use content hashing in filenames: hero-abc123.webp (cache forever)\n\n5. Critical CSS:\n   - Inline above-fold CSS in <head> (~10KB)\n   - Defer non-critical CSS: <link rel=\"preload\" as=\"style\" href=\"main.css\">\n   - Remove unused CSS: Use PurgeCSS (50KB \u2192 8KB)\n\nImplementation steps:\n1. Image processing: Use sharp library to generate WebP + multiple sizes\n2. Update image components: Use <picture> element with WebP + JPEG fallback\n3. Webpack config: Add code splitting, bundle analyzer\n4. Font subsetting: Use pyftsubset to extract Latin glyphs\n5. Deploy behind Cloudflare CDN with caching rules\n\nVerification:\n- Run Lighthouse in CI: Fail build if score <90\n- Test on real devices: iPhone 12, Pixel 5 (3G connection)\n- Measure field data: Send Core Web Vitals to analytics (real user monitoring)\n- Compare before/after:\n  - LCP: 6.2s \u2192 1.8s \u2705\n  - FID: 180ms \u2192 45ms \u2705\n  - CLS: 0.42 \u2192 0.05 \u2705\n  - Lighthouse: 32 \u2192 95 \u2705",
        "files_touched": [
          "src/components/ImageOptimizer.tsx",
          "webpack.config.js",
          "src/utils/image-optimizer.ts",
          "scripts/optimize-images.sh"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5086115674797661,
        "is_confident": true
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "IMP-OBS-02",
      "title": "Build Grafana dashboard for application health with Prometheus metrics",
      "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
      "files_touched": [
        "src/metrics/prometheus.ts",
        "src/metrics/collectors.ts",
        "grafana/dashboard.json",
        "docker-compose.yml"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "DOC-02",
        "title": "Generate OpenAPI 3.1 specification with request/response examples",
        "description": "Create comprehensive OpenAPI specification for all REST API endpoints with rich examples.\n\nOpenAPI file structure (openapi.yaml):\n\n```yaml\nopenapi: 3.1.0\ninfo:\n  title: Company API\n  version: 1.2.3\n  description: REST API for company platform\n  contact:\n    email: api-team@company.com\nservers:\n  - url: https://api.company.com/v1\n    description: Production\n  - url: https://api-staging.company.com/v1\n    description: Staging\n```\n\nAuthentication:\n- Security scheme: Bearer JWT token\n- Header: Authorization: Bearer <token>\n- Token obtained from POST /auth/login\n- Include security requirement on all protected endpoints\n\nEndpoint documentation (30 endpoints total):\n\nExample: GET /users\n```yaml\n/users:\n  get:\n    summary: List users with pagination\n    operationId: listUsers\n    tags: [Users]\n    parameters:\n      - name: cursor\n        in: query\n        schema: {type: string}\n        description: Pagination cursor from previous response\n      - name: limit\n        in: query\n        schema: {type: integer, minimum: 1, maximum: 100, default: 50}\n      - name: role\n        in: query\n        schema: {type: string, enum: [admin, user, guest]}\n    responses:\n      '200':\n        description: Successful response\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                users:\n                  type: array\n                  items: {$ref: '#/components/schemas/User'}\n                next_cursor: {type: string, nullable: true}\n            examples:\n              page1:\n                summary: First page of results\n                value:\n                  users: [{id: 1, email: \"alice@example.com\", role: \"admin\"}]\n                  next_cursor: \"eyJpZCI6MX0=\"\n      '401': {$ref: '#/components/responses/Unauthorized'}\n      '429': {$ref: '#/components/responses/RateLimited'}\n```\n\nSchemas (components/schemas):\n- User: id, email, display_name, role, created_at\n- Error: code, message, details\n- PaginationMeta: cursor, limit, has_more\n\nResponse examples:\n- Include success case (200)\n- Include error cases (400, 401, 404, 500)\n- Include edge cases (empty results, max limit exceeded)\n\nRate limiting documentation:\n- Global: 1000 requests/hour per IP\n- Per-endpoint: Varies (auth: 10/min, search: 100/min)\n- Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- 429 response includes Retry-After header\n\nCode generation:\n- Generate TypeScript types: openapi-typescript openapi.yaml -o types/api.ts\n- Generate client SDK: openapi-generator-cli generate -i openapi.yaml -g typescript-axios -o sdk/\n- Validate spec: openapi-generator-cli validate -i openapi.yaml\n\nInteractive documentation:\n- Host Swagger UI: Serve openapi.yaml at https://api.company.com/docs\n- Try it out: Allow users to make test requests directly from docs\n- Authentication: Users can input their JWT token in Swagger UI\n\nVersioning:\n- API version in URL: /v1/users\n- Breaking changes require new version: /v2/users\n- Document deprecated endpoints: deprecated: true, description: \"Use /v2/users instead\"\n\nValidation:\n- Ensure all endpoints documented (compare with actual routes)\n- Ensure all schemas used (no orphaned definitions)\n- Ensure examples valid (match schema)",
        "files_touched": [
          "docs/openapi.yaml",
          "docs/api-reference.md",
          "scripts/generate-docs.sh",
          "docs/swagger-ui.html"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.6653934995226963,
        "is_confident": true
      },
      {
        "task_id": "CRIT-UI-01",
        "title": "Fix React form losing data on validation error (state management bug)",
        "description": "Contact form clears all fields when server returns validation error, losing user's work.\n\nBug details:\n- User fills out 10-field contact form (takes 5 minutes)\n- Submit fails with \"Email already registered\" error\n- Form state resets to empty, all data lost\n- Users complaining: \"I had to re-enter everything!\"\n\nRoot cause:\n- Form component calls setFormData({}) on any error response\n- Should preserve form data, only show error message\n- Current code: `onError: () => setFormData(initialFormData)` \u274c\n\nFix approach:\n1. Remove setFormData({}) from error handler\n2. Add auto-save to localStorage every 2 seconds:\n   - Key: `form_draft_contact_${Date.now()}`\n   - Value: JSON.stringify(formData)\n   - Clear localStorage on successful submit\n3. On page load: Restore draft if present (show \"Restore previous draft?\" prompt)\n4. Show inline field errors (don't clear valid fields):\n   - Server returns: {errors: {email: \"Already registered\", phone: \"Invalid format\"}}\n   - Only highlight email and phone fields, preserve other data\n\nAdditional improvements:\n- Add \"Save draft\" button (manual save to localStorage)\n- Show \"*Unsaved changes\" indicator\n- Warn before leaving page: beforeunload event if form has data\n\nTests:\n- Submit with validation error preserves form data\n- Auto-save writes to localStorage every 2s\n- Draft restored on page reload\n- Draft cleared after successful submit\n- beforeunload warns when form has unsaved data",
        "files_touched": [
          "src/components/ContactForm.tsx",
          "src/hooks/useFormPersistence.ts",
          "src/components/ContactForm.test.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.6595042571419562,
        "is_confident": true
      },
      {
        "task_id": "IMP-INFRA-01",
        "title": "Set up GitHub Actions CI/CD with automated testing and blue-green deployment",
        "description": "Automate entire software delivery pipeline: build \u2192 test \u2192 deploy to staging \u2192 deploy to production.\n\nGitHub Actions workflow structure:\n\nWorkflow 1: ci.yml (runs on every PR)\n```yaml\nname: CI\non: [pull_request]\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm run lint  # ESLint + Prettier check\n      - run: npm run typecheck  # TypeScript compiler\n\n  test:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:15\n        env: {POSTGRES_PASSWORD: test}\n      redis:\n        image: redis:7\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm test -- --coverage  # Jest with coverage\n      - uses: codecov/codecov-action@v3  # Upload coverage report\n      - run: npm run test:e2e  # Playwright E2E tests\n\n  security:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm audit --audit-level=high  # Fail on high/critical vulns\n      - uses: snyk/actions/node@master  # Additional security scan\n        env:\n          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}\n\n  build:\n    runs-on: ubuntu-latest\n    needs: [lint, test, security]  # Only build if all checks pass\n    steps:\n      - uses: actions/checkout@v3\n      - run: docker build -t api:${{ github.sha }} .\n      - run: docker push ecr.../api:${{ github.sha }}\n```\n\nWorkflow 2: deploy-staging.yml (runs on merge to main)\n```yaml\nname: Deploy Staging\non:\n  push:\n    branches: [main]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to staging\n        run: |\n          kubectl set image deployment/api-staging api=api:${{ github.sha }}\n          kubectl rollout status deployment/api-staging --timeout=5m\n      - name: Run smoke tests\n        run: npm run test:smoke -- --env staging\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\u2705 Deployed to staging: ${{ github.sha }}\"\n            }\n```\n\nWorkflow 3: deploy-prod.yml (runs on git tag)\n```yaml\nname: Deploy Production\non:\n  push:\n    tags: ['v*']\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    environment: production  # Requires manual approval in GitHub\n    steps:\n      - uses: actions/checkout@v3\n      - name: Blue-green deployment\n        run: |\n          # Deploy to green environment\n          kubectl set image deployment/api-green api=api:${{ github.ref_name }}\n          kubectl rollout status deployment/api-green --timeout=10m\n\n          # Run smoke tests on green\n          npm run test:smoke -- --env green\n\n          # Traffic switch: 0% \u2192 10% \u2192 50% \u2192 100%\n          ./scripts/traffic-switch.sh green 10\n          sleep 300  # Monitor for 5 minutes\n\n          ./scripts/traffic-switch.sh green 50\n          sleep 300\n\n          ./scripts/traffic-switch.sh green 100\n\n          # Scale down blue environment\n          kubectl scale deployment/api-blue --replicas=0\n\n      - name: Create GitHub Release\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: Release ${{ github.ref }}\n          body: |\n            See CHANGELOG.md for details\n\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\ud83d\ude80 Deployed to production: ${{ github.ref_name }}\"\n            }\n```\n\nSecrets configuration:\n- AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY: For ECR push\n- KUBECONFIG: Kubernetes cluster access\n- SNYK_TOKEN: Security scanning\n- SLACK_WEBHOOK_URL: Notifications\n- CODECOV_TOKEN: Coverage upload\n\nBranch protection rules:\n- Require status checks to pass: lint, test, security\n- Require 1 approving review\n- Require linear history (no merge commits)\n- Require signed commits (GPG)\n\nDeployment notifications:\n- Slack: Post to #deployments channel with commit SHA, author, status\n- Email: Send to on-call engineer if production deployment fails\n- PagerDuty: Create incident if deployment fails (rollback required)\n\nRollback procedure:\n- Manual rollback: Re-run deploy workflow with previous git tag\n- Automatic rollback: If smoke tests fail, revert traffic to blue\n\nCost optimization:\n- Use GitHub-hosted runners (free for public repos)\n- Cache npm dependencies: actions/cache@v3 (saves 2 min per build)\n- Cancel redundant runs: concurrency group (auto-cancel old PR runs)\n\nMonitoring:\n- Track deployment frequency: Target 10+ deployments/week\n- Track lead time: PR opened \u2192 production, target <4 hours\n- Track failure rate: Target <5% failed deployments\n- Track MTTR: Mean time to recovery, target <30 minutes",
        "files_touched": [
          ".github/workflows/ci.yml",
          ".github/workflows/deploy-staging.yml",
          ".github/workflows/deploy-prod.yml",
          "scripts/traffic-switch.sh"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.6563739313660778,
        "is_confident": true
      },
      {
        "task_id": "IMP-UI-01",
        "title": "Build responsive navigation with mobile hamburger menu (Material UI)",
        "description": "Create responsive navigation component using Material-UI with mobile-first design.\n\nComponent requirements:\n- Desktop (>900px): Horizontal nav bar with logo, links, user menu\n- Mobile (<900px): Hamburger icon, slide-out drawer with links\n- Support nested dropdowns (Account > Profile, Settings, Logout)\n- Active link highlighting (match current route)\n- Keyboard navigation: Tab through links, Enter to activate, Escape to close drawer\n\nTechnical implementation:\n- Material-UI AppBar + Drawer components\n- React Router useLocation for active link detection\n- Animated transitions: slide drawer from left (300ms ease-out)\n- Prevent body scroll when drawer open (CSS: overflow: hidden)\n- Focus trap in drawer (focus cycles through links)\n\nAccessibility (WCAG AA):\n- Hamburger button: aria-label=\"Open navigation menu\", aria-expanded\n- Drawer: role=\"navigation\", aria-labelledby=\"nav-title\"\n- Links: Descriptive text (not \"Click here\")\n- Focus visible indicator (2px outline)\n- Color contrast ratio >4.5:1 (text on background)\n\nResponsive breakpoints:\n- Mobile: <600px (stacked links, larger tap targets 48px)\n- Tablet: 600-900px (compact nav, smaller text)\n- Desktop: >900px (full horizontal layout)\n\nTests:\n- Renders correctly at all breakpoints (visual regression)\n- Keyboard navigation works (tab order, enter, escape)\n- Active link highlights current page\n- Drawer opens/closes with animation",
        "files_touched": [
          "src/components/Navigation.tsx",
          "src/components/Navigation.test.tsx",
          "src/styles/navigation.css",
          "src/components/NavDrawer.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.6504772334073105,
        "is_confident": true
      },
      {
        "task_id": "IMP-OBS-01",
        "title": "Instrument API layer with OpenTelemetry distributed tracing to Jaeger",
        "description": "Add OpenTelemetry tracing to capture request flows through API \u2192 database \u2192 external services.\n\nInstrumentation approach:\n- Use @opentelemetry/sdk-node for auto-instrumentation\n- Export traces to Jaeger (localhost:14268) via OTLP\n- Capture spans for: HTTP requests, database queries, Redis operations, external API calls\n\nSpan structure:\n- Root span: http.server (entire request/response cycle)\n  - Attributes: http.method, http.url, http.status_code, http.user_agent\n- Child spans:\n  - db.query (for each SQL query): db.statement, db.table, db.duration_ms\n  - redis.operation (get/set/del): redis.key, redis.ttl\n  - http.client (external API calls): http.url, http.method, http.status_code\n\nCustom spans:\n- Add manual spans for business logic: tracer.startSpan('process_order')\n- Add span events: span.addEvent('validation_failed', {reason: 'invalid_email'})\n- Add span links: Link payment span to order span (trace causality)\n\nPerformance:\n- Sampling: 10% of requests in production (100% in dev)\n- Batch export: Buffer 100 spans, flush every 5s\n- Low overhead: <5ms per request (confirmed with benchmark)\n\nConfiguration:\n- Environment variables: OTEL_EXPORTER_JAEGER_ENDPOINT, OTEL_SERVICE_NAME=api-server\n- Graceful degradation: If Jaeger unavailable, log warning and continue\n\nVerification:\n- Generate test traffic\n- Open Jaeger UI (http://localhost:16686)\n- Search for traces, verify complete request flow visible\n- Verify spans show correct duration, attributes, errors\n\nError tracking:\n- Failed requests: span.setStatus(SpanStatusCode.ERROR)\n- Exception details: span.recordException(error)\n- Error rate alert: If >5% requests have error status, alert",
        "files_touched": [
          "src/tracing/tracer.ts",
          "src/middleware/tracing.ts",
          "src/config/otel.ts",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.6256189349924621,
        "is_confident": true
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "CRIT-OBS-01",
      "title": "Fix memory leak in background job processor (25GB heap growth over 24h)",
      "description": "Worker process memory grows from 500MB to 25GB over 24 hours, crashing with OOM error.\n\nSymptoms:\n- Worker starts: 500MB heap\n- After 24h: 25GB heap (50x growth!)\n- Eventually crashes: \"JavaScript heap out of memory\"\n- Requires manual restart every day\n\nInvestigation steps:\n1. Take heap snapshots: node --expose-gc --max-old-space-size=2048 worker.js\n2. Capture snapshots: Every hour for 24 hours\n3. Analyze with Chrome DevTools Memory Profiler\n4. Compare snapshots: Identify growing objects\n\nFindings (from heap analysis):\n- Retained size: 23GB in Array of Job objects\n- Retaining path: jobQueue \u2192 processedJobs \u2192 Job[]\n- Root cause: processedJobs.push(job) on every job completion, never cleared\n- Jobs accumulate: 1000 jobs/hour * 24 hours = 24,000 jobs * 1MB each = 24GB\n\nFix:\n1. Remove processedJobs array (not needed, jobs logged to database)\n2. Alternative: Limit array size with LRU cache (keep last 1000 jobs only)\n3. Add memory monitoring: Log heap size every minute, alert if >2GB\n\nVerification approach:\n- Run worker for 48 hours with fix\n- Monitor heap size: Should stay flat at ~500MB\n- Load test: Process 100,000 jobs, verify no memory growth\n\nAdditional improvements:\n- Add job.cleanup() method to release resources (close file handles, clear buffers)\n- Use WeakMap for temporary job metadata (auto garbage collected)\n- Set maxJobRetention: 1000 (after 1000 jobs, clear oldest)\n\nMemory profile comparison:\n- Before: 500MB \u2192 25GB over 24h (linear growth)\n- After: 500MB \u2192 520MB over 48h (stable)\n\nTests:\n- Process 10,000 jobs in test, verify heap <1GB\n- Check no memory leaks with --expose-gc and manual GC after each job",
      "files_touched": [
        "src/workers/job-processor.ts",
        "src/workers/cleanup.ts",
        "src/workers/memory-monitor.ts",
        "src/workers/job-processor.test.ts"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "IMP-INFRA-01",
        "title": "Set up GitHub Actions CI/CD with automated testing and blue-green deployment",
        "description": "Automate entire software delivery pipeline: build \u2192 test \u2192 deploy to staging \u2192 deploy to production.\n\nGitHub Actions workflow structure:\n\nWorkflow 1: ci.yml (runs on every PR)\n```yaml\nname: CI\non: [pull_request]\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm run lint  # ESLint + Prettier check\n      - run: npm run typecheck  # TypeScript compiler\n\n  test:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:15\n        env: {POSTGRES_PASSWORD: test}\n      redis:\n        image: redis:7\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm test -- --coverage  # Jest with coverage\n      - uses: codecov/codecov-action@v3  # Upload coverage report\n      - run: npm run test:e2e  # Playwright E2E tests\n\n  security:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm audit --audit-level=high  # Fail on high/critical vulns\n      - uses: snyk/actions/node@master  # Additional security scan\n        env:\n          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}\n\n  build:\n    runs-on: ubuntu-latest\n    needs: [lint, test, security]  # Only build if all checks pass\n    steps:\n      - uses: actions/checkout@v3\n      - run: docker build -t api:${{ github.sha }} .\n      - run: docker push ecr.../api:${{ github.sha }}\n```\n\nWorkflow 2: deploy-staging.yml (runs on merge to main)\n```yaml\nname: Deploy Staging\non:\n  push:\n    branches: [main]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to staging\n        run: |\n          kubectl set image deployment/api-staging api=api:${{ github.sha }}\n          kubectl rollout status deployment/api-staging --timeout=5m\n      - name: Run smoke tests\n        run: npm run test:smoke -- --env staging\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\u2705 Deployed to staging: ${{ github.sha }}\"\n            }\n```\n\nWorkflow 3: deploy-prod.yml (runs on git tag)\n```yaml\nname: Deploy Production\non:\n  push:\n    tags: ['v*']\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    environment: production  # Requires manual approval in GitHub\n    steps:\n      - uses: actions/checkout@v3\n      - name: Blue-green deployment\n        run: |\n          # Deploy to green environment\n          kubectl set image deployment/api-green api=api:${{ github.ref_name }}\n          kubectl rollout status deployment/api-green --timeout=10m\n\n          # Run smoke tests on green\n          npm run test:smoke -- --env green\n\n          # Traffic switch: 0% \u2192 10% \u2192 50% \u2192 100%\n          ./scripts/traffic-switch.sh green 10\n          sleep 300  # Monitor for 5 minutes\n\n          ./scripts/traffic-switch.sh green 50\n          sleep 300\n\n          ./scripts/traffic-switch.sh green 100\n\n          # Scale down blue environment\n          kubectl scale deployment/api-blue --replicas=0\n\n      - name: Create GitHub Release\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: Release ${{ github.ref }}\n          body: |\n            See CHANGELOG.md for details\n\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\ud83d\ude80 Deployed to production: ${{ github.ref_name }}\"\n            }\n```\n\nSecrets configuration:\n- AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY: For ECR push\n- KUBECONFIG: Kubernetes cluster access\n- SNYK_TOKEN: Security scanning\n- SLACK_WEBHOOK_URL: Notifications\n- CODECOV_TOKEN: Coverage upload\n\nBranch protection rules:\n- Require status checks to pass: lint, test, security\n- Require 1 approving review\n- Require linear history (no merge commits)\n- Require signed commits (GPG)\n\nDeployment notifications:\n- Slack: Post to #deployments channel with commit SHA, author, status\n- Email: Send to on-call engineer if production deployment fails\n- PagerDuty: Create incident if deployment fails (rollback required)\n\nRollback procedure:\n- Manual rollback: Re-run deploy workflow with previous git tag\n- Automatic rollback: If smoke tests fail, revert traffic to blue\n\nCost optimization:\n- Use GitHub-hosted runners (free for public repos)\n- Cache npm dependencies: actions/cache@v3 (saves 2 min per build)\n- Cancel redundant runs: concurrency group (auto-cancel old PR runs)\n\nMonitoring:\n- Track deployment frequency: Target 10+ deployments/week\n- Track lead time: PR opened \u2192 production, target <4 hours\n- Track failure rate: Target <5% failed deployments\n- Track MTTR: Mean time to recovery, target <30 minutes",
        "files_touched": [
          ".github/workflows/ci.yml",
          ".github/workflows/deploy-staging.yml",
          ".github/workflows/deploy-prod.yml",
          "scripts/traffic-switch.sh"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5694650446175011,
        "is_confident": true
      },
      {
        "task_id": "IMP-TEST-02",
        "title": "Increase payment processing unit test coverage to 95% (focus edge cases)",
        "description": "Expand test coverage for payment module from current 60% to 95%, focusing on error scenarios.\n\nCurrent gaps (from coverage report):\n- PaymentProcessor.processCharge(): 45% covered (missing error paths)\n- RefundManager.partialRefund(): 20% covered (no edge cases tested)\n- CurrencyConverter.convert(): 0% covered (NO TESTS!)\n\nTest scenarios to add:\n\n1. Payment failures:\n   - Card declined (insufficient funds): Verify error code CARD_DECLINED\n   - Card expired: Verify error code EXPIRED_CARD\n   - Invalid CVV: Verify error code INVALID_CVV\n   - Network timeout (5s): Verify retry logic (3 attempts with exponential backoff)\n   - Gateway error 500: Verify fallback to secondary payment provider\n\n2. Partial refunds:\n   - Refund $50 of $100 charge: Verify remaining balance $50\n   - Multiple partial refunds totaling original amount: Verify full refund\n   - Refund exceeds original amount: Throw error \"Refund exceeds charge amount\"\n   - Refund already-refunded charge: Throw error \"Charge already refunded\"\n\n3. Currency conversion:\n   - USD to EUR: Verify exchange rate within 1% of current rate (use ECB API)\n   - Unsupported currency (XYZ): Throw error \"Currency XYZ not supported\"\n   - Conversion with rounding: $10.999 USD \u2192 \u20ac10.00 (round to 2 decimals)\n   - Same currency (USD to USD): Return original amount (no conversion)\n\n4. Concurrency:\n   - Process 100 payments simultaneously: All succeed or fail independently (no race conditions)\n   - Refund same charge twice concurrently: Only one succeeds (use database transaction)\n\nTest utilities:\n- Mock Stripe API responses (use nock or MSW)\n- Test fixtures: createTestCharge(), createTestRefund()\n- Assertions: toHaveBeenCalledWith(expectedParams), toThrow(ExpectedError)\n\nPerformance:\n- All tests complete in <5s (use mocks, no real API calls)\n- Parallel test execution (Jest --maxWorkers=4)",
        "files_touched": [
          "src/payment/processor.test.ts",
          "src/payment/refunds.test.ts",
          "src/payment/currency.test.ts",
          "src/payment/__mocks__/stripe.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5495113232460563,
        "is_confident": true
      },
      {
        "task_id": "IMP-OBS-02",
        "title": "Build Grafana dashboard for application health with Prometheus metrics",
        "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
        "files_touched": [
          "src/metrics/prometheus.ts",
          "src/metrics/collectors.ts",
          "grafana/dashboard.json",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5379380581365059,
        "is_confident": true
      },
      {
        "task_id": "DOC-02",
        "title": "Generate OpenAPI 3.1 specification with request/response examples",
        "description": "Create comprehensive OpenAPI specification for all REST API endpoints with rich examples.\n\nOpenAPI file structure (openapi.yaml):\n\n```yaml\nopenapi: 3.1.0\ninfo:\n  title: Company API\n  version: 1.2.3\n  description: REST API for company platform\n  contact:\n    email: api-team@company.com\nservers:\n  - url: https://api.company.com/v1\n    description: Production\n  - url: https://api-staging.company.com/v1\n    description: Staging\n```\n\nAuthentication:\n- Security scheme: Bearer JWT token\n- Header: Authorization: Bearer <token>\n- Token obtained from POST /auth/login\n- Include security requirement on all protected endpoints\n\nEndpoint documentation (30 endpoints total):\n\nExample: GET /users\n```yaml\n/users:\n  get:\n    summary: List users with pagination\n    operationId: listUsers\n    tags: [Users]\n    parameters:\n      - name: cursor\n        in: query\n        schema: {type: string}\n        description: Pagination cursor from previous response\n      - name: limit\n        in: query\n        schema: {type: integer, minimum: 1, maximum: 100, default: 50}\n      - name: role\n        in: query\n        schema: {type: string, enum: [admin, user, guest]}\n    responses:\n      '200':\n        description: Successful response\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                users:\n                  type: array\n                  items: {$ref: '#/components/schemas/User'}\n                next_cursor: {type: string, nullable: true}\n            examples:\n              page1:\n                summary: First page of results\n                value:\n                  users: [{id: 1, email: \"alice@example.com\", role: \"admin\"}]\n                  next_cursor: \"eyJpZCI6MX0=\"\n      '401': {$ref: '#/components/responses/Unauthorized'}\n      '429': {$ref: '#/components/responses/RateLimited'}\n```\n\nSchemas (components/schemas):\n- User: id, email, display_name, role, created_at\n- Error: code, message, details\n- PaginationMeta: cursor, limit, has_more\n\nResponse examples:\n- Include success case (200)\n- Include error cases (400, 401, 404, 500)\n- Include edge cases (empty results, max limit exceeded)\n\nRate limiting documentation:\n- Global: 1000 requests/hour per IP\n- Per-endpoint: Varies (auth: 10/min, search: 100/min)\n- Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- 429 response includes Retry-After header\n\nCode generation:\n- Generate TypeScript types: openapi-typescript openapi.yaml -o types/api.ts\n- Generate client SDK: openapi-generator-cli generate -i openapi.yaml -g typescript-axios -o sdk/\n- Validate spec: openapi-generator-cli validate -i openapi.yaml\n\nInteractive documentation:\n- Host Swagger UI: Serve openapi.yaml at https://api.company.com/docs\n- Try it out: Allow users to make test requests directly from docs\n- Authentication: Users can input their JWT token in Swagger UI\n\nVersioning:\n- API version in URL: /v1/users\n- Breaking changes require new version: /v2/users\n- Document deprecated endpoints: deprecated: true, description: \"Use /v2/users instead\"\n\nValidation:\n- Ensure all endpoints documented (compare with actual routes)\n- Ensure all schemas used (no orphaned definitions)\n- Ensure examples valid (match schema)",
        "files_touched": [
          "docs/openapi.yaml",
          "docs/api-reference.md",
          "scripts/generate-docs.sh",
          "docs/swagger-ui.html"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5306011953832475,
        "is_confident": true
      },
      {
        "task_id": "CRIT-API-01",
        "title": "Fix SQL injection vulnerability in search endpoint",
        "description": "CRITICAL: GET /api/v1/products/search?q=<query> is vulnerable to SQL injection.\n\nVulnerability details:\n- Endpoint: GET /api/v1/products/search?q=foo\n- Current code: db.query(`SELECT * FROM products WHERE name LIKE '%${req.query.q}%'`)\n- Attack vector: ?q='; DROP TABLE products; --\n- Confirmed exploitable in production (no damage yet)\n\nFix approach:\n- Replace with parameterized query: db.query('SELECT * FROM products WHERE name LIKE ?', [`%${query}%`])\n- Use Prisma raw query with $1 placeholders\n- Add input validation: alphanumeric + spaces only (reject special chars)\n- Escape wildcards: replace % and _ in user input\n- Add rate limiting: 100 searches/minute per IP\n\nAdditional security:\n- Audit all other endpoints for SQL injection (grep for string concatenation in queries)\n- Add SAST check in CI: semgrep rule for SQL injection patterns\n- Add database user with read-only permissions for search queries\n\nTests:\n- Test injection attempts return 400 Bad Request\n- Test escaped wildcards don't match unintended results\n- Test rate limiting blocks excessive requests",
        "files_touched": [
          "src/api/products/search.ts",
          "src/api/products/search.test.ts",
          "src/db/validation.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5213532819676842,
        "is_confident": true
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "REFACTOR-01",
      "title": "Extract email/phone/password validators into shared @company/validators package",
      "description": "Validation logic duplicated across 15 files. Extract into reusable shared package.\n\nCurrent duplication:\n- Email validation: Regex /^[^@]+@[^@]+\\.[^@]+$/ appears in 8 files\n- Phone validation: Regex /^\\+?[1-9]\\d{1,14}$/ appears in 6 files (E.164 format)\n- Password validation: \"8+ chars, uppercase, lowercase, number\" in 12 files\n- Each has slightly different implementation (inconsistent!)\n\nNew package structure:\n- Package: @company/validators\n- Exports: validateEmail(), validatePhone(), validatePassword(), validateURL()\n- TypeScript with type guards: (input: string) => input is ValidEmail\n- Zod integration: emailSchema, phoneSchema, passwordSchema\n\nValidation rules (standardized):\n\n1. Email:\n   - Format: RFC 5322 compliant (use validator.js library)\n   - Max length: 254 characters\n   - Disallow disposable domains (tempmail.com, guerrillamail.com)\n   - Return: {valid: boolean, error?: string}\n\n2. Phone:\n   - Format: E.164 international format (+1234567890)\n   - Use libphonenumber-js for validation\n   - Auto-format: Convert \"(555) 123-4567\" \u2192 \"+15551234567\"\n   - Country code required\n\n3. Password:\n   - Length: 8-128 characters\n   - Requirements: 1 uppercase, 1 lowercase, 1 number, 1 special char (!@#$%^&*)\n   - Reject common passwords (check against top 10k list)\n   - Return strength score: weak/medium/strong\n\n4. URL:\n   - Valid HTTP/HTTPS URL\n   - No localhost or private IPs in production\n   - Max length: 2048 characters\n\nMigration plan:\n1. Publish @company/validators package to private npm registry\n2. Update 15 files to import from package: import {validateEmail} from '@company/validators'\n3. Remove local validation functions\n4. Update tests to use shared validators\n\nBenefits:\n- Single source of truth (no inconsistencies)\n- Easier to update validation rules (change once, affects all services)\n- Comprehensive tests in one place (100% coverage)\n- TypeScript types shared across services\n\nTests:\n- Valid inputs return true\n- Invalid inputs return false with descriptive errors\n- Edge cases: empty string, null, undefined, very long input\n- Locale-specific formats (phone numbers from different countries)",
      "files_touched": [
        "packages/validators/src/email.ts",
        "packages/validators/src/phone.ts",
        "packages/validators/src/password.ts",
        "packages/validators/tests/email.test.ts"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "IMP-OBS-02",
        "title": "Build Grafana dashboard for application health with Prometheus metrics",
        "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
        "files_touched": [
          "src/metrics/prometheus.ts",
          "src/metrics/collectors.ts",
          "grafana/dashboard.json",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5770252167864781,
        "is_confident": true
      },
      {
        "task_id": "IMP-TEST-02",
        "title": "Increase payment processing unit test coverage to 95% (focus edge cases)",
        "description": "Expand test coverage for payment module from current 60% to 95%, focusing on error scenarios.\n\nCurrent gaps (from coverage report):\n- PaymentProcessor.processCharge(): 45% covered (missing error paths)\n- RefundManager.partialRefund(): 20% covered (no edge cases tested)\n- CurrencyConverter.convert(): 0% covered (NO TESTS!)\n\nTest scenarios to add:\n\n1. Payment failures:\n   - Card declined (insufficient funds): Verify error code CARD_DECLINED\n   - Card expired: Verify error code EXPIRED_CARD\n   - Invalid CVV: Verify error code INVALID_CVV\n   - Network timeout (5s): Verify retry logic (3 attempts with exponential backoff)\n   - Gateway error 500: Verify fallback to secondary payment provider\n\n2. Partial refunds:\n   - Refund $50 of $100 charge: Verify remaining balance $50\n   - Multiple partial refunds totaling original amount: Verify full refund\n   - Refund exceeds original amount: Throw error \"Refund exceeds charge amount\"\n   - Refund already-refunded charge: Throw error \"Charge already refunded\"\n\n3. Currency conversion:\n   - USD to EUR: Verify exchange rate within 1% of current rate (use ECB API)\n   - Unsupported currency (XYZ): Throw error \"Currency XYZ not supported\"\n   - Conversion with rounding: $10.999 USD \u2192 \u20ac10.00 (round to 2 decimals)\n   - Same currency (USD to USD): Return original amount (no conversion)\n\n4. Concurrency:\n   - Process 100 payments simultaneously: All succeed or fail independently (no race conditions)\n   - Refund same charge twice concurrently: Only one succeeds (use database transaction)\n\nTest utilities:\n- Mock Stripe API responses (use nock or MSW)\n- Test fixtures: createTestCharge(), createTestRefund()\n- Assertions: toHaveBeenCalledWith(expectedParams), toThrow(ExpectedError)\n\nPerformance:\n- All tests complete in <5s (use mocks, no real API calls)\n- Parallel test execution (Jest --maxWorkers=4)",
        "files_touched": [
          "src/payment/processor.test.ts",
          "src/payment/refunds.test.ts",
          "src/payment/currency.test.ts",
          "src/payment/__mocks__/stripe.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.53782011355656,
        "is_confident": true
      },
      {
        "task_id": "DOC-02",
        "title": "Generate OpenAPI 3.1 specification with request/response examples",
        "description": "Create comprehensive OpenAPI specification for all REST API endpoints with rich examples.\n\nOpenAPI file structure (openapi.yaml):\n\n```yaml\nopenapi: 3.1.0\ninfo:\n  title: Company API\n  version: 1.2.3\n  description: REST API for company platform\n  contact:\n    email: api-team@company.com\nservers:\n  - url: https://api.company.com/v1\n    description: Production\n  - url: https://api-staging.company.com/v1\n    description: Staging\n```\n\nAuthentication:\n- Security scheme: Bearer JWT token\n- Header: Authorization: Bearer <token>\n- Token obtained from POST /auth/login\n- Include security requirement on all protected endpoints\n\nEndpoint documentation (30 endpoints total):\n\nExample: GET /users\n```yaml\n/users:\n  get:\n    summary: List users with pagination\n    operationId: listUsers\n    tags: [Users]\n    parameters:\n      - name: cursor\n        in: query\n        schema: {type: string}\n        description: Pagination cursor from previous response\n      - name: limit\n        in: query\n        schema: {type: integer, minimum: 1, maximum: 100, default: 50}\n      - name: role\n        in: query\n        schema: {type: string, enum: [admin, user, guest]}\n    responses:\n      '200':\n        description: Successful response\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                users:\n                  type: array\n                  items: {$ref: '#/components/schemas/User'}\n                next_cursor: {type: string, nullable: true}\n            examples:\n              page1:\n                summary: First page of results\n                value:\n                  users: [{id: 1, email: \"alice@example.com\", role: \"admin\"}]\n                  next_cursor: \"eyJpZCI6MX0=\"\n      '401': {$ref: '#/components/responses/Unauthorized'}\n      '429': {$ref: '#/components/responses/RateLimited'}\n```\n\nSchemas (components/schemas):\n- User: id, email, display_name, role, created_at\n- Error: code, message, details\n- PaginationMeta: cursor, limit, has_more\n\nResponse examples:\n- Include success case (200)\n- Include error cases (400, 401, 404, 500)\n- Include edge cases (empty results, max limit exceeded)\n\nRate limiting documentation:\n- Global: 1000 requests/hour per IP\n- Per-endpoint: Varies (auth: 10/min, search: 100/min)\n- Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- 429 response includes Retry-After header\n\nCode generation:\n- Generate TypeScript types: openapi-typescript openapi.yaml -o types/api.ts\n- Generate client SDK: openapi-generator-cli generate -i openapi.yaml -g typescript-axios -o sdk/\n- Validate spec: openapi-generator-cli validate -i openapi.yaml\n\nInteractive documentation:\n- Host Swagger UI: Serve openapi.yaml at https://api.company.com/docs\n- Try it out: Allow users to make test requests directly from docs\n- Authentication: Users can input their JWT token in Swagger UI\n\nVersioning:\n- API version in URL: /v1/users\n- Breaking changes require new version: /v2/users\n- Document deprecated endpoints: deprecated: true, description: \"Use /v2/users instead\"\n\nValidation:\n- Ensure all endpoints documented (compare with actual routes)\n- Ensure all schemas used (no orphaned definitions)\n- Ensure examples valid (match schema)",
        "files_touched": [
          "docs/openapi.yaml",
          "docs/api-reference.md",
          "scripts/generate-docs.sh",
          "docs/swagger-ui.html"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5016467484092081,
        "is_confident": true
      },
      {
        "task_id": "IMP-INFRA-01",
        "title": "Set up GitHub Actions CI/CD with automated testing and blue-green deployment",
        "description": "Automate entire software delivery pipeline: build \u2192 test \u2192 deploy to staging \u2192 deploy to production.\n\nGitHub Actions workflow structure:\n\nWorkflow 1: ci.yml (runs on every PR)\n```yaml\nname: CI\non: [pull_request]\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm run lint  # ESLint + Prettier check\n      - run: npm run typecheck  # TypeScript compiler\n\n  test:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:15\n        env: {POSTGRES_PASSWORD: test}\n      redis:\n        image: redis:7\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm test -- --coverage  # Jest with coverage\n      - uses: codecov/codecov-action@v3  # Upload coverage report\n      - run: npm run test:e2e  # Playwright E2E tests\n\n  security:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm audit --audit-level=high  # Fail on high/critical vulns\n      - uses: snyk/actions/node@master  # Additional security scan\n        env:\n          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}\n\n  build:\n    runs-on: ubuntu-latest\n    needs: [lint, test, security]  # Only build if all checks pass\n    steps:\n      - uses: actions/checkout@v3\n      - run: docker build -t api:${{ github.sha }} .\n      - run: docker push ecr.../api:${{ github.sha }}\n```\n\nWorkflow 2: deploy-staging.yml (runs on merge to main)\n```yaml\nname: Deploy Staging\non:\n  push:\n    branches: [main]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to staging\n        run: |\n          kubectl set image deployment/api-staging api=api:${{ github.sha }}\n          kubectl rollout status deployment/api-staging --timeout=5m\n      - name: Run smoke tests\n        run: npm run test:smoke -- --env staging\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\u2705 Deployed to staging: ${{ github.sha }}\"\n            }\n```\n\nWorkflow 3: deploy-prod.yml (runs on git tag)\n```yaml\nname: Deploy Production\non:\n  push:\n    tags: ['v*']\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    environment: production  # Requires manual approval in GitHub\n    steps:\n      - uses: actions/checkout@v3\n      - name: Blue-green deployment\n        run: |\n          # Deploy to green environment\n          kubectl set image deployment/api-green api=api:${{ github.ref_name }}\n          kubectl rollout status deployment/api-green --timeout=10m\n\n          # Run smoke tests on green\n          npm run test:smoke -- --env green\n\n          # Traffic switch: 0% \u2192 10% \u2192 50% \u2192 100%\n          ./scripts/traffic-switch.sh green 10\n          sleep 300  # Monitor for 5 minutes\n\n          ./scripts/traffic-switch.sh green 50\n          sleep 300\n\n          ./scripts/traffic-switch.sh green 100\n\n          # Scale down blue environment\n          kubectl scale deployment/api-blue --replicas=0\n\n      - name: Create GitHub Release\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: Release ${{ github.ref }}\n          body: |\n            See CHANGELOG.md for details\n\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\ud83d\ude80 Deployed to production: ${{ github.ref_name }}\"\n            }\n```\n\nSecrets configuration:\n- AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY: For ECR push\n- KUBECONFIG: Kubernetes cluster access\n- SNYK_TOKEN: Security scanning\n- SLACK_WEBHOOK_URL: Notifications\n- CODECOV_TOKEN: Coverage upload\n\nBranch protection rules:\n- Require status checks to pass: lint, test, security\n- Require 1 approving review\n- Require linear history (no merge commits)\n- Require signed commits (GPG)\n\nDeployment notifications:\n- Slack: Post to #deployments channel with commit SHA, author, status\n- Email: Send to on-call engineer if production deployment fails\n- PagerDuty: Create incident if deployment fails (rollback required)\n\nRollback procedure:\n- Manual rollback: Re-run deploy workflow with previous git tag\n- Automatic rollback: If smoke tests fail, revert traffic to blue\n\nCost optimization:\n- Use GitHub-hosted runners (free for public repos)\n- Cache npm dependencies: actions/cache@v3 (saves 2 min per build)\n- Cancel redundant runs: concurrency group (auto-cancel old PR runs)\n\nMonitoring:\n- Track deployment frequency: Target 10+ deployments/week\n- Track lead time: PR opened \u2192 production, target <4 hours\n- Track failure rate: Target <5% failed deployments\n- Track MTTR: Mean time to recovery, target <30 minutes",
        "files_touched": [
          ".github/workflows/ci.yml",
          ".github/workflows/deploy-staging.yml",
          ".github/workflows/deploy-prod.yml",
          "scripts/traffic-switch.sh"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.4920321471712705,
        "is_confident": false
      },
      {
        "task_id": "CRIT-PERF-01",
        "title": "Optimize landing page load time from 8s to <3s (Core Web Vitals)",
        "description": "Landing page loads in 8 seconds with 20MB of unoptimized images, failing Core Web Vitals.\n\nCurrent performance (Lighthouse score):\n- LCP (Largest Contentful Paint): 6.2s (target: <2.5s) \u274c\n- FID (First Input Delay): 180ms (target: <100ms) \u274c\n- CLS (Cumulative Layout Shift): 0.42 (target: <0.1) \u274c\n- Lighthouse score: 32/100 (Poor)\n\nPerformance bottlenecks (from DevTools):\n1. Images: 20MB total, 12 images at full resolution (4000x3000px)\n2. JavaScript: 2MB bundle size (React, unused libraries)\n3. Fonts: 800KB custom fonts loading blocking render\n4. No caching: Every visit downloads everything again\n\nOptimization plan:\n\n1. Image optimization:\n   - Convert to WebP format (70% size reduction)\n   - Serve responsive images with srcset:\n     ```html\n     <img\n       src=\"hero-800w.webp\"\n       srcset=\"hero-400w.webp 400w, hero-800w.webp 800w, hero-1200w.webp 1200w\"\n       sizes=\"(max-width: 600px) 400px, (max-width: 1200px) 800px, 1200px\"\n       loading=\"lazy\"\n       decoding=\"async\"\n     />\n     ```\n   - Lazy load below-fold images (loading=\"lazy\")\n   - Add CDN caching (Cloudflare): Cache-Control: max-age=31536000, immutable\n   - Expected: 20MB \u2192 2MB (10x reduction)\n\n2. Code splitting:\n   - Split bundle by route: React.lazy(() => import('./About'))\n   - Load above-fold code first (~100KB initial bundle)\n   - Defer non-critical scripts: <script defer src=\"analytics.js\">\n   - Tree-shake unused code: Check webpack-bundle-analyzer\n   - Expected: 2MB \u2192 300KB initial load (6x reduction)\n\n3. Font optimization:\n   - Use font-display: swap (show fallback font immediately)\n   - Preload critical fonts: <link rel=\"preload\" as=\"font\" href=\"font.woff2\">\n   - Subset fonts (Latin characters only): 800KB \u2192 80KB\n   - Use system fonts for body text (zero load time)\n\n4. Caching strategy:\n   - Service Worker: Cache static assets for offline use\n   - HTTP headers: Cache-Control: max-age=31536000 for immutable assets\n   - Use content hashing in filenames: hero-abc123.webp (cache forever)\n\n5. Critical CSS:\n   - Inline above-fold CSS in <head> (~10KB)\n   - Defer non-critical CSS: <link rel=\"preload\" as=\"style\" href=\"main.css\">\n   - Remove unused CSS: Use PurgeCSS (50KB \u2192 8KB)\n\nImplementation steps:\n1. Image processing: Use sharp library to generate WebP + multiple sizes\n2. Update image components: Use <picture> element with WebP + JPEG fallback\n3. Webpack config: Add code splitting, bundle analyzer\n4. Font subsetting: Use pyftsubset to extract Latin glyphs\n5. Deploy behind Cloudflare CDN with caching rules\n\nVerification:\n- Run Lighthouse in CI: Fail build if score <90\n- Test on real devices: iPhone 12, Pixel 5 (3G connection)\n- Measure field data: Send Core Web Vitals to analytics (real user monitoring)\n- Compare before/after:\n  - LCP: 6.2s \u2192 1.8s \u2705\n  - FID: 180ms \u2192 45ms \u2705\n  - CLS: 0.42 \u2192 0.05 \u2705\n  - Lighthouse: 32 \u2192 95 \u2705",
        "files_touched": [
          "src/components/ImageOptimizer.tsx",
          "webpack.config.js",
          "src/utils/image-optimizer.ts",
          "scripts/optimize-images.sh"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.48836809030489775,
        "is_confident": false
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "REFACTOR-02",
      "title": "Migrate callback-based file upload to async/await with streaming",
      "description": "File upload module uses nested callbacks (callback hell), hard to maintain and error-prone.\n\nCurrent code structure (callback pyramid):\n```javascript\nupload.parseMultipart(req, (err, files) => {\n  if (err) return res.status(400).send(err);\n\n  validateFiles(files, (err, validFiles) => {\n    if (err) return res.status(400).send(err);\n\n    storage.uploadToS3(validFiles, (err, urls) => {\n      if (err) return res.status(500).send(err);\n\n      db.saveFileRecords(urls, (err, records) => {\n        if (err) return res.status(500).send(err);\n\n        res.json(records); // Success nested 4 levels deep!\n      });\n    });\n  });\n});\n```\n\nProblems:\n- 4 levels of nesting (hard to read)\n- Error handling duplicated at each level\n- Can't use try/catch (must check err at each callback)\n- Can't use Promise.all for parallel operations\n\nRefactored approach (async/await):\n```javascript\nasync function handleUpload(req, res) {\n  try {\n    const files = await parseMultipart(req);\n    const validFiles = await validateFiles(files);\n    const urls = await uploadToS3(validFiles);\n    const records = await saveFileRecords(urls);\n\n    res.json(records);\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      res.status(400).json({error: error.message});\n    } else {\n      res.status(500).json({error: 'Upload failed'});\n    }\n  }\n}\n```\n\nStreaming improvements:\n- Use streams to avoid loading entire file into memory\n- parseMultipart: Use busboy with streams (process as bytes arrive)\n- uploadToS3: Pipe directly to S3 (no intermediate buffer)\n- Memory usage: 50MB \u2192 5MB for 100MB file upload\n\nError handling improvements:\n- Single try/catch block (centralized error handling)\n- Typed errors: ValidationError, StorageError, DatabaseError\n- Proper cleanup on error: Delete uploaded files, rollback database\n\nProgress tracking:\n- Add upload progress events: req.on('progress', (percent) => sendSSE(percent))\n- Client receives real-time upload progress\n- Cancel upload: req.on('close', () => cleanup())\n\nPerformance:\n- Parallel validation: Use Promise.all to validate multiple files\n- Before: Validate serially (10s for 10 files)\n- After: Validate in parallel (2s for 10 files)\n\nTests:\n- Upload single file: Success\n- Upload multiple files: All succeed\n- Upload with validation error: Reject early, no S3 upload\n- Upload with S3 error: Cleanup temp files\n- Large file upload: Memory usage stays <10MB\n- Cancel upload: Cleanup occurs, no orphaned files",
      "files_touched": [
        "src/upload/file-handler.ts",
        "src/upload/streaming.ts",
        "src/upload/file-handler.test.ts",
        "src/upload/progress.ts"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "CRIT-UI-01",
        "title": "Fix React form losing data on validation error (state management bug)",
        "description": "Contact form clears all fields when server returns validation error, losing user's work.\n\nBug details:\n- User fills out 10-field contact form (takes 5 minutes)\n- Submit fails with \"Email already registered\" error\n- Form state resets to empty, all data lost\n- Users complaining: \"I had to re-enter everything!\"\n\nRoot cause:\n- Form component calls setFormData({}) on any error response\n- Should preserve form data, only show error message\n- Current code: `onError: () => setFormData(initialFormData)` \u274c\n\nFix approach:\n1. Remove setFormData({}) from error handler\n2. Add auto-save to localStorage every 2 seconds:\n   - Key: `form_draft_contact_${Date.now()}`\n   - Value: JSON.stringify(formData)\n   - Clear localStorage on successful submit\n3. On page load: Restore draft if present (show \"Restore previous draft?\" prompt)\n4. Show inline field errors (don't clear valid fields):\n   - Server returns: {errors: {email: \"Already registered\", phone: \"Invalid format\"}}\n   - Only highlight email and phone fields, preserve other data\n\nAdditional improvements:\n- Add \"Save draft\" button (manual save to localStorage)\n- Show \"*Unsaved changes\" indicator\n- Warn before leaving page: beforeunload event if form has data\n\nTests:\n- Submit with validation error preserves form data\n- Auto-save writes to localStorage every 2s\n- Draft restored on page reload\n- Draft cleared after successful submit\n- beforeunload warns when form has unsaved data",
        "files_touched": [
          "src/components/ContactForm.tsx",
          "src/hooks/useFormPersistence.ts",
          "src/components/ContactForm.test.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.616588849833146,
        "is_confident": true
      },
      {
        "task_id": "IMP-UI-01",
        "title": "Build responsive navigation with mobile hamburger menu (Material UI)",
        "description": "Create responsive navigation component using Material-UI with mobile-first design.\n\nComponent requirements:\n- Desktop (>900px): Horizontal nav bar with logo, links, user menu\n- Mobile (<900px): Hamburger icon, slide-out drawer with links\n- Support nested dropdowns (Account > Profile, Settings, Logout)\n- Active link highlighting (match current route)\n- Keyboard navigation: Tab through links, Enter to activate, Escape to close drawer\n\nTechnical implementation:\n- Material-UI AppBar + Drawer components\n- React Router useLocation for active link detection\n- Animated transitions: slide drawer from left (300ms ease-out)\n- Prevent body scroll when drawer open (CSS: overflow: hidden)\n- Focus trap in drawer (focus cycles through links)\n\nAccessibility (WCAG AA):\n- Hamburger button: aria-label=\"Open navigation menu\", aria-expanded\n- Drawer: role=\"navigation\", aria-labelledby=\"nav-title\"\n- Links: Descriptive text (not \"Click here\")\n- Focus visible indicator (2px outline)\n- Color contrast ratio >4.5:1 (text on background)\n\nResponsive breakpoints:\n- Mobile: <600px (stacked links, larger tap targets 48px)\n- Tablet: 600-900px (compact nav, smaller text)\n- Desktop: >900px (full horizontal layout)\n\nTests:\n- Renders correctly at all breakpoints (visual regression)\n- Keyboard navigation works (tab order, enter, escape)\n- Active link highlights current page\n- Drawer opens/closes with animation",
        "files_touched": [
          "src/components/Navigation.tsx",
          "src/components/Navigation.test.tsx",
          "src/styles/navigation.css",
          "src/components/NavDrawer.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.47574624906153345,
        "is_confident": false
      },
      {
        "task_id": "IMP-TEST-01",
        "title": "Add Playwright E2E tests for complete user registration flow",
        "description": "Create comprehensive end-to-end tests covering user registration with Playwright.\n\nTest scenarios:\n1. Happy path:\n   - Navigate to /register\n   - Fill form: email, password (8+ chars), confirm password, accept terms\n   - Submit form\n   - Verify \"Check your email\" message\n   - Open email (use Mailhog test SMTP server)\n   - Click verification link\n   - Verify redirect to /login\n   - Login with new credentials\n   - Verify dashboard loads\n\n2. Validation errors:\n   - Test weak password (< 8 chars): Shows \"Password must be 8+ characters\"\n   - Test password mismatch: Shows \"Passwords do not match\"\n   - Test existing email: Shows \"Email already registered\"\n   - Test invalid email format: Shows \"Invalid email address\"\n   - Test missing required fields: All fields highlighted\n\n3. Email verification edge cases:\n   - Expired link (24h): Shows \"Link expired, resend verification\"\n   - Already verified: Redirect to login with \"Already verified\" message\n   - Invalid token: Shows \"Invalid verification link\"\n\n4. Concurrency:\n   - Two users register with same email simultaneously\n   - Only one succeeds, other gets \"Email already registered\"\n\nTest fixtures:\n- users.fixture.ts: Generate random test users\n- smtp.fixture.ts: Mailhog client for reading verification emails\n- Cleanup: Delete test users after each test\n\nPage objects:\n- RegisterPage: fill(), submit(), getError()\n- LoginPage: login()\n- EmailInbox: getVerificationEmail(), clickLink()\n\nAssertions:\n- Form validation messages appear/disappear correctly\n- Network requests succeed (check status 200/400)\n- Email contains correct verification link\n- User can login after verification\n- User data visible on dashboard",
        "files_touched": [
          "e2e/registration.spec.ts",
          "e2e/fixtures/users.ts",
          "e2e/fixtures/smtp.ts",
          "e2e/pages/RegisterPage.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.45624562623525183,
        "is_confident": false
      },
      {
        "task_id": "IMP-API-01",
        "title": "Add GET /api/v1/users endpoint with cursor-based pagination",
        "description": "Implement REST API endpoint for listing users with cursor-based pagination (not offset/limit).\n\nTechnical requirements:\n- Endpoint: GET /api/v1/users?cursor=<id>&limit=50\n- Return fields: id, email, display_name, created_at, role\n- Default limit: 50, max limit: 100\n- Sort by: id ASC (stable ordering for cursor)\n- Response includes next_cursor for pagination\n- Filter support: ?role=admin,user&status=active\n- Return 400 for invalid cursor, 401 for unauthenticated\n\nImplementation approach:\n- Use Prisma ORM with cursor pagination\n- Add index on (id, created_at) for performance\n- Implement CursorPaginationDTO with Zod validation\n- Unit tests: pagination, filtering, edge cases (empty result, last page)\n- OpenAPI spec in docs/api.yaml\n\nAcceptance criteria:\n- Paginate through 10,000 users in <2s total\n- No duplicate users across pages\n- Works with concurrent updates (stable cursor)",
        "files_touched": [
          "src/api/users/list.ts",
          "src/api/users/list.test.ts",
          "src/dto/pagination.ts",
          "docs/api.yaml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.45315356767905557,
        "is_confident": false
      },
      {
        "task_id": "IMP-OBS-02",
        "title": "Build Grafana dashboard for application health with Prometheus metrics",
        "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
        "files_touched": [
          "src/metrics/prometheus.ts",
          "src/metrics/collectors.ts",
          "grafana/dashboard.json",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.4499488526474336,
        "is_confident": false
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "DOC-01",
      "title": "Write comprehensive production deployment guide with blue-green strategy",
      "description": "Create step-by-step deployment documentation for production environment with zero-downtime blue-green deployments.\n\nDocument structure:\n\n1. Prerequisites:\n   - AWS account with EC2, RDS, S3, Route53 access\n   - Kubernetes cluster (EKS) with kubectl configured\n   - Docker registry access (ECR)\n   - Terraform v1.5+ for infrastructure\n   - Required secrets in AWS Secrets Manager\n\n2. Pre-deployment checklist:\n   - Run test suite: npm test (must be 100% passing)\n   - Run security scan: npm audit (0 high/critical vulnerabilities)\n   - Build Docker image: docker build -t api:v1.2.3 .\n   - Push to registry: docker push ecr.../api:v1.2.3\n   - Database migrations ready: Review migrations/*.sql\n   - Feature flags configured: Check LaunchDarkly dashboard\n\n3. Blue-green deployment steps:\n\n   Step 1: Deploy to GREEN environment (staging)\n   - Update Kubernetes deployment: kubectl set image deployment/api-green api=api:v1.2.3\n   - Wait for rollout: kubectl rollout status deployment/api-green (5 min timeout)\n   - Run smoke tests: curl https://api-green.company.com/health\n   - Verify metrics: Check Grafana dashboard (request rate, error rate, latency)\n\n   Step 2: Run database migrations (if needed)\n   - Migrations run from Kubernetes job: kubectl apply -f k8s/migrate-job.yaml\n   - Forward-compatible only (old code still works): ADD COLUMN (not DROP COLUMN)\n   - Verify migration success: Check job logs, query database\n\n   Step 3: Traffic switch (blue \u2192 green)\n   - Update Route53 weighted routing: 0% blue, 100% green\n   - Monitor error rates: Watch for spike in errors (rollback trigger)\n   - Gradual rollout: 10% \u2192 50% \u2192 100% over 30 minutes\n   - Rollback criteria: Error rate >5% OR p95 latency >500ms OR manual abort\n\n   Step 4: Verify production traffic\n   - Check logs: kubectl logs -f deployment/api-green (look for errors)\n   - Check metrics: Request rate matches expected (no traffic loss)\n   - Check APM: Verify traces in Datadog show expected flow\n   - User testing: QA team tests critical flows in production\n\n   Step 5: Decommission BLUE environment\n   - Scale down old deployment: kubectl scale deployment/api-blue --replicas=0\n   - Keep for 24h as rollback option\n   - After 24h: Delete blue deployment\n\n4. Rollback procedure:\n   - Immediate rollback: kubectl set image deployment/api-green api=api:v1.2.2 (previous version)\n   - Or traffic switch: Route53 100% to blue (old version still running)\n   - Investigate issues: Check logs, metrics, error reports\n   - Fix forward: Deploy hotfix to green, switch traffic back\n\n5. Post-deployment:\n   - Update release notes: docs/CHANGELOG.md\n   - Notify team: Slack message to #deployments channel\n   - Monitor for 1 hour: Watch metrics, error logs, user reports\n   - Tag release: git tag v1.2.3 && git push --tags\n\n6. Troubleshooting common issues:\n   - Issue: Deployment stuck in \"Progressing\" state\n     - Cause: Image pull error (invalid tag)\n     - Fix: Verify image exists: docker pull ecr.../api:v1.2.3\n\n   - Issue: Pods crashing (CrashLoopBackOff)\n     - Cause: Missing environment variable or secret\n     - Fix: Check pod logs: kubectl logs api-green-xxxx\n\n   - Issue: High error rate after deployment\n     - Cause: Breaking change in API, clients sending old format\n     - Fix: Rollback immediately, implement backward compatibility\n\nAppendices:\n- A: Environment variables reference (50+ vars with descriptions)\n- B: Kubernetes resource definitions (deployment.yaml, service.yaml)\n- C: Monitoring runbooks (what to do when alerts fire)\n- D: Database migration best practices",
      "files_touched": [
        "docs/deployment.md",
        "docs/troubleshooting.md",
        "docs/runbooks.md",
        "k8s/deployment.yaml"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "IMP-PERF-01",
        "title": "Implement Redis caching layer with TTL and cache invalidation",
        "description": "Add Redis caching for frequently accessed data (user sessions, product catalog) to reduce database load by 80%.\n\nCaching strategy:\n\n1. User sessions (high read frequency):\n   - Key: session:{session_id}\n   - Value: {user_id, role, permissions, expires_at}\n   - TTL: 15 minutes (refresh on each request)\n   - Invalidation: On logout or password change\n   - Pattern: Read-through cache (check Redis, fallback to DB, populate cache)\n\n2. Product catalog (read-heavy, infrequent updates):\n   - Key: product:{product_id}\n   - Value: {id, name, price, description, inventory, images}\n   - TTL: 1 hour\n   - Invalidation: On product update (PATCH /products/:id)\n   - Pattern: Cache-aside (application manages cache explicitly)\n\n3. API rate limits (write-heavy):\n   - Key: ratelimit:{ip}:{endpoint}\n   - Value: Request count\n   - TTL: 1 minute (sliding window)\n   - Increment on each request: INCR key, check if > limit\n\nRedis client setup:\n- Use ioredis library (supports Redis Cluster, pipelining)\n- Connection pool: 10 connections max\n- Retry strategy: Exponential backoff (1s, 2s, 4s, max 10s)\n- Error handling: If Redis unavailable, fallback to database (log warning)\n\nCache patterns implementation:\n\nRead-through cache:\n```typescript\nasync function getUser(userId: string): Promise<User> {\n  // Try cache first\n  const cached = await redis.get(`user:${userId}`);\n  if (cached) {\n    return JSON.parse(cached);\n  }\n\n  // Cache miss: fetch from database\n  const user = await db.users.findUnique({where: {id: userId}});\n\n  // Populate cache with 15min TTL\n  await redis.setex(`user:${userId}`, 900, JSON.stringify(user));\n\n  return user;\n}\n```\n\nCache invalidation:\n```typescript\nasync function updateProduct(id: string, data: UpdateData): Promise<Product> {\n  // Update database\n  const product = await db.products.update({where: {id}, data});\n\n  // Invalidate cache\n  await redis.del(`product:${id}`);\n\n  // Optional: Also invalidate list caches\n  await redis.del('products:list:page:*');  // Use SCAN to find keys\n\n  return product;\n}\n```\n\nPerformance optimization:\n- Pipeline multiple operations: redis.pipeline().get('key1').get('key2').exec()\n- Use mget for bulk reads: redis.mget(['key1', 'key2', 'key3'])\n- Compress large values: Use zlib to gzip JSON before storing\n\nMonitoring:\n- Cache hit rate: hits / (hits + misses), target >90%\n- Eviction rate: Monitor evicted_keys metric, alert if >1000/min\n- Memory usage: Alert if >80% of max memory\n- Connection errors: Alert on connection failures\n\nCache warming:\n- On application startup: Preload hot data (top 100 products)\n- Scheduled job: Refresh catalog every hour\n- Avoid thundering herd: Use locks (SET key NX EX 10) for cache regeneration\n\nTests:\n- Cache hit: Verify second read from cache (faster than DB)\n- Cache miss: Verify fallback to DB\n- Cache invalidation: Update data, verify cache cleared\n- Redis failure: Verify graceful degradation to DB\n- Concurrent requests: No cache stampede (use locking)",
        "files_touched": [
          "src/cache/redis-client.ts",
          "src/cache/cache-strategy.ts",
          "src/cache/redis-client.test.ts",
          "src/middleware/rate-limit.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5223141257233569,
        "is_confident": true
      },
      {
        "task_id": "IMP-DB-01",
        "title": "Add Postgres migration for user_preferences JSONB column",
        "description": "Create migration to add user preferences as flexible JSONB column.\n\nSchema change:\n- Table: users\n- New column: preferences JSONB DEFAULT '{}'::jsonb NOT NULL\n- Add GIN index: CREATE INDEX idx_users_preferences_gin ON users USING GIN (preferences)\n- Example data: {\"theme\": \"dark\", \"language\": \"en-US\", \"timezone\": \"America/Los_Angeles\", \"notifications\": {\"email\": true, \"push\": false}}\n\nMigration file structure:\n- up.sql: ALTER TABLE users ADD COLUMN preferences JSONB DEFAULT '{}'::jsonb NOT NULL; CREATE INDEX ...\n- down.sql: DROP INDEX idx_users_preferences_gin; ALTER TABLE users DROP COLUMN preferences;\n- Estimated time: <100ms on 1M rows (column default doesn't rewrite table)\n\nApplication code changes:\n- Update User model with preferences: Record<string, any>\n- Add preference validation schema (max 50KB, valid JSON)\n- Add endpoint: PATCH /api/v1/users/:id/preferences (merge with existing prefs)\n- Query optimization: WHERE preferences @> '{\"theme\": \"dark\"}' uses GIN index\n\nRollback plan:\n- Run down.sql to remove column\n- No data loss (preferences are optional settings)",
        "files_touched": [
          "migrations/20251029_add_user_preferences.sql",
          "src/models/user.ts",
          "src/api/users/preferences.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.4804112682356673,
        "is_confident": false
      },
      {
        "task_id": "CRIT-PERF-01",
        "title": "Optimize landing page load time from 8s to <3s (Core Web Vitals)",
        "description": "Landing page loads in 8 seconds with 20MB of unoptimized images, failing Core Web Vitals.\n\nCurrent performance (Lighthouse score):\n- LCP (Largest Contentful Paint): 6.2s (target: <2.5s) \u274c\n- FID (First Input Delay): 180ms (target: <100ms) \u274c\n- CLS (Cumulative Layout Shift): 0.42 (target: <0.1) \u274c\n- Lighthouse score: 32/100 (Poor)\n\nPerformance bottlenecks (from DevTools):\n1. Images: 20MB total, 12 images at full resolution (4000x3000px)\n2. JavaScript: 2MB bundle size (React, unused libraries)\n3. Fonts: 800KB custom fonts loading blocking render\n4. No caching: Every visit downloads everything again\n\nOptimization plan:\n\n1. Image optimization:\n   - Convert to WebP format (70% size reduction)\n   - Serve responsive images with srcset:\n     ```html\n     <img\n       src=\"hero-800w.webp\"\n       srcset=\"hero-400w.webp 400w, hero-800w.webp 800w, hero-1200w.webp 1200w\"\n       sizes=\"(max-width: 600px) 400px, (max-width: 1200px) 800px, 1200px\"\n       loading=\"lazy\"\n       decoding=\"async\"\n     />\n     ```\n   - Lazy load below-fold images (loading=\"lazy\")\n   - Add CDN caching (Cloudflare): Cache-Control: max-age=31536000, immutable\n   - Expected: 20MB \u2192 2MB (10x reduction)\n\n2. Code splitting:\n   - Split bundle by route: React.lazy(() => import('./About'))\n   - Load above-fold code first (~100KB initial bundle)\n   - Defer non-critical scripts: <script defer src=\"analytics.js\">\n   - Tree-shake unused code: Check webpack-bundle-analyzer\n   - Expected: 2MB \u2192 300KB initial load (6x reduction)\n\n3. Font optimization:\n   - Use font-display: swap (show fallback font immediately)\n   - Preload critical fonts: <link rel=\"preload\" as=\"font\" href=\"font.woff2\">\n   - Subset fonts (Latin characters only): 800KB \u2192 80KB\n   - Use system fonts for body text (zero load time)\n\n4. Caching strategy:\n   - Service Worker: Cache static assets for offline use\n   - HTTP headers: Cache-Control: max-age=31536000 for immutable assets\n   - Use content hashing in filenames: hero-abc123.webp (cache forever)\n\n5. Critical CSS:\n   - Inline above-fold CSS in <head> (~10KB)\n   - Defer non-critical CSS: <link rel=\"preload\" as=\"style\" href=\"main.css\">\n   - Remove unused CSS: Use PurgeCSS (50KB \u2192 8KB)\n\nImplementation steps:\n1. Image processing: Use sharp library to generate WebP + multiple sizes\n2. Update image components: Use <picture> element with WebP + JPEG fallback\n3. Webpack config: Add code splitting, bundle analyzer\n4. Font subsetting: Use pyftsubset to extract Latin glyphs\n5. Deploy behind Cloudflare CDN with caching rules\n\nVerification:\n- Run Lighthouse in CI: Fail build if score <90\n- Test on real devices: iPhone 12, Pixel 5 (3G connection)\n- Measure field data: Send Core Web Vitals to analytics (real user monitoring)\n- Compare before/after:\n  - LCP: 6.2s \u2192 1.8s \u2705\n  - FID: 180ms \u2192 45ms \u2705\n  - CLS: 0.42 \u2192 0.05 \u2705\n  - Lighthouse: 32 \u2192 95 \u2705",
        "files_touched": [
          "src/components/ImageOptimizer.tsx",
          "webpack.config.js",
          "src/utils/image-optimizer.ts",
          "scripts/optimize-images.sh"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.4717368854247181,
        "is_confident": false
      },
      {
        "task_id": "IMP-API-01",
        "title": "Add GET /api/v1/users endpoint with cursor-based pagination",
        "description": "Implement REST API endpoint for listing users with cursor-based pagination (not offset/limit).\n\nTechnical requirements:\n- Endpoint: GET /api/v1/users?cursor=<id>&limit=50\n- Return fields: id, email, display_name, created_at, role\n- Default limit: 50, max limit: 100\n- Sort by: id ASC (stable ordering for cursor)\n- Response includes next_cursor for pagination\n- Filter support: ?role=admin,user&status=active\n- Return 400 for invalid cursor, 401 for unauthenticated\n\nImplementation approach:\n- Use Prisma ORM with cursor pagination\n- Add index on (id, created_at) for performance\n- Implement CursorPaginationDTO with Zod validation\n- Unit tests: pagination, filtering, edge cases (empty result, last page)\n- OpenAPI spec in docs/api.yaml\n\nAcceptance criteria:\n- Paginate through 10,000 users in <2s total\n- No duplicate users across pages\n- Works with concurrent updates (stable cursor)",
        "files_touched": [
          "src/api/users/list.ts",
          "src/api/users/list.test.ts",
          "src/dto/pagination.ts",
          "docs/api.yaml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.4046758629692656,
        "is_confident": false
      },
      {
        "task_id": "DOC-02",
        "title": "Generate OpenAPI 3.1 specification with request/response examples",
        "description": "Create comprehensive OpenAPI specification for all REST API endpoints with rich examples.\n\nOpenAPI file structure (openapi.yaml):\n\n```yaml\nopenapi: 3.1.0\ninfo:\n  title: Company API\n  version: 1.2.3\n  description: REST API for company platform\n  contact:\n    email: api-team@company.com\nservers:\n  - url: https://api.company.com/v1\n    description: Production\n  - url: https://api-staging.company.com/v1\n    description: Staging\n```\n\nAuthentication:\n- Security scheme: Bearer JWT token\n- Header: Authorization: Bearer <token>\n- Token obtained from POST /auth/login\n- Include security requirement on all protected endpoints\n\nEndpoint documentation (30 endpoints total):\n\nExample: GET /users\n```yaml\n/users:\n  get:\n    summary: List users with pagination\n    operationId: listUsers\n    tags: [Users]\n    parameters:\n      - name: cursor\n        in: query\n        schema: {type: string}\n        description: Pagination cursor from previous response\n      - name: limit\n        in: query\n        schema: {type: integer, minimum: 1, maximum: 100, default: 50}\n      - name: role\n        in: query\n        schema: {type: string, enum: [admin, user, guest]}\n    responses:\n      '200':\n        description: Successful response\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                users:\n                  type: array\n                  items: {$ref: '#/components/schemas/User'}\n                next_cursor: {type: string, nullable: true}\n            examples:\n              page1:\n                summary: First page of results\n                value:\n                  users: [{id: 1, email: \"alice@example.com\", role: \"admin\"}]\n                  next_cursor: \"eyJpZCI6MX0=\"\n      '401': {$ref: '#/components/responses/Unauthorized'}\n      '429': {$ref: '#/components/responses/RateLimited'}\n```\n\nSchemas (components/schemas):\n- User: id, email, display_name, role, created_at\n- Error: code, message, details\n- PaginationMeta: cursor, limit, has_more\n\nResponse examples:\n- Include success case (200)\n- Include error cases (400, 401, 404, 500)\n- Include edge cases (empty results, max limit exceeded)\n\nRate limiting documentation:\n- Global: 1000 requests/hour per IP\n- Per-endpoint: Varies (auth: 10/min, search: 100/min)\n- Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- 429 response includes Retry-After header\n\nCode generation:\n- Generate TypeScript types: openapi-typescript openapi.yaml -o types/api.ts\n- Generate client SDK: openapi-generator-cli generate -i openapi.yaml -g typescript-axios -o sdk/\n- Validate spec: openapi-generator-cli validate -i openapi.yaml\n\nInteractive documentation:\n- Host Swagger UI: Serve openapi.yaml at https://api.company.com/docs\n- Try it out: Allow users to make test requests directly from docs\n- Authentication: Users can input their JWT token in Swagger UI\n\nVersioning:\n- API version in URL: /v1/users\n- Breaking changes require new version: /v2/users\n- Document deprecated endpoints: deprecated: true, description: \"Use /v2/users instead\"\n\nValidation:\n- Ensure all endpoints documented (compare with actual routes)\n- Ensure all schemas used (no orphaned definitions)\n- Ensure examples valid (match schema)",
        "files_touched": [
          "docs/openapi.yaml",
          "docs/api-reference.md",
          "scripts/generate-docs.sh",
          "docs/swagger-ui.html"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.38086046793620715,
        "is_confident": false
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "DOC-02",
      "title": "Generate OpenAPI 3.1 specification with request/response examples",
      "description": "Create comprehensive OpenAPI specification for all REST API endpoints with rich examples.\n\nOpenAPI file structure (openapi.yaml):\n\n```yaml\nopenapi: 3.1.0\ninfo:\n  title: Company API\n  version: 1.2.3\n  description: REST API for company platform\n  contact:\n    email: api-team@company.com\nservers:\n  - url: https://api.company.com/v1\n    description: Production\n  - url: https://api-staging.company.com/v1\n    description: Staging\n```\n\nAuthentication:\n- Security scheme: Bearer JWT token\n- Header: Authorization: Bearer <token>\n- Token obtained from POST /auth/login\n- Include security requirement on all protected endpoints\n\nEndpoint documentation (30 endpoints total):\n\nExample: GET /users\n```yaml\n/users:\n  get:\n    summary: List users with pagination\n    operationId: listUsers\n    tags: [Users]\n    parameters:\n      - name: cursor\n        in: query\n        schema: {type: string}\n        description: Pagination cursor from previous response\n      - name: limit\n        in: query\n        schema: {type: integer, minimum: 1, maximum: 100, default: 50}\n      - name: role\n        in: query\n        schema: {type: string, enum: [admin, user, guest]}\n    responses:\n      '200':\n        description: Successful response\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                users:\n                  type: array\n                  items: {$ref: '#/components/schemas/User'}\n                next_cursor: {type: string, nullable: true}\n            examples:\n              page1:\n                summary: First page of results\n                value:\n                  users: [{id: 1, email: \"alice@example.com\", role: \"admin\"}]\n                  next_cursor: \"eyJpZCI6MX0=\"\n      '401': {$ref: '#/components/responses/Unauthorized'}\n      '429': {$ref: '#/components/responses/RateLimited'}\n```\n\nSchemas (components/schemas):\n- User: id, email, display_name, role, created_at\n- Error: code, message, details\n- PaginationMeta: cursor, limit, has_more\n\nResponse examples:\n- Include success case (200)\n- Include error cases (400, 401, 404, 500)\n- Include edge cases (empty results, max limit exceeded)\n\nRate limiting documentation:\n- Global: 1000 requests/hour per IP\n- Per-endpoint: Varies (auth: 10/min, search: 100/min)\n- Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- 429 response includes Retry-After header\n\nCode generation:\n- Generate TypeScript types: openapi-typescript openapi.yaml -o types/api.ts\n- Generate client SDK: openapi-generator-cli generate -i openapi.yaml -g typescript-axios -o sdk/\n- Validate spec: openapi-generator-cli validate -i openapi.yaml\n\nInteractive documentation:\n- Host Swagger UI: Serve openapi.yaml at https://api.company.com/docs\n- Try it out: Allow users to make test requests directly from docs\n- Authentication: Users can input their JWT token in Swagger UI\n\nVersioning:\n- API version in URL: /v1/users\n- Breaking changes require new version: /v2/users\n- Document deprecated endpoints: deprecated: true, description: \"Use /v2/users instead\"\n\nValidation:\n- Ensure all endpoints documented (compare with actual routes)\n- Ensure all schemas used (no orphaned definitions)\n- Ensure examples valid (match schema)",
      "files_touched": [
        "docs/openapi.yaml",
        "docs/api-reference.md",
        "scripts/generate-docs.sh",
        "docs/swagger-ui.html"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "IMP-OBS-02",
        "title": "Build Grafana dashboard for application health with Prometheus metrics",
        "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
        "files_touched": [
          "src/metrics/prometheus.ts",
          "src/metrics/collectors.ts",
          "grafana/dashboard.json",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.6653934995226963,
        "is_confident": true
      },
      {
        "task_id": "IMP-INFRA-01",
        "title": "Set up GitHub Actions CI/CD with automated testing and blue-green deployment",
        "description": "Automate entire software delivery pipeline: build \u2192 test \u2192 deploy to staging \u2192 deploy to production.\n\nGitHub Actions workflow structure:\n\nWorkflow 1: ci.yml (runs on every PR)\n```yaml\nname: CI\non: [pull_request]\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm run lint  # ESLint + Prettier check\n      - run: npm run typecheck  # TypeScript compiler\n\n  test:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:15\n        env: {POSTGRES_PASSWORD: test}\n      redis:\n        image: redis:7\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm test -- --coverage  # Jest with coverage\n      - uses: codecov/codecov-action@v3  # Upload coverage report\n      - run: npm run test:e2e  # Playwright E2E tests\n\n  security:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm audit --audit-level=high  # Fail on high/critical vulns\n      - uses: snyk/actions/node@master  # Additional security scan\n        env:\n          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}\n\n  build:\n    runs-on: ubuntu-latest\n    needs: [lint, test, security]  # Only build if all checks pass\n    steps:\n      - uses: actions/checkout@v3\n      - run: docker build -t api:${{ github.sha }} .\n      - run: docker push ecr.../api:${{ github.sha }}\n```\n\nWorkflow 2: deploy-staging.yml (runs on merge to main)\n```yaml\nname: Deploy Staging\non:\n  push:\n    branches: [main]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to staging\n        run: |\n          kubectl set image deployment/api-staging api=api:${{ github.sha }}\n          kubectl rollout status deployment/api-staging --timeout=5m\n      - name: Run smoke tests\n        run: npm run test:smoke -- --env staging\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\u2705 Deployed to staging: ${{ github.sha }}\"\n            }\n```\n\nWorkflow 3: deploy-prod.yml (runs on git tag)\n```yaml\nname: Deploy Production\non:\n  push:\n    tags: ['v*']\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    environment: production  # Requires manual approval in GitHub\n    steps:\n      - uses: actions/checkout@v3\n      - name: Blue-green deployment\n        run: |\n          # Deploy to green environment\n          kubectl set image deployment/api-green api=api:${{ github.ref_name }}\n          kubectl rollout status deployment/api-green --timeout=10m\n\n          # Run smoke tests on green\n          npm run test:smoke -- --env green\n\n          # Traffic switch: 0% \u2192 10% \u2192 50% \u2192 100%\n          ./scripts/traffic-switch.sh green 10\n          sleep 300  # Monitor for 5 minutes\n\n          ./scripts/traffic-switch.sh green 50\n          sleep 300\n\n          ./scripts/traffic-switch.sh green 100\n\n          # Scale down blue environment\n          kubectl scale deployment/api-blue --replicas=0\n\n      - name: Create GitHub Release\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: Release ${{ github.ref }}\n          body: |\n            See CHANGELOG.md for details\n\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\ud83d\ude80 Deployed to production: ${{ github.ref_name }}\"\n            }\n```\n\nSecrets configuration:\n- AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY: For ECR push\n- KUBECONFIG: Kubernetes cluster access\n- SNYK_TOKEN: Security scanning\n- SLACK_WEBHOOK_URL: Notifications\n- CODECOV_TOKEN: Coverage upload\n\nBranch protection rules:\n- Require status checks to pass: lint, test, security\n- Require 1 approving review\n- Require linear history (no merge commits)\n- Require signed commits (GPG)\n\nDeployment notifications:\n- Slack: Post to #deployments channel with commit SHA, author, status\n- Email: Send to on-call engineer if production deployment fails\n- PagerDuty: Create incident if deployment fails (rollback required)\n\nRollback procedure:\n- Manual rollback: Re-run deploy workflow with previous git tag\n- Automatic rollback: If smoke tests fail, revert traffic to blue\n\nCost optimization:\n- Use GitHub-hosted runners (free for public repos)\n- Cache npm dependencies: actions/cache@v3 (saves 2 min per build)\n- Cancel redundant runs: concurrency group (auto-cancel old PR runs)\n\nMonitoring:\n- Track deployment frequency: Target 10+ deployments/week\n- Track lead time: PR opened \u2192 production, target <4 hours\n- Track failure rate: Target <5% failed deployments\n- Track MTTR: Mean time to recovery, target <30 minutes",
        "files_touched": [
          ".github/workflows/ci.yml",
          ".github/workflows/deploy-staging.yml",
          ".github/workflows/deploy-prod.yml",
          "scripts/traffic-switch.sh"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.638298299868388,
        "is_confident": true
      },
      {
        "task_id": "CRIT-UI-01",
        "title": "Fix React form losing data on validation error (state management bug)",
        "description": "Contact form clears all fields when server returns validation error, losing user's work.\n\nBug details:\n- User fills out 10-field contact form (takes 5 minutes)\n- Submit fails with \"Email already registered\" error\n- Form state resets to empty, all data lost\n- Users complaining: \"I had to re-enter everything!\"\n\nRoot cause:\n- Form component calls setFormData({}) on any error response\n- Should preserve form data, only show error message\n- Current code: `onError: () => setFormData(initialFormData)` \u274c\n\nFix approach:\n1. Remove setFormData({}) from error handler\n2. Add auto-save to localStorage every 2 seconds:\n   - Key: `form_draft_contact_${Date.now()}`\n   - Value: JSON.stringify(formData)\n   - Clear localStorage on successful submit\n3. On page load: Restore draft if present (show \"Restore previous draft?\" prompt)\n4. Show inline field errors (don't clear valid fields):\n   - Server returns: {errors: {email: \"Already registered\", phone: \"Invalid format\"}}\n   - Only highlight email and phone fields, preserve other data\n\nAdditional improvements:\n- Add \"Save draft\" button (manual save to localStorage)\n- Show \"*Unsaved changes\" indicator\n- Warn before leaving page: beforeunload event if form has data\n\nTests:\n- Submit with validation error preserves form data\n- Auto-save writes to localStorage every 2s\n- Draft restored on page reload\n- Draft cleared after successful submit\n- beforeunload warns when form has unsaved data",
        "files_touched": [
          "src/components/ContactForm.tsx",
          "src/hooks/useFormPersistence.ts",
          "src/components/ContactForm.test.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5788556795104318,
        "is_confident": true
      },
      {
        "task_id": "IMP-TEST-02",
        "title": "Increase payment processing unit test coverage to 95% (focus edge cases)",
        "description": "Expand test coverage for payment module from current 60% to 95%, focusing on error scenarios.\n\nCurrent gaps (from coverage report):\n- PaymentProcessor.processCharge(): 45% covered (missing error paths)\n- RefundManager.partialRefund(): 20% covered (no edge cases tested)\n- CurrencyConverter.convert(): 0% covered (NO TESTS!)\n\nTest scenarios to add:\n\n1. Payment failures:\n   - Card declined (insufficient funds): Verify error code CARD_DECLINED\n   - Card expired: Verify error code EXPIRED_CARD\n   - Invalid CVV: Verify error code INVALID_CVV\n   - Network timeout (5s): Verify retry logic (3 attempts with exponential backoff)\n   - Gateway error 500: Verify fallback to secondary payment provider\n\n2. Partial refunds:\n   - Refund $50 of $100 charge: Verify remaining balance $50\n   - Multiple partial refunds totaling original amount: Verify full refund\n   - Refund exceeds original amount: Throw error \"Refund exceeds charge amount\"\n   - Refund already-refunded charge: Throw error \"Charge already refunded\"\n\n3. Currency conversion:\n   - USD to EUR: Verify exchange rate within 1% of current rate (use ECB API)\n   - Unsupported currency (XYZ): Throw error \"Currency XYZ not supported\"\n   - Conversion with rounding: $10.999 USD \u2192 \u20ac10.00 (round to 2 decimals)\n   - Same currency (USD to USD): Return original amount (no conversion)\n\n4. Concurrency:\n   - Process 100 payments simultaneously: All succeed or fail independently (no race conditions)\n   - Refund same charge twice concurrently: Only one succeeds (use database transaction)\n\nTest utilities:\n- Mock Stripe API responses (use nock or MSW)\n- Test fixtures: createTestCharge(), createTestRefund()\n- Assertions: toHaveBeenCalledWith(expectedParams), toThrow(ExpectedError)\n\nPerformance:\n- All tests complete in <5s (use mocks, no real API calls)\n- Parallel test execution (Jest --maxWorkers=4)",
        "files_touched": [
          "src/payment/processor.test.ts",
          "src/payment/refunds.test.ts",
          "src/payment/currency.test.ts",
          "src/payment/__mocks__/stripe.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.565895782859834,
        "is_confident": true
      },
      {
        "task_id": "IMP-UI-01",
        "title": "Build responsive navigation with mobile hamburger menu (Material UI)",
        "description": "Create responsive navigation component using Material-UI with mobile-first design.\n\nComponent requirements:\n- Desktop (>900px): Horizontal nav bar with logo, links, user menu\n- Mobile (<900px): Hamburger icon, slide-out drawer with links\n- Support nested dropdowns (Account > Profile, Settings, Logout)\n- Active link highlighting (match current route)\n- Keyboard navigation: Tab through links, Enter to activate, Escape to close drawer\n\nTechnical implementation:\n- Material-UI AppBar + Drawer components\n- React Router useLocation for active link detection\n- Animated transitions: slide drawer from left (300ms ease-out)\n- Prevent body scroll when drawer open (CSS: overflow: hidden)\n- Focus trap in drawer (focus cycles through links)\n\nAccessibility (WCAG AA):\n- Hamburger button: aria-label=\"Open navigation menu\", aria-expanded\n- Drawer: role=\"navigation\", aria-labelledby=\"nav-title\"\n- Links: Descriptive text (not \"Click here\")\n- Focus visible indicator (2px outline)\n- Color contrast ratio >4.5:1 (text on background)\n\nResponsive breakpoints:\n- Mobile: <600px (stacked links, larger tap targets 48px)\n- Tablet: 600-900px (compact nav, smaller text)\n- Desktop: >900px (full horizontal layout)\n\nTests:\n- Renders correctly at all breakpoints (visual regression)\n- Keyboard navigation works (tab order, enter, escape)\n- Active link highlights current page\n- Drawer opens/closes with animation",
        "files_touched": [
          "src/components/Navigation.tsx",
          "src/components/Navigation.test.tsx",
          "src/styles/navigation.css",
          "src/components/NavDrawer.tsx"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5393362919795819,
        "is_confident": true
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "CRIT-PERF-01",
      "title": "Optimize landing page load time from 8s to <3s (Core Web Vitals)",
      "description": "Landing page loads in 8 seconds with 20MB of unoptimized images, failing Core Web Vitals.\n\nCurrent performance (Lighthouse score):\n- LCP (Largest Contentful Paint): 6.2s (target: <2.5s) \u274c\n- FID (First Input Delay): 180ms (target: <100ms) \u274c\n- CLS (Cumulative Layout Shift): 0.42 (target: <0.1) \u274c\n- Lighthouse score: 32/100 (Poor)\n\nPerformance bottlenecks (from DevTools):\n1. Images: 20MB total, 12 images at full resolution (4000x3000px)\n2. JavaScript: 2MB bundle size (React, unused libraries)\n3. Fonts: 800KB custom fonts loading blocking render\n4. No caching: Every visit downloads everything again\n\nOptimization plan:\n\n1. Image optimization:\n   - Convert to WebP format (70% size reduction)\n   - Serve responsive images with srcset:\n     ```html\n     <img\n       src=\"hero-800w.webp\"\n       srcset=\"hero-400w.webp 400w, hero-800w.webp 800w, hero-1200w.webp 1200w\"\n       sizes=\"(max-width: 600px) 400px, (max-width: 1200px) 800px, 1200px\"\n       loading=\"lazy\"\n       decoding=\"async\"\n     />\n     ```\n   - Lazy load below-fold images (loading=\"lazy\")\n   - Add CDN caching (Cloudflare): Cache-Control: max-age=31536000, immutable\n   - Expected: 20MB \u2192 2MB (10x reduction)\n\n2. Code splitting:\n   - Split bundle by route: React.lazy(() => import('./About'))\n   - Load above-fold code first (~100KB initial bundle)\n   - Defer non-critical scripts: <script defer src=\"analytics.js\">\n   - Tree-shake unused code: Check webpack-bundle-analyzer\n   - Expected: 2MB \u2192 300KB initial load (6x reduction)\n\n3. Font optimization:\n   - Use font-display: swap (show fallback font immediately)\n   - Preload critical fonts: <link rel=\"preload\" as=\"font\" href=\"font.woff2\">\n   - Subset fonts (Latin characters only): 800KB \u2192 80KB\n   - Use system fonts for body text (zero load time)\n\n4. Caching strategy:\n   - Service Worker: Cache static assets for offline use\n   - HTTP headers: Cache-Control: max-age=31536000 for immutable assets\n   - Use content hashing in filenames: hero-abc123.webp (cache forever)\n\n5. Critical CSS:\n   - Inline above-fold CSS in <head> (~10KB)\n   - Defer non-critical CSS: <link rel=\"preload\" as=\"style\" href=\"main.css\">\n   - Remove unused CSS: Use PurgeCSS (50KB \u2192 8KB)\n\nImplementation steps:\n1. Image processing: Use sharp library to generate WebP + multiple sizes\n2. Update image components: Use <picture> element with WebP + JPEG fallback\n3. Webpack config: Add code splitting, bundle analyzer\n4. Font subsetting: Use pyftsubset to extract Latin glyphs\n5. Deploy behind Cloudflare CDN with caching rules\n\nVerification:\n- Run Lighthouse in CI: Fail build if score <90\n- Test on real devices: iPhone 12, Pixel 5 (3G connection)\n- Measure field data: Send Core Web Vitals to analytics (real user monitoring)\n- Compare before/after:\n  - LCP: 6.2s \u2192 1.8s \u2705\n  - FID: 180ms \u2192 45ms \u2705\n  - CLS: 0.42 \u2192 0.05 \u2705\n  - Lighthouse: 32 \u2192 95 \u2705",
      "files_touched": [
        "src/components/ImageOptimizer.tsx",
        "webpack.config.js",
        "src/utils/image-optimizer.ts",
        "scripts/optimize-images.sh"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "IMP-OBS-02",
        "title": "Build Grafana dashboard for application health with Prometheus metrics",
        "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
        "files_touched": [
          "src/metrics/prometheus.ts",
          "src/metrics/collectors.ts",
          "grafana/dashboard.json",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.53338438844126,
        "is_confident": true
      },
      {
        "task_id": "IMP-INFRA-01",
        "title": "Set up GitHub Actions CI/CD with automated testing and blue-green deployment",
        "description": "Automate entire software delivery pipeline: build \u2192 test \u2192 deploy to staging \u2192 deploy to production.\n\nGitHub Actions workflow structure:\n\nWorkflow 1: ci.yml (runs on every PR)\n```yaml\nname: CI\non: [pull_request]\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm run lint  # ESLint + Prettier check\n      - run: npm run typecheck  # TypeScript compiler\n\n  test:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:15\n        env: {POSTGRES_PASSWORD: test}\n      redis:\n        image: redis:7\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm test -- --coverage  # Jest with coverage\n      - uses: codecov/codecov-action@v3  # Upload coverage report\n      - run: npm run test:e2e  # Playwright E2E tests\n\n  security:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm audit --audit-level=high  # Fail on high/critical vulns\n      - uses: snyk/actions/node@master  # Additional security scan\n        env:\n          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}\n\n  build:\n    runs-on: ubuntu-latest\n    needs: [lint, test, security]  # Only build if all checks pass\n    steps:\n      - uses: actions/checkout@v3\n      - run: docker build -t api:${{ github.sha }} .\n      - run: docker push ecr.../api:${{ github.sha }}\n```\n\nWorkflow 2: deploy-staging.yml (runs on merge to main)\n```yaml\nname: Deploy Staging\non:\n  push:\n    branches: [main]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to staging\n        run: |\n          kubectl set image deployment/api-staging api=api:${{ github.sha }}\n          kubectl rollout status deployment/api-staging --timeout=5m\n      - name: Run smoke tests\n        run: npm run test:smoke -- --env staging\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\u2705 Deployed to staging: ${{ github.sha }}\"\n            }\n```\n\nWorkflow 3: deploy-prod.yml (runs on git tag)\n```yaml\nname: Deploy Production\non:\n  push:\n    tags: ['v*']\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    environment: production  # Requires manual approval in GitHub\n    steps:\n      - uses: actions/checkout@v3\n      - name: Blue-green deployment\n        run: |\n          # Deploy to green environment\n          kubectl set image deployment/api-green api=api:${{ github.ref_name }}\n          kubectl rollout status deployment/api-green --timeout=10m\n\n          # Run smoke tests on green\n          npm run test:smoke -- --env green\n\n          # Traffic switch: 0% \u2192 10% \u2192 50% \u2192 100%\n          ./scripts/traffic-switch.sh green 10\n          sleep 300  # Monitor for 5 minutes\n\n          ./scripts/traffic-switch.sh green 50\n          sleep 300\n\n          ./scripts/traffic-switch.sh green 100\n\n          # Scale down blue environment\n          kubectl scale deployment/api-blue --replicas=0\n\n      - name: Create GitHub Release\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: Release ${{ github.ref }}\n          body: |\n            See CHANGELOG.md for details\n\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\ud83d\ude80 Deployed to production: ${{ github.ref_name }}\"\n            }\n```\n\nSecrets configuration:\n- AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY: For ECR push\n- KUBECONFIG: Kubernetes cluster access\n- SNYK_TOKEN: Security scanning\n- SLACK_WEBHOOK_URL: Notifications\n- CODECOV_TOKEN: Coverage upload\n\nBranch protection rules:\n- Require status checks to pass: lint, test, security\n- Require 1 approving review\n- Require linear history (no merge commits)\n- Require signed commits (GPG)\n\nDeployment notifications:\n- Slack: Post to #deployments channel with commit SHA, author, status\n- Email: Send to on-call engineer if production deployment fails\n- PagerDuty: Create incident if deployment fails (rollback required)\n\nRollback procedure:\n- Manual rollback: Re-run deploy workflow with previous git tag\n- Automatic rollback: If smoke tests fail, revert traffic to blue\n\nCost optimization:\n- Use GitHub-hosted runners (free for public repos)\n- Cache npm dependencies: actions/cache@v3 (saves 2 min per build)\n- Cancel redundant runs: concurrency group (auto-cancel old PR runs)\n\nMonitoring:\n- Track deployment frequency: Target 10+ deployments/week\n- Track lead time: PR opened \u2192 production, target <4 hours\n- Track failure rate: Target <5% failed deployments\n- Track MTTR: Mean time to recovery, target <30 minutes",
        "files_touched": [
          ".github/workflows/ci.yml",
          ".github/workflows/deploy-staging.yml",
          ".github/workflows/deploy-prod.yml",
          "scripts/traffic-switch.sh"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5161707442371986,
        "is_confident": true
      },
      {
        "task_id": "DOC-02",
        "title": "Generate OpenAPI 3.1 specification with request/response examples",
        "description": "Create comprehensive OpenAPI specification for all REST API endpoints with rich examples.\n\nOpenAPI file structure (openapi.yaml):\n\n```yaml\nopenapi: 3.1.0\ninfo:\n  title: Company API\n  version: 1.2.3\n  description: REST API for company platform\n  contact:\n    email: api-team@company.com\nservers:\n  - url: https://api.company.com/v1\n    description: Production\n  - url: https://api-staging.company.com/v1\n    description: Staging\n```\n\nAuthentication:\n- Security scheme: Bearer JWT token\n- Header: Authorization: Bearer <token>\n- Token obtained from POST /auth/login\n- Include security requirement on all protected endpoints\n\nEndpoint documentation (30 endpoints total):\n\nExample: GET /users\n```yaml\n/users:\n  get:\n    summary: List users with pagination\n    operationId: listUsers\n    tags: [Users]\n    parameters:\n      - name: cursor\n        in: query\n        schema: {type: string}\n        description: Pagination cursor from previous response\n      - name: limit\n        in: query\n        schema: {type: integer, minimum: 1, maximum: 100, default: 50}\n      - name: role\n        in: query\n        schema: {type: string, enum: [admin, user, guest]}\n    responses:\n      '200':\n        description: Successful response\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                users:\n                  type: array\n                  items: {$ref: '#/components/schemas/User'}\n                next_cursor: {type: string, nullable: true}\n            examples:\n              page1:\n                summary: First page of results\n                value:\n                  users: [{id: 1, email: \"alice@example.com\", role: \"admin\"}]\n                  next_cursor: \"eyJpZCI6MX0=\"\n      '401': {$ref: '#/components/responses/Unauthorized'}\n      '429': {$ref: '#/components/responses/RateLimited'}\n```\n\nSchemas (components/schemas):\n- User: id, email, display_name, role, created_at\n- Error: code, message, details\n- PaginationMeta: cursor, limit, has_more\n\nResponse examples:\n- Include success case (200)\n- Include error cases (400, 401, 404, 500)\n- Include edge cases (empty results, max limit exceeded)\n\nRate limiting documentation:\n- Global: 1000 requests/hour per IP\n- Per-endpoint: Varies (auth: 10/min, search: 100/min)\n- Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- 429 response includes Retry-After header\n\nCode generation:\n- Generate TypeScript types: openapi-typescript openapi.yaml -o types/api.ts\n- Generate client SDK: openapi-generator-cli generate -i openapi.yaml -g typescript-axios -o sdk/\n- Validate spec: openapi-generator-cli validate -i openapi.yaml\n\nInteractive documentation:\n- Host Swagger UI: Serve openapi.yaml at https://api.company.com/docs\n- Try it out: Allow users to make test requests directly from docs\n- Authentication: Users can input their JWT token in Swagger UI\n\nVersioning:\n- API version in URL: /v1/users\n- Breaking changes require new version: /v2/users\n- Document deprecated endpoints: deprecated: true, description: \"Use /v2/users instead\"\n\nValidation:\n- Ensure all endpoints documented (compare with actual routes)\n- Ensure all schemas used (no orphaned definitions)\n- Ensure examples valid (match schema)",
        "files_touched": [
          "docs/openapi.yaml",
          "docs/api-reference.md",
          "scripts/generate-docs.sh",
          "docs/swagger-ui.html"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.513958494343147,
        "is_confident": true
      },
      {
        "task_id": "IMP-TEST-02",
        "title": "Increase payment processing unit test coverage to 95% (focus edge cases)",
        "description": "Expand test coverage for payment module from current 60% to 95%, focusing on error scenarios.\n\nCurrent gaps (from coverage report):\n- PaymentProcessor.processCharge(): 45% covered (missing error paths)\n- RefundManager.partialRefund(): 20% covered (no edge cases tested)\n- CurrencyConverter.convert(): 0% covered (NO TESTS!)\n\nTest scenarios to add:\n\n1. Payment failures:\n   - Card declined (insufficient funds): Verify error code CARD_DECLINED\n   - Card expired: Verify error code EXPIRED_CARD\n   - Invalid CVV: Verify error code INVALID_CVV\n   - Network timeout (5s): Verify retry logic (3 attempts with exponential backoff)\n   - Gateway error 500: Verify fallback to secondary payment provider\n\n2. Partial refunds:\n   - Refund $50 of $100 charge: Verify remaining balance $50\n   - Multiple partial refunds totaling original amount: Verify full refund\n   - Refund exceeds original amount: Throw error \"Refund exceeds charge amount\"\n   - Refund already-refunded charge: Throw error \"Charge already refunded\"\n\n3. Currency conversion:\n   - USD to EUR: Verify exchange rate within 1% of current rate (use ECB API)\n   - Unsupported currency (XYZ): Throw error \"Currency XYZ not supported\"\n   - Conversion with rounding: $10.999 USD \u2192 \u20ac10.00 (round to 2 decimals)\n   - Same currency (USD to USD): Return original amount (no conversion)\n\n4. Concurrency:\n   - Process 100 payments simultaneously: All succeed or fail independently (no race conditions)\n   - Refund same charge twice concurrently: Only one succeeds (use database transaction)\n\nTest utilities:\n- Mock Stripe API responses (use nock or MSW)\n- Test fixtures: createTestCharge(), createTestRefund()\n- Assertions: toHaveBeenCalledWith(expectedParams), toThrow(ExpectedError)\n\nPerformance:\n- All tests complete in <5s (use mocks, no real API calls)\n- Parallel test execution (Jest --maxWorkers=4)",
        "files_touched": [
          "src/payment/processor.test.ts",
          "src/payment/refunds.test.ts",
          "src/payment/currency.test.ts",
          "src/payment/__mocks__/stripe.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5129584020000703,
        "is_confident": true
      },
      {
        "task_id": "IMP-OBS-01",
        "title": "Instrument API layer with OpenTelemetry distributed tracing to Jaeger",
        "description": "Add OpenTelemetry tracing to capture request flows through API \u2192 database \u2192 external services.\n\nInstrumentation approach:\n- Use @opentelemetry/sdk-node for auto-instrumentation\n- Export traces to Jaeger (localhost:14268) via OTLP\n- Capture spans for: HTTP requests, database queries, Redis operations, external API calls\n\nSpan structure:\n- Root span: http.server (entire request/response cycle)\n  - Attributes: http.method, http.url, http.status_code, http.user_agent\n- Child spans:\n  - db.query (for each SQL query): db.statement, db.table, db.duration_ms\n  - redis.operation (get/set/del): redis.key, redis.ttl\n  - http.client (external API calls): http.url, http.method, http.status_code\n\nCustom spans:\n- Add manual spans for business logic: tracer.startSpan('process_order')\n- Add span events: span.addEvent('validation_failed', {reason: 'invalid_email'})\n- Add span links: Link payment span to order span (trace causality)\n\nPerformance:\n- Sampling: 10% of requests in production (100% in dev)\n- Batch export: Buffer 100 spans, flush every 5s\n- Low overhead: <5ms per request (confirmed with benchmark)\n\nConfiguration:\n- Environment variables: OTEL_EXPORTER_JAEGER_ENDPOINT, OTEL_SERVICE_NAME=api-server\n- Graceful degradation: If Jaeger unavailable, log warning and continue\n\nVerification:\n- Generate test traffic\n- Open Jaeger UI (http://localhost:16686)\n- Search for traces, verify complete request flow visible\n- Verify spans show correct duration, attributes, errors\n\nError tracking:\n- Failed requests: span.setStatus(SpanStatusCode.ERROR)\n- Exception details: span.recordException(error)\n- Error rate alert: If >5% requests have error status, alert",
        "files_touched": [
          "src/tracing/tracer.ts",
          "src/middleware/tracing.ts",
          "src/config/otel.ts",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5086115674797661,
        "is_confident": true
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "IMP-PERF-01",
      "title": "Implement Redis caching layer with TTL and cache invalidation",
      "description": "Add Redis caching for frequently accessed data (user sessions, product catalog) to reduce database load by 80%.\n\nCaching strategy:\n\n1. User sessions (high read frequency):\n   - Key: session:{session_id}\n   - Value: {user_id, role, permissions, expires_at}\n   - TTL: 15 minutes (refresh on each request)\n   - Invalidation: On logout or password change\n   - Pattern: Read-through cache (check Redis, fallback to DB, populate cache)\n\n2. Product catalog (read-heavy, infrequent updates):\n   - Key: product:{product_id}\n   - Value: {id, name, price, description, inventory, images}\n   - TTL: 1 hour\n   - Invalidation: On product update (PATCH /products/:id)\n   - Pattern: Cache-aside (application manages cache explicitly)\n\n3. API rate limits (write-heavy):\n   - Key: ratelimit:{ip}:{endpoint}\n   - Value: Request count\n   - TTL: 1 minute (sliding window)\n   - Increment on each request: INCR key, check if > limit\n\nRedis client setup:\n- Use ioredis library (supports Redis Cluster, pipelining)\n- Connection pool: 10 connections max\n- Retry strategy: Exponential backoff (1s, 2s, 4s, max 10s)\n- Error handling: If Redis unavailable, fallback to database (log warning)\n\nCache patterns implementation:\n\nRead-through cache:\n```typescript\nasync function getUser(userId: string): Promise<User> {\n  // Try cache first\n  const cached = await redis.get(`user:${userId}`);\n  if (cached) {\n    return JSON.parse(cached);\n  }\n\n  // Cache miss: fetch from database\n  const user = await db.users.findUnique({where: {id: userId}});\n\n  // Populate cache with 15min TTL\n  await redis.setex(`user:${userId}`, 900, JSON.stringify(user));\n\n  return user;\n}\n```\n\nCache invalidation:\n```typescript\nasync function updateProduct(id: string, data: UpdateData): Promise<Product> {\n  // Update database\n  const product = await db.products.update({where: {id}, data});\n\n  // Invalidate cache\n  await redis.del(`product:${id}`);\n\n  // Optional: Also invalidate list caches\n  await redis.del('products:list:page:*');  // Use SCAN to find keys\n\n  return product;\n}\n```\n\nPerformance optimization:\n- Pipeline multiple operations: redis.pipeline().get('key1').get('key2').exec()\n- Use mget for bulk reads: redis.mget(['key1', 'key2', 'key3'])\n- Compress large values: Use zlib to gzip JSON before storing\n\nMonitoring:\n- Cache hit rate: hits / (hits + misses), target >90%\n- Eviction rate: Monitor evicted_keys metric, alert if >1000/min\n- Memory usage: Alert if >80% of max memory\n- Connection errors: Alert on connection failures\n\nCache warming:\n- On application startup: Preload hot data (top 100 products)\n- Scheduled job: Refresh catalog every hour\n- Avoid thundering herd: Use locks (SET key NX EX 10) for cache regeneration\n\nTests:\n- Cache hit: Verify second read from cache (faster than DB)\n- Cache miss: Verify fallback to DB\n- Cache invalidation: Update data, verify cache cleared\n- Redis failure: Verify graceful degradation to DB\n- Concurrent requests: No cache stampede (use locking)",
      "files_touched": [
        "src/cache/redis-client.ts",
        "src/cache/cache-strategy.ts",
        "src/cache/redis-client.test.ts",
        "src/middleware/rate-limit.ts"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "DOC-01",
        "title": "Write comprehensive production deployment guide with blue-green strategy",
        "description": "Create step-by-step deployment documentation for production environment with zero-downtime blue-green deployments.\n\nDocument structure:\n\n1. Prerequisites:\n   - AWS account with EC2, RDS, S3, Route53 access\n   - Kubernetes cluster (EKS) with kubectl configured\n   - Docker registry access (ECR)\n   - Terraform v1.5+ for infrastructure\n   - Required secrets in AWS Secrets Manager\n\n2. Pre-deployment checklist:\n   - Run test suite: npm test (must be 100% passing)\n   - Run security scan: npm audit (0 high/critical vulnerabilities)\n   - Build Docker image: docker build -t api:v1.2.3 .\n   - Push to registry: docker push ecr.../api:v1.2.3\n   - Database migrations ready: Review migrations/*.sql\n   - Feature flags configured: Check LaunchDarkly dashboard\n\n3. Blue-green deployment steps:\n\n   Step 1: Deploy to GREEN environment (staging)\n   - Update Kubernetes deployment: kubectl set image deployment/api-green api=api:v1.2.3\n   - Wait for rollout: kubectl rollout status deployment/api-green (5 min timeout)\n   - Run smoke tests: curl https://api-green.company.com/health\n   - Verify metrics: Check Grafana dashboard (request rate, error rate, latency)\n\n   Step 2: Run database migrations (if needed)\n   - Migrations run from Kubernetes job: kubectl apply -f k8s/migrate-job.yaml\n   - Forward-compatible only (old code still works): ADD COLUMN (not DROP COLUMN)\n   - Verify migration success: Check job logs, query database\n\n   Step 3: Traffic switch (blue \u2192 green)\n   - Update Route53 weighted routing: 0% blue, 100% green\n   - Monitor error rates: Watch for spike in errors (rollback trigger)\n   - Gradual rollout: 10% \u2192 50% \u2192 100% over 30 minutes\n   - Rollback criteria: Error rate >5% OR p95 latency >500ms OR manual abort\n\n   Step 4: Verify production traffic\n   - Check logs: kubectl logs -f deployment/api-green (look for errors)\n   - Check metrics: Request rate matches expected (no traffic loss)\n   - Check APM: Verify traces in Datadog show expected flow\n   - User testing: QA team tests critical flows in production\n\n   Step 5: Decommission BLUE environment\n   - Scale down old deployment: kubectl scale deployment/api-blue --replicas=0\n   - Keep for 24h as rollback option\n   - After 24h: Delete blue deployment\n\n4. Rollback procedure:\n   - Immediate rollback: kubectl set image deployment/api-green api=api:v1.2.2 (previous version)\n   - Or traffic switch: Route53 100% to blue (old version still running)\n   - Investigate issues: Check logs, metrics, error reports\n   - Fix forward: Deploy hotfix to green, switch traffic back\n\n5. Post-deployment:\n   - Update release notes: docs/CHANGELOG.md\n   - Notify team: Slack message to #deployments channel\n   - Monitor for 1 hour: Watch metrics, error logs, user reports\n   - Tag release: git tag v1.2.3 && git push --tags\n\n6. Troubleshooting common issues:\n   - Issue: Deployment stuck in \"Progressing\" state\n     - Cause: Image pull error (invalid tag)\n     - Fix: Verify image exists: docker pull ecr.../api:v1.2.3\n\n   - Issue: Pods crashing (CrashLoopBackOff)\n     - Cause: Missing environment variable or secret\n     - Fix: Check pod logs: kubectl logs api-green-xxxx\n\n   - Issue: High error rate after deployment\n     - Cause: Breaking change in API, clients sending old format\n     - Fix: Rollback immediately, implement backward compatibility\n\nAppendices:\n- A: Environment variables reference (50+ vars with descriptions)\n- B: Kubernetes resource definitions (deployment.yaml, service.yaml)\n- C: Monitoring runbooks (what to do when alerts fire)\n- D: Database migration best practices",
        "files_touched": [
          "docs/deployment.md",
          "docs/troubleshooting.md",
          "docs/runbooks.md",
          "k8s/deployment.yaml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5223141257233569,
        "is_confident": true
      },
      {
        "task_id": "IMP-API-01",
        "title": "Add GET /api/v1/users endpoint with cursor-based pagination",
        "description": "Implement REST API endpoint for listing users with cursor-based pagination (not offset/limit).\n\nTechnical requirements:\n- Endpoint: GET /api/v1/users?cursor=<id>&limit=50\n- Return fields: id, email, display_name, created_at, role\n- Default limit: 50, max limit: 100\n- Sort by: id ASC (stable ordering for cursor)\n- Response includes next_cursor for pagination\n- Filter support: ?role=admin,user&status=active\n- Return 400 for invalid cursor, 401 for unauthenticated\n\nImplementation approach:\n- Use Prisma ORM with cursor pagination\n- Add index on (id, created_at) for performance\n- Implement CursorPaginationDTO with Zod validation\n- Unit tests: pagination, filtering, edge cases (empty result, last page)\n- OpenAPI spec in docs/api.yaml\n\nAcceptance criteria:\n- Paginate through 10,000 users in <2s total\n- No duplicate users across pages\n- Works with concurrent updates (stable cursor)",
        "files_touched": [
          "src/api/users/list.ts",
          "src/api/users/list.test.ts",
          "src/dto/pagination.ts",
          "docs/api.yaml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5106723538614579,
        "is_confident": true
      },
      {
        "task_id": "CRIT-PERF-01",
        "title": "Optimize landing page load time from 8s to <3s (Core Web Vitals)",
        "description": "Landing page loads in 8 seconds with 20MB of unoptimized images, failing Core Web Vitals.\n\nCurrent performance (Lighthouse score):\n- LCP (Largest Contentful Paint): 6.2s (target: <2.5s) \u274c\n- FID (First Input Delay): 180ms (target: <100ms) \u274c\n- CLS (Cumulative Layout Shift): 0.42 (target: <0.1) \u274c\n- Lighthouse score: 32/100 (Poor)\n\nPerformance bottlenecks (from DevTools):\n1. Images: 20MB total, 12 images at full resolution (4000x3000px)\n2. JavaScript: 2MB bundle size (React, unused libraries)\n3. Fonts: 800KB custom fonts loading blocking render\n4. No caching: Every visit downloads everything again\n\nOptimization plan:\n\n1. Image optimization:\n   - Convert to WebP format (70% size reduction)\n   - Serve responsive images with srcset:\n     ```html\n     <img\n       src=\"hero-800w.webp\"\n       srcset=\"hero-400w.webp 400w, hero-800w.webp 800w, hero-1200w.webp 1200w\"\n       sizes=\"(max-width: 600px) 400px, (max-width: 1200px) 800px, 1200px\"\n       loading=\"lazy\"\n       decoding=\"async\"\n     />\n     ```\n   - Lazy load below-fold images (loading=\"lazy\")\n   - Add CDN caching (Cloudflare): Cache-Control: max-age=31536000, immutable\n   - Expected: 20MB \u2192 2MB (10x reduction)\n\n2. Code splitting:\n   - Split bundle by route: React.lazy(() => import('./About'))\n   - Load above-fold code first (~100KB initial bundle)\n   - Defer non-critical scripts: <script defer src=\"analytics.js\">\n   - Tree-shake unused code: Check webpack-bundle-analyzer\n   - Expected: 2MB \u2192 300KB initial load (6x reduction)\n\n3. Font optimization:\n   - Use font-display: swap (show fallback font immediately)\n   - Preload critical fonts: <link rel=\"preload\" as=\"font\" href=\"font.woff2\">\n   - Subset fonts (Latin characters only): 800KB \u2192 80KB\n   - Use system fonts for body text (zero load time)\n\n4. Caching strategy:\n   - Service Worker: Cache static assets for offline use\n   - HTTP headers: Cache-Control: max-age=31536000 for immutable assets\n   - Use content hashing in filenames: hero-abc123.webp (cache forever)\n\n5. Critical CSS:\n   - Inline above-fold CSS in <head> (~10KB)\n   - Defer non-critical CSS: <link rel=\"preload\" as=\"style\" href=\"main.css\">\n   - Remove unused CSS: Use PurgeCSS (50KB \u2192 8KB)\n\nImplementation steps:\n1. Image processing: Use sharp library to generate WebP + multiple sizes\n2. Update image components: Use <picture> element with WebP + JPEG fallback\n3. Webpack config: Add code splitting, bundle analyzer\n4. Font subsetting: Use pyftsubset to extract Latin glyphs\n5. Deploy behind Cloudflare CDN with caching rules\n\nVerification:\n- Run Lighthouse in CI: Fail build if score <90\n- Test on real devices: iPhone 12, Pixel 5 (3G connection)\n- Measure field data: Send Core Web Vitals to analytics (real user monitoring)\n- Compare before/after:\n  - LCP: 6.2s \u2192 1.8s \u2705\n  - FID: 180ms \u2192 45ms \u2705\n  - CLS: 0.42 \u2192 0.05 \u2705\n  - Lighthouse: 32 \u2192 95 \u2705",
        "files_touched": [
          "src/components/ImageOptimizer.tsx",
          "webpack.config.js",
          "src/utils/image-optimizer.ts",
          "scripts/optimize-images.sh"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.4769311113939369,
        "is_confident": false
      },
      {
        "task_id": "DOC-02",
        "title": "Generate OpenAPI 3.1 specification with request/response examples",
        "description": "Create comprehensive OpenAPI specification for all REST API endpoints with rich examples.\n\nOpenAPI file structure (openapi.yaml):\n\n```yaml\nopenapi: 3.1.0\ninfo:\n  title: Company API\n  version: 1.2.3\n  description: REST API for company platform\n  contact:\n    email: api-team@company.com\nservers:\n  - url: https://api.company.com/v1\n    description: Production\n  - url: https://api-staging.company.com/v1\n    description: Staging\n```\n\nAuthentication:\n- Security scheme: Bearer JWT token\n- Header: Authorization: Bearer <token>\n- Token obtained from POST /auth/login\n- Include security requirement on all protected endpoints\n\nEndpoint documentation (30 endpoints total):\n\nExample: GET /users\n```yaml\n/users:\n  get:\n    summary: List users with pagination\n    operationId: listUsers\n    tags: [Users]\n    parameters:\n      - name: cursor\n        in: query\n        schema: {type: string}\n        description: Pagination cursor from previous response\n      - name: limit\n        in: query\n        schema: {type: integer, minimum: 1, maximum: 100, default: 50}\n      - name: role\n        in: query\n        schema: {type: string, enum: [admin, user, guest]}\n    responses:\n      '200':\n        description: Successful response\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                users:\n                  type: array\n                  items: {$ref: '#/components/schemas/User'}\n                next_cursor: {type: string, nullable: true}\n            examples:\n              page1:\n                summary: First page of results\n                value:\n                  users: [{id: 1, email: \"alice@example.com\", role: \"admin\"}]\n                  next_cursor: \"eyJpZCI6MX0=\"\n      '401': {$ref: '#/components/responses/Unauthorized'}\n      '429': {$ref: '#/components/responses/RateLimited'}\n```\n\nSchemas (components/schemas):\n- User: id, email, display_name, role, created_at\n- Error: code, message, details\n- PaginationMeta: cursor, limit, has_more\n\nResponse examples:\n- Include success case (200)\n- Include error cases (400, 401, 404, 500)\n- Include edge cases (empty results, max limit exceeded)\n\nRate limiting documentation:\n- Global: 1000 requests/hour per IP\n- Per-endpoint: Varies (auth: 10/min, search: 100/min)\n- Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- 429 response includes Retry-After header\n\nCode generation:\n- Generate TypeScript types: openapi-typescript openapi.yaml -o types/api.ts\n- Generate client SDK: openapi-generator-cli generate -i openapi.yaml -g typescript-axios -o sdk/\n- Validate spec: openapi-generator-cli validate -i openapi.yaml\n\nInteractive documentation:\n- Host Swagger UI: Serve openapi.yaml at https://api.company.com/docs\n- Try it out: Allow users to make test requests directly from docs\n- Authentication: Users can input their JWT token in Swagger UI\n\nVersioning:\n- API version in URL: /v1/users\n- Breaking changes require new version: /v2/users\n- Document deprecated endpoints: deprecated: true, description: \"Use /v2/users instead\"\n\nValidation:\n- Ensure all endpoints documented (compare with actual routes)\n- Ensure all schemas used (no orphaned definitions)\n- Ensure examples valid (match schema)",
        "files_touched": [
          "docs/openapi.yaml",
          "docs/api-reference.md",
          "scripts/generate-docs.sh",
          "docs/swagger-ui.html"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.4740345689443898,
        "is_confident": false
      },
      {
        "task_id": "IMP-OBS-02",
        "title": "Build Grafana dashboard for application health with Prometheus metrics",
        "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
        "files_touched": [
          "src/metrics/prometheus.ts",
          "src/metrics/collectors.ts",
          "grafana/dashboard.json",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.4621619464681832,
        "is_confident": false
      }
    ],
    "count": 5
  },
  {
    "query_task": {
      "task_id": "IMP-INFRA-01",
      "title": "Set up GitHub Actions CI/CD with automated testing and blue-green deployment",
      "description": "Automate entire software delivery pipeline: build \u2192 test \u2192 deploy to staging \u2192 deploy to production.\n\nGitHub Actions workflow structure:\n\nWorkflow 1: ci.yml (runs on every PR)\n```yaml\nname: CI\non: [pull_request]\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm run lint  # ESLint + Prettier check\n      - run: npm run typecheck  # TypeScript compiler\n\n  test:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:15\n        env: {POSTGRES_PASSWORD: test}\n      redis:\n        image: redis:7\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npm test -- --coverage  # Jest with coverage\n      - uses: codecov/codecov-action@v3  # Upload coverage report\n      - run: npm run test:e2e  # Playwright E2E tests\n\n  security:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm audit --audit-level=high  # Fail on high/critical vulns\n      - uses: snyk/actions/node@master  # Additional security scan\n        env:\n          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}\n\n  build:\n    runs-on: ubuntu-latest\n    needs: [lint, test, security]  # Only build if all checks pass\n    steps:\n      - uses: actions/checkout@v3\n      - run: docker build -t api:${{ github.sha }} .\n      - run: docker push ecr.../api:${{ github.sha }}\n```\n\nWorkflow 2: deploy-staging.yml (runs on merge to main)\n```yaml\nname: Deploy Staging\non:\n  push:\n    branches: [main]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to staging\n        run: |\n          kubectl set image deployment/api-staging api=api:${{ github.sha }}\n          kubectl rollout status deployment/api-staging --timeout=5m\n      - name: Run smoke tests\n        run: npm run test:smoke -- --env staging\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\u2705 Deployed to staging: ${{ github.sha }}\"\n            }\n```\n\nWorkflow 3: deploy-prod.yml (runs on git tag)\n```yaml\nname: Deploy Production\non:\n  push:\n    tags: ['v*']\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    environment: production  # Requires manual approval in GitHub\n    steps:\n      - uses: actions/checkout@v3\n      - name: Blue-green deployment\n        run: |\n          # Deploy to green environment\n          kubectl set image deployment/api-green api=api:${{ github.ref_name }}\n          kubectl rollout status deployment/api-green --timeout=10m\n\n          # Run smoke tests on green\n          npm run test:smoke -- --env green\n\n          # Traffic switch: 0% \u2192 10% \u2192 50% \u2192 100%\n          ./scripts/traffic-switch.sh green 10\n          sleep 300  # Monitor for 5 minutes\n\n          ./scripts/traffic-switch.sh green 50\n          sleep 300\n\n          ./scripts/traffic-switch.sh green 100\n\n          # Scale down blue environment\n          kubectl scale deployment/api-blue --replicas=0\n\n      - name: Create GitHub Release\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: Release ${{ github.ref }}\n          body: |\n            See CHANGELOG.md for details\n\n      - name: Notify Slack\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"\ud83d\ude80 Deployed to production: ${{ github.ref_name }}\"\n            }\n```\n\nSecrets configuration:\n- AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY: For ECR push\n- KUBECONFIG: Kubernetes cluster access\n- SNYK_TOKEN: Security scanning\n- SLACK_WEBHOOK_URL: Notifications\n- CODECOV_TOKEN: Coverage upload\n\nBranch protection rules:\n- Require status checks to pass: lint, test, security\n- Require 1 approving review\n- Require linear history (no merge commits)\n- Require signed commits (GPG)\n\nDeployment notifications:\n- Slack: Post to #deployments channel with commit SHA, author, status\n- Email: Send to on-call engineer if production deployment fails\n- PagerDuty: Create incident if deployment fails (rollback required)\n\nRollback procedure:\n- Manual rollback: Re-run deploy workflow with previous git tag\n- Automatic rollback: If smoke tests fail, revert traffic to blue\n\nCost optimization:\n- Use GitHub-hosted runners (free for public repos)\n- Cache npm dependencies: actions/cache@v3 (saves 2 min per build)\n- Cancel redundant runs: concurrency group (auto-cancel old PR runs)\n\nMonitoring:\n- Track deployment frequency: Target 10+ deployments/week\n- Track lead time: PR opened \u2192 production, target <4 hours\n- Track failure rate: Target <5% failed deployments\n- Track MTTR: Mean time to recovery, target <30 minutes",
      "files_touched": [
        ".github/workflows/ci.yml",
        ".github/workflows/deploy-staging.yml",
        ".github/workflows/deploy-prod.yml",
        "scripts/traffic-switch.sh"
      ]
    },
    "similar_tasks": [
      {
        "task_id": "IMP-TEST-02",
        "title": "Increase payment processing unit test coverage to 95% (focus edge cases)",
        "description": "Expand test coverage for payment module from current 60% to 95%, focusing on error scenarios.\n\nCurrent gaps (from coverage report):\n- PaymentProcessor.processCharge(): 45% covered (missing error paths)\n- RefundManager.partialRefund(): 20% covered (no edge cases tested)\n- CurrencyConverter.convert(): 0% covered (NO TESTS!)\n\nTest scenarios to add:\n\n1. Payment failures:\n   - Card declined (insufficient funds): Verify error code CARD_DECLINED\n   - Card expired: Verify error code EXPIRED_CARD\n   - Invalid CVV: Verify error code INVALID_CVV\n   - Network timeout (5s): Verify retry logic (3 attempts with exponential backoff)\n   - Gateway error 500: Verify fallback to secondary payment provider\n\n2. Partial refunds:\n   - Refund $50 of $100 charge: Verify remaining balance $50\n   - Multiple partial refunds totaling original amount: Verify full refund\n   - Refund exceeds original amount: Throw error \"Refund exceeds charge amount\"\n   - Refund already-refunded charge: Throw error \"Charge already refunded\"\n\n3. Currency conversion:\n   - USD to EUR: Verify exchange rate within 1% of current rate (use ECB API)\n   - Unsupported currency (XYZ): Throw error \"Currency XYZ not supported\"\n   - Conversion with rounding: $10.999 USD \u2192 \u20ac10.00 (round to 2 decimals)\n   - Same currency (USD to USD): Return original amount (no conversion)\n\n4. Concurrency:\n   - Process 100 payments simultaneously: All succeed or fail independently (no race conditions)\n   - Refund same charge twice concurrently: Only one succeeds (use database transaction)\n\nTest utilities:\n- Mock Stripe API responses (use nock or MSW)\n- Test fixtures: createTestCharge(), createTestRefund()\n- Assertions: toHaveBeenCalledWith(expectedParams), toThrow(ExpectedError)\n\nPerformance:\n- All tests complete in <5s (use mocks, no real API calls)\n- Parallel test execution (Jest --maxWorkers=4)",
        "files_touched": [
          "src/payment/processor.test.ts",
          "src/payment/refunds.test.ts",
          "src/payment/currency.test.ts",
          "src/payment/__mocks__/stripe.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.6854532551949154,
        "is_confident": true
      },
      {
        "task_id": "IMP-OBS-02",
        "title": "Build Grafana dashboard for application health with Prometheus metrics",
        "description": "Create Grafana dashboard showing key application health metrics from Prometheus.\n\nDashboard layout (4 panels):\n\nPanel 1: Request Rate (top left)\n- Metric: rate(http_requests_total[5m])\n- Chart: Line graph, last 1 hour\n- Color: Blue\n- Show: Requests per second by endpoint\n- Alert: If rate drops >50% from baseline, warn (service degradation)\n\nPanel 2: Error Rate (top right)\n- Metric: sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))\n- Chart: Line graph with threshold line at 5%\n- Color: Red when >5%, yellow 1-5%, green <1%\n- Alert: If error rate >5% for 5 minutes, critical alert (page on-call)\n\nPanel 3: Response Time (bottom left)\n- Metric: histogram_quantile(0.95, http_request_duration_seconds_bucket)\n- Chart: Line graph showing p50, p95, p99\n- Show: Latency in milliseconds\n- Alert: If p95 >500ms for 10 minutes, warn (performance degradation)\n\nPanel 4: Database Connections (bottom right)\n- Metric: db_connections_active, db_connections_max\n- Chart: Gauge showing current/max ratio\n- Color: Green <70%, yellow 70-90%, red >90%\n- Alert: If connections >90% of max, critical (risk of connection exhaustion)\n\nAdditional metrics to collect:\n- http_requests_total{method, endpoint, status}: Counter\n- http_request_duration_seconds: Histogram (buckets: 0.01, 0.05, 0.1, 0.5, 1, 5)\n- db_connections_active, db_connections_max: Gauge\n- redis_operations_total{operation}: Counter\n\nPrometheus exporter:\n- Use prom-client library\n- Expose /metrics endpoint (port 9090)\n- Update every 15s (scrape interval)\n\nDashboard features:\n- Time range selector (last 1h, 6h, 24h, 7d)\n- Refresh: Auto-refresh every 30s\n- Variables: $environment (dev, staging, prod), $endpoint (filter by endpoint)\n\nSLO tracking:\n- SLO: 99.9% uptime, p95 latency <500ms, error rate <1%\n- Dashboard shows current vs SLO (green if meeting, red if violating)",
        "files_touched": [
          "src/metrics/prometheus.ts",
          "src/metrics/collectors.ts",
          "grafana/dashboard.json",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.6563739313660778,
        "is_confident": true
      },
      {
        "task_id": "DOC-02",
        "title": "Generate OpenAPI 3.1 specification with request/response examples",
        "description": "Create comprehensive OpenAPI specification for all REST API endpoints with rich examples.\n\nOpenAPI file structure (openapi.yaml):\n\n```yaml\nopenapi: 3.1.0\ninfo:\n  title: Company API\n  version: 1.2.3\n  description: REST API for company platform\n  contact:\n    email: api-team@company.com\nservers:\n  - url: https://api.company.com/v1\n    description: Production\n  - url: https://api-staging.company.com/v1\n    description: Staging\n```\n\nAuthentication:\n- Security scheme: Bearer JWT token\n- Header: Authorization: Bearer <token>\n- Token obtained from POST /auth/login\n- Include security requirement on all protected endpoints\n\nEndpoint documentation (30 endpoints total):\n\nExample: GET /users\n```yaml\n/users:\n  get:\n    summary: List users with pagination\n    operationId: listUsers\n    tags: [Users]\n    parameters:\n      - name: cursor\n        in: query\n        schema: {type: string}\n        description: Pagination cursor from previous response\n      - name: limit\n        in: query\n        schema: {type: integer, minimum: 1, maximum: 100, default: 50}\n      - name: role\n        in: query\n        schema: {type: string, enum: [admin, user, guest]}\n    responses:\n      '200':\n        description: Successful response\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                users:\n                  type: array\n                  items: {$ref: '#/components/schemas/User'}\n                next_cursor: {type: string, nullable: true}\n            examples:\n              page1:\n                summary: First page of results\n                value:\n                  users: [{id: 1, email: \"alice@example.com\", role: \"admin\"}]\n                  next_cursor: \"eyJpZCI6MX0=\"\n      '401': {$ref: '#/components/responses/Unauthorized'}\n      '429': {$ref: '#/components/responses/RateLimited'}\n```\n\nSchemas (components/schemas):\n- User: id, email, display_name, role, created_at\n- Error: code, message, details\n- PaginationMeta: cursor, limit, has_more\n\nResponse examples:\n- Include success case (200)\n- Include error cases (400, 401, 404, 500)\n- Include edge cases (empty results, max limit exceeded)\n\nRate limiting documentation:\n- Global: 1000 requests/hour per IP\n- Per-endpoint: Varies (auth: 10/min, search: 100/min)\n- Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- 429 response includes Retry-After header\n\nCode generation:\n- Generate TypeScript types: openapi-typescript openapi.yaml -o types/api.ts\n- Generate client SDK: openapi-generator-cli generate -i openapi.yaml -g typescript-axios -o sdk/\n- Validate spec: openapi-generator-cli validate -i openapi.yaml\n\nInteractive documentation:\n- Host Swagger UI: Serve openapi.yaml at https://api.company.com/docs\n- Try it out: Allow users to make test requests directly from docs\n- Authentication: Users can input their JWT token in Swagger UI\n\nVersioning:\n- API version in URL: /v1/users\n- Breaking changes require new version: /v2/users\n- Document deprecated endpoints: deprecated: true, description: \"Use /v2/users instead\"\n\nValidation:\n- Ensure all endpoints documented (compare with actual routes)\n- Ensure all schemas used (no orphaned definitions)\n- Ensure examples valid (match schema)",
        "files_touched": [
          "docs/openapi.yaml",
          "docs/api-reference.md",
          "scripts/generate-docs.sh",
          "docs/swagger-ui.html"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.638298299868388,
        "is_confident": true
      },
      {
        "task_id": "CRIT-OBS-01",
        "title": "Fix memory leak in background job processor (25GB heap growth over 24h)",
        "description": "Worker process memory grows from 500MB to 25GB over 24 hours, crashing with OOM error.\n\nSymptoms:\n- Worker starts: 500MB heap\n- After 24h: 25GB heap (50x growth!)\n- Eventually crashes: \"JavaScript heap out of memory\"\n- Requires manual restart every day\n\nInvestigation steps:\n1. Take heap snapshots: node --expose-gc --max-old-space-size=2048 worker.js\n2. Capture snapshots: Every hour for 24 hours\n3. Analyze with Chrome DevTools Memory Profiler\n4. Compare snapshots: Identify growing objects\n\nFindings (from heap analysis):\n- Retained size: 23GB in Array of Job objects\n- Retaining path: jobQueue \u2192 processedJobs \u2192 Job[]\n- Root cause: processedJobs.push(job) on every job completion, never cleared\n- Jobs accumulate: 1000 jobs/hour * 24 hours = 24,000 jobs * 1MB each = 24GB\n\nFix:\n1. Remove processedJobs array (not needed, jobs logged to database)\n2. Alternative: Limit array size with LRU cache (keep last 1000 jobs only)\n3. Add memory monitoring: Log heap size every minute, alert if >2GB\n\nVerification approach:\n- Run worker for 48 hours with fix\n- Monitor heap size: Should stay flat at ~500MB\n- Load test: Process 100,000 jobs, verify no memory growth\n\nAdditional improvements:\n- Add job.cleanup() method to release resources (close file handles, clear buffers)\n- Use WeakMap for temporary job metadata (auto garbage collected)\n- Set maxJobRetention: 1000 (after 1000 jobs, clear oldest)\n\nMemory profile comparison:\n- Before: 500MB \u2192 25GB over 24h (linear growth)\n- After: 500MB \u2192 520MB over 48h (stable)\n\nTests:\n- Process 10,000 jobs in test, verify heap <1GB\n- Check no memory leaks with --expose-gc and manual GC after each job",
        "files_touched": [
          "src/workers/job-processor.ts",
          "src/workers/cleanup.ts",
          "src/workers/memory-monitor.ts",
          "src/workers/job-processor.test.ts"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5694650446175011,
        "is_confident": true
      },
      {
        "task_id": "IMP-OBS-01",
        "title": "Instrument API layer with OpenTelemetry distributed tracing to Jaeger",
        "description": "Add OpenTelemetry tracing to capture request flows through API \u2192 database \u2192 external services.\n\nInstrumentation approach:\n- Use @opentelemetry/sdk-node for auto-instrumentation\n- Export traces to Jaeger (localhost:14268) via OTLP\n- Capture spans for: HTTP requests, database queries, Redis operations, external API calls\n\nSpan structure:\n- Root span: http.server (entire request/response cycle)\n  - Attributes: http.method, http.url, http.status_code, http.user_agent\n- Child spans:\n  - db.query (for each SQL query): db.statement, db.table, db.duration_ms\n  - redis.operation (get/set/del): redis.key, redis.ttl\n  - http.client (external API calls): http.url, http.method, http.status_code\n\nCustom spans:\n- Add manual spans for business logic: tracer.startSpan('process_order')\n- Add span events: span.addEvent('validation_failed', {reason: 'invalid_email'})\n- Add span links: Link payment span to order span (trace causality)\n\nPerformance:\n- Sampling: 10% of requests in production (100% in dev)\n- Batch export: Buffer 100 spans, flush every 5s\n- Low overhead: <5ms per request (confirmed with benchmark)\n\nConfiguration:\n- Environment variables: OTEL_EXPORTER_JAEGER_ENDPOINT, OTEL_SERVICE_NAME=api-server\n- Graceful degradation: If Jaeger unavailable, log warning and continue\n\nVerification:\n- Generate test traffic\n- Open Jaeger UI (http://localhost:16686)\n- Search for traces, verify complete request flow visible\n- Verify spans show correct duration, attributes, errors\n\nError tracking:\n- Failed requests: span.setStatus(SpanStatusCode.ERROR)\n- Exception details: span.recordException(error)\n- Error rate alert: If >5% requests have error status, alert",
        "files_touched": [
          "src/tracing/tracer.ts",
          "src/middleware/tracing.ts",
          "src/config/otel.ts",
          "docker-compose.yml"
        ],
        "outcome": {
          "status": "success"
        },
        "duration_ms": null,
        "quality": null,
        "complexity_score": null,
        "similarity": 0.5307487828240403,
        "is_confident": true
      }
    ],
    "count": 5
  }
]